
private fun pushTail ( root : Array < Any ? > ? , shift : Int , tail : Array < Any ? > ) : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > : Array < Any ? > :


: Array < Any ? > { if ( root.isEmpty() ) { if ( tailCarry != null ) { tailCarry = null } else { tailCarry = root } return tailCarry } else { if ( index >= root.size() ) { if ( tailCarry != null ) { tailCarry = null } else { tailCarry = root.get(index) } return tailCarry } else { if ( root.get(index).isLeaf() ) { if ( tailCarry != null ) { tailCarry = null } else { tailCarry = root.get(index) } return tailCarry } else { if ( tailCarry != null ) { tailCarry = null } else { tailCarry = root.get(index) } return tailCarry } } } } /** * Extracts the last leaf buffer from tri

private fun bufferFor ( index : Int ) : Array < Array < Any ? > ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
{ if ( varArgs ) { if ( ktTypeRef == psiType ) { return true } else { return false } } else { if ( ktTypeRef == psiType ) { return true } else { return false } } } /** * Compare erased types */ /** * Compare erased types */ /** * Compare erased types */ /** * Compare erased types */ /** * Compare erased types */ /** * Compare erased types */ /** * Compare erased types */ /** * Compare erased types */ /** * Compare erased types */ /** * Compare erased types */ /** * Compare erased types */ /** * Compare erased types */ /** * Compare erased types */ /** * Compare erased types */ /** * Compare erased types
it = new Iterator < T > (); * * @return [FlatIterator]. */ public Iterator < T > flatIter ( ) : Iterator < T > () { return this; } /** * Returns [Iterator]. */ public Iterator < T > iterator ( ) : Iterator < T > () { return this; } /** * Returns [Iterator]. */ public Iterator < T > iterator ( ) : Iterator < T > () { return this; } /** * Returns [Iterator]. */ public Iterator < T > iterator ( ) : Iterator < T > () { return this; } /** * Returns [Iterator]. */ public Iterator < T > iterator ( ) : Iterator < T > () { return this; } /** * Returns [Iterator]. */ public Iterator < T > iterator ( ) : Iterator < T > () { return this; } /** * Returns [Iterator]. */ public Iterator < T > iterator ( ) :
[] = [ ] | toList ( x : T ) : List < T > = x :: toList ( xs ) | toList ( xs : T ) : List < T > = xs :: toList ( xs ) | toList ( [] : T ) : List < T > = [ x ] | toList ( xs : T ) : List < T > = xs :: toList ( xs ) | toList ( [] : T ) : List < T > = [ x ] | toList ( xs : T ) : List < T > = xs :: toList ( xs ) | toList ( [] : T ) : List < T > = [ x ] | toList ( xs : T ) : List < T > = xs :: toList ( xs ) | toList ( [] : T ) : List < T > = [ x ] | toList ( xs : T ) : List < T > = xs :: toList ( xs ) | toList ( [] : T ) : List < T > = [ x ] | toList ( xs : T ) : List < T
( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) : List < List < T > > a ( ) :
( ) : List < List < List < T > > > a ( ) : List < List < List < T > > > a ( ) : List < List < List < T > > > a ( ) : List < List < List < T > > > a ( ) : List < List < List < T > > > a ( ) : List < List < List < T > > > a ( ) : List < List < List < T > > > a ( ) : List < List < List < T > > > a ( ) : List < List < List < T > > > a ( ) : List < List < List < T > > > a ( ) : List < List < List < T > > > a ( ) : List < List < List < T > > > a ( ) : List < List < List < T > > > a ( ) : List < List < List < T > > > a ( ) : List < List < List < T > > > a ( ) : List < List < List < T > > > a ( ) : List < List < List < T > > > a ( ) : List < List < List < T > > > a ( ) : List



( other : C ) : KtNDArray < Boolean > = KtNDArray < Boolean > . lt ( other : C ) = KtNDArray < Boolean > . lt ( other : C ) = KtNDArray < Boolean > . lt ( other : C ) = KtNDArray < Boolean > . lt ( other : C ) = KtNDArray < Boolean > . lt ( other : C ) = KtNDArray < Boolean > . lt ( other : C ) = KtNDArray < Boolean > . lt ( other : C ) = KtNDArray < Boolean > . lt ( other : C ) = KtNDArray < Boolean > . lt ( other : C ) = KtNDArray < Boolean > . lt ( other : C ) = KtNDArray < Boolean > . lt ( other : C ) = KtNDArray < Boolean > . lt ( other : C ) = KtNDArray < Boolean > . lt ( other : C ) = KtNDArray < Boolean
infix fun < T : Any , C : Number > KtNDArray < T > . le ( other : C ) : KtNDArray < T > . le ( other : C ) : KtNDArray < T > . le ( other : C ) : KtNDArray < T > . le ( other : C ) : KtNDArray < T > . le ( other : C ) : KtNDArray < T > . le ( other : C ) : KtNDArray < T > . le ( other : C ) : KtNDArray < T > . le ( other : C ) : KtNDArray < T > . le ( other : C ) : KtNDArray < T > . le ( other : C ) : KtNDArray < T > . le ( other : C ) : KtNDArray < T > . le ( other : C ) : KtNDArray < T > . le ( other : C ) : KtNDArray < T > . le ( other : C ) : KtNDArray < T > . le ( other : C ) : KtNDArray < T > . le ( other : C ) : KtNDArray
( other : C ) : KtNDArray < Boolean > = ( other > KtNDArray < T > . gt ( other ) ) ? true : false * * @param other * @return */ fun < T : Any , C : Number > KtNDArray < T > . gt ( other : C ) : KtNDArray < Boolean > = ( other > KtNDArray < T > . gt ( other ) ) ? true : false fun < T : Any , C : Number > KtNDArray < T > . lt ( other : C ) : KtNDArray < Boolean > = ( other < KtNDArray < T > . lt ( other ) ) ? true : false fun < T : Any , C : Number > KtNDArray < T > . le ( other : C ) : KtNDArray < Boolean > = ( other < KtNDArray < T > . le ( other ) ) ? true : false fun < T : Any , C : Number > KtNDArray < T > . eq ( other : C ) : KtNDArray < Boolean > = ( other == Kt
( other : C ) : KtNDArray < Boolean > * = */ fun < T : Any , C : Number > KtNDArray < T > . ge ( other : C ) : KtNDArray < Boolean > fun < T : Any , C : Number > KtNDArray < T > . ge ( other : C ) : KtNDArray < Boolean > fun < T : Any , C : Number > KtNDArray < T > . ge ( other : C ) : KtNDArray < Boolean > fun < T : Any , C : Number > KtNDArray < T > . ge ( other : C ) : KtNDArray < Boolean > fun < T : Any , C : Number > KtNDArray < T > . ge ( other : C ) : KtNDArray < Boolean > fun < T : Any , C : Number > KtNDArray < T > . ge ( other : C ) : KtNDArray < Boolean > fun < T : Any , C : Number > KtNDArray < T > . ge ( other : C ) : K
( other : C ) : KtNDArray < Boolean > fun < T : Any , C : Number > KtNDArray < T > . eq ( other : C ) : KtNDArray < Boolean > = let fun < T : Any , C : Number > KtNDArray < T > . eq ( other : C ) : KtNDArray < Boolean > = let fun < T : Any , C : Number > KtNDArray < T > . eq ( other : C ) : KtNDArray < Boolean > = let fun < T : Any , C : Number > KtNDArray < T > . eq ( other : C ) : KtNDArray < Boolean > = let fun < T : Any , C : Number > KtNDArray < T > . eq ( other : C ) : KtNDArray < Boolean > = let fun < T : Any , C : Number > KtNDArray < T > . eq ( other : C ) : KtNDArray < Boolean > = let fun < T : Any , C : Number
( a : KtNDArray < T > , b : KtNDArray < T > ) : KtNDArray < Boolean > = ( a : KtNDArray < T > , b : KtNDArray < T > ) -> KtNDArray < Boolean > = ( a : KtNDArray < T > , b : KtNDArray < T > ) -> KtNDArray < Boolean > = ( a : KtNDArray < T > , b : KtNDArray < T > ) -> KtNDArray < Boolean > = ( a : KtNDArray < T > , b : KtNDArray < T > ) -> KtNDArray < Boolean > = ( a : KtNDArray < T > , b : KtNDArray < T > ) -> KtNDArray < Boolean > = ( a : KtNDArray < T > , b : KtNDArray < T > ) -> KtNDArray < Boolean > = ( a : KtNDArray < T > , b : KtNDArray < T > ) -> KtNDArray < Boolean > = ( a : KtNDArray < T > , b : KtND
c : Bitcode * * @param clang * @param cppFile * @param bitcodeFile * * @return void */ void produceCAdapterBitcode ( clang : ClangArgs , cppFile : File , bitcodeFile : File ) { clang.cflags.append( "-O3" ); clang.cflags.append( "-std=c++11" ); clang.cflags.append( "-Wall" ); clang.cflags.append( "-Werror" ); clang.cflags.append( "-Wmissing-prototypes" ); clang.cflags.append( "-Wstrict-prototypes" ); clang.cflags.append( "-Wold-style-definition" ); clang.cflags.append( "-Wextra" ); clang.cflags.append( "-Wold-style-definition" ); clang.cflags.append( "-Wold-style-definition" ); clang.cflags.append( "-Wold-style-definition" );
{ return other.hasDifferentParameterNames(this) } /** * This function basically checks that these two functions have different objective-C signature. * * This signature consists of function name and parameter names except first. * * So we ignore the first parameter name, but check others */ /** * This function basically checks that these two functions have different objective-C signature. * * This signature consists of function name and parameter names except first. * * So we ignore the first parameter name, but check others */ /** * This function basically checks that these two functions have different objective-C signature. * * This signature consists of function name and parameter names except first. * * So we ignore the first parameter name, but check others */ /** * This function basically checks that these two functions have different objective-C signature. * * This signature consists of function name and parameter names except first. * * So we ignore the first parameter name, but check others */ /** * This function basically checks that these two functions have different objective-C signature. * * This signature consists of function
fun getCurrentMapKey ( ) { return this.currentMapKey; } public void setCurrentMapKey ( String key ) { this.currentMapKey = key; } public String getCurrentMapKey ( ) { return this.currentMapKey; } public void resetCurrentMapKey ( ) { this.currentMapKey = ""; } public static void main ( String[] args ) { // TODO Auto-generated method stub final String key = ""; final String path = ""; final File file = new File ( path ); final Scanner scanner = new Scanner ( file ); while ( scanner.hasNextLine ( ) ) { final String line = scanner.nextLine ( ); final String[] tokens = line.split ( ":" ); if ( tokens.length != 2 ) { continue; } final String key = tokens [ 0 ]; final String path = tokens [ 1 ]; final File file = new File ( path ); final Scanner scanner = new Scanner ( file );
= { println( task.getName() ) println( task.getDescription() ) println( task.getInputs() ) println( task.getOutputs() ) println( task.getExpectedOutputs() ) println( task.getExpectedInputs() ) println( task.getExpectedOutputs() ) println( task.getExpectedInputs() ) println( task.getExpectedOutputs() ) println( task.getExpectedInputs() ) println( task.getExpectedOutputs() ) println( task.getExpectedInputs() ) println( task.getExpectedOutputs() ) println( task.getExpectedInputs() ) println( task.getExpectedOutputs() ) println( task.getExpectedInputs() ) println( task.getExpectedOutputs() ) println( task.getExpectedInputs() ) println( task.getExpectedOutputs() ) println( task.getExpectedInputs() )
: LLFirLazyResolverByPhase { var resolver : LLFirLazyResolverByPhase var target : LLFirResolveTarget var phase : FirResolvePhase var target : LLFirResolveTarget var phase : FirResolvePhase var target : LLFirResolveTarget var phase : FirResolvePhase var target : LLFirResolveTarget var phase : FirResolvePhase var target : LLFirResolveTarget var phase : FirResolvePhase var target : LLFirResolveTarget var phase : FirResolvePhase var target : LLFirResolveTarget var phase : FirResolvePhase var target : LLFirResolveTarget var phase : FirResolvePhase var target : LLFirResolveTarget var phase : FirResolvePhase var target : LLFirResolveTarget var phase : FirResolvePhase var target : LLFirResolveTarget var phase : FirResolvePhase var target : LLFirResolve
fun ConeIntegerLiteralType . Companion . findCommonSuperType ( types : Collection < SimpleTypeMarker > ) : ConeIntegerLiteralType . Companion . findCommonSuperType ( types : Collection < SimpleTypeMarker > ) : ConeIntegerLiteralType . Companion . findCommonSuperType ( types : Collection < SimpleTypeMarker > ) : ConeIntegerLiteralType . Companion . findCommonSuperType ( types : Collection < SimpleTypeMarker > ) : ConeIntegerLiteralType . Companion . findCommonSuperType ( types : Collection < SimpleTypeMarker > ) : ConeIntegerLiteralType . Companion . findCommonSuperType ( types : Collection < SimpleTypeMarker > ) : ConeIntegerLiteralType . Companion . findCommonSuperType ( types : Collection < SimpleTypeMarker > ) : ConeIntegerLiteralType . Companion . findCommonSuperType ( types : Collection < SimpleTypeMarker > ) : ConeIntegerLiteralType . Companion . findCommonSuperType ( types : Collection < SimpleTypeMarker > ) : ConeIntegerLiteralType . Companion . findCommonSuperType ( types : Collection < SimpleType
val = null { if ( ! isJvmConDy ( ) ) { return null; } if ( isJvmConDy ( ) ) { if ( isJvmConDy ( ) ) { if ( isJvmConDy ( ) ) { if ( isJvmConDy ( ) ) { if ( isJvmConDy ( ) ) { if ( isJvmConDy ( ) ) { if ( isJvmConDy ( ) ) { if ( isJvmConDy ( ) ) { if ( isJvmConDy ( ) ) { if ( isJvmConDy ( ) ) { if ( isJvmConDy ( ) ) { if ( isJvmConDy ( ) ) { if ( isJvmConDy ( ) ) { if ( isJvmConDy (
. * * @param prevValue previous value of JVM ConDy setting. * * @return new value of JVM ConDy setting. */ public static String restoreConDy ( String prevValue ) { if ( prevValue == null ) { return null; } else { return prevValue; } } /** * Restore previous value of JVM ConDy setting. * * @param prevValue previous value of JVM ConDy setting. * * @return new value of JVM ConDy setting. */ public static String restoreConDy ( String prevValue ) { if ( prevValue == null ) { return null; } else { return prevValue; } } /** * Restore previous value of JVM ConDy setting. * * @param prevValue previous value of JVM ConDy setting. * * @return new value of JVM ConDy setting. */ public static String restoreConDy ( String prev

public fun < T > DataFrame < T > . drop ( n : Int ) : DataFrame < T > { if ( n < 0 ) { throw IllegalArgumentException( "n must be non-negative" ) } return this.drop( n ) } /** * Returns a DataFrame containing all rows except first [n] rows. * * @throws IllegalArgumentException if [n] is negative. */ private fun < T > DataFrame < T > . drop ( n : Int ) : DataFrame < T > { if ( n < 0 ) { throw IllegalArgumentException( "n must be non-negative" ) } return this.drop( n ) } /** * Returns a DataFrame containing all rows except first [n] rows. * * @throws IllegalArgumentException if [n] is negative. */ private fun < T > DataFrame < T > . drop ( n : Int ) : DataFrame < T > { if ( n < 0 ) { throw IllegalArgumentException( "n must be non-negative" )
{ if ( n < 0 ) { throw IllegalArgumentException( "dropLast: n must be non-negative" ) } if ( n == 0 ) { throw IllegalArgumentException( "dropLast: n must be non-zero" ) } return this.dropLast( n ) } /** * Returns a DataFrame containing all rows except first [n] rows. * * @throws IllegalArgumentException if [n] is negative. */ public fun < T > DataFrame < T > . dropFirst ( n : Int = irth ) : DataFrame < T > irth { if ( n < 0 ) { throw IllegalArgumentException( "dropFirst: n must be non-negative" ) } if ( n == 0 ) { throw IllegalArgumentException( "dropFirst: n must be non-zero" ) } return this.dropFirst( n ) } /** * Returns a DataFrame containing all rows except last [n] rows. * * @throws IllegalArgumentException if [n]
public fun < T > DataFrame < T > . dropAll ( predicate : RowFilter < T > ) : DataFrame < T > : DataFrame < T > { return this.filterNot(predicate) } /** * Returns a DataFrame containing all rows that satisfy the given [predicate]. */ fun < T > DataFrame < T > . dropAll ( predicate : RowFilter < T > ) : DataFrame < T > : DataFrame < T > { return this.filter(predicate) } /** * Returns a DataFrame containing all rows that satisfy the given [predicate]. */ fun < T > DataFrame < T > . filter ( predicate : RowFilter < T > ) : DataFrame < T > : DataFrame < T > { return this.filterAll(predicate) } /** * Returns a DataFrame containing all rows that satisfy the given [predicate]. */ fun < T > DataFrame < T > . filterAll ( predicate : RowFilter < T > ) : DataFrame < T > : DataFrame < T > {
public fun < T > DataFrame < T > . dropFirst ( predicate : RowFilter < T > ) : DataFrame < T > : DataFrame < T > { return this.dropWhile ( predicate ) .dropFirst ( predicate ) .dropWhile ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .dropFirst ( predicate ) .

{ if ( n < 0 ) { throw new IllegalArgumentException( "n must be >= 0" ) } if ( n < 0 ) { throw new IllegalArgumentException( "n must be >= 0" ) } if ( n < 0 ) { throw new IllegalArgumentException( "n must be >= 0" ) } if ( n < 0 ) { throw new IllegalArgumentException( "n must be >= 0" ) } if ( n < 0 ) { throw new IllegalArgumentException( "n must be >= 0" ) } if ( n < 0 ) { throw new IllegalArgumentException( "n must be >= 0" ) } if ( n < 0 ) { throw new IllegalArgumentException( "n must be >= 0" ) } if ( n < 0 ) { throw new IllegalArgumentException( "n must be >= 0" ) } if ( n < 0 ) { throw new IllegalArgumentException( "n must be >=
public fun SingleColumn < DataRow < * > > . dropCols ( n : Int ) : ColumnSet < * > { if ( n < 0 ) { throw new IllegalArgumentException( "dropCols must be non-negative" ) } if ( n < 1 ) { throw new IllegalArgumentException( "dropCols must be greater than 0" ) } if ( n > this.count ) { throw new IllegalArgumentException( "dropCols must be less than or equal to the number of columns" ) } if ( n > this.count ) { throw new IllegalArgumentException( "dropCols must be less than or equal to the number of columns" ) } if ( n < 0 ) { throw new IllegalArgumentException( "dropCols must be non-negative" ) } if ( n < 1 ) { throw new IllegalArgumentException( "dropCols must be greater than 0" ) } if ( n > this.count ) { throw new IllegalArgumentException( "
{ if ( n < 0 ) { throw new IllegalArgumentException( "dropCols must be non-negative" ) } if ( n == 0 ) { return this } if ( n < 1 ) { throw new IllegalArgumentException( "dropCols must be greater than 0" ) } if ( n > this.size ) { throw new IllegalArgumentException( "dropCols must be less than or equal to the number of columns" ) } if ( this.size < n ) { throw new IllegalArgumentException( "dropCols must be less than or equal to the number of columns" ) } if ( this.size < n ) { throw new IllegalArgumentException( "dropCols must be less than or equal to the number of columns" ) } if ( this.size < n ) { throw new IllegalArgumentException( "dropCols must be less than or equal to the number of columns" ) } if ( this.size < n ) { throw new
ject { if ( n < 0 ) { throw new IllegalArgumentException( "dropCols must be non-negative" ) } if ( n < 1 ) { throw new IllegalArgumentException( "dropCols must be greater than 0" ) } if ( n > this.count ) { throw new IllegalArgumentException( "dropCols must be less than or equal to the number of columns" ) } if ( n > this.count - 1 ) { throw new IllegalArgumentException( "dropCols must be less than or equal to the number of columns minus one" ) } if ( n > this.count - 2 ) { throw new IllegalArgumentException( "dropCols must be less than or equal to the number of columns minus two" ) } if ( n > this.count - 3 ) { throw new IllegalArgumentException( "dropCols must be less than or equal to the number of columns minus three" ) } if ( n > this.count - 4 ) { throw new Illegal
g { if ( n < 0 ) { throw new IllegalArgumentException( "dropCols must be non-negative" ) } if ( n < 0 ) { throw new IllegalArgumentException( "dropCols must be non-negative" ) } if ( n < 0 ) { throw new IllegalArgumentException( "dropCols must be non-negative" ) } if ( n < 0 ) { throw new IllegalArgumentException( "dropCols must be non-negative" ) } if ( n < 0 ) { throw new IllegalArgumentException( "dropCols must be non-negative" ) } if ( n < 0 ) { throw new IllegalArgumentException( "dropCols must be non-negative" ) } if ( n < 0 ) { throw new IllegalArgumentException( "dropCols must be non-negative" ) } if ( n < 0 ) { throw new IllegalArgumentException( "dropCols must be non-negative" )

{ if ( n == 0 ) { return this } if ( n < 0 ) { throw new IllegalArgumentException() } if ( n > this.size ) { throw new IllegalArgumentException() } return this.dropLast(n) } /** * `df.`[select][DataFrame.select]` { `[take][ColumnsSelectionDsl.take]`(5) }` * * `df.`[select][DataFrame.select]` { `[take][ColumnsSelectionDsl.take]`(5) }` * * `df.`[select][DataFrame.select]` { `[take][ColumnsSelectionDsl.take]`(5) }` * * `df.`[select][DataFrame.select]` { `[take][ColumnsSelectionDsl.take]`(5) }` * * `df.`[select][DataFrame.select]` { `[take][ColumnsSelectionDsl.take]`(5
{ if ( n < 0 ) { throw new IllegalArgumentException() } if ( n < 1 ) { throw new IllegalArgumentException() } if ( n > 1 ) { throw new IllegalArgumentException() } if ( n == 1 ) { throw new IllegalArgumentException() } if ( n == 0 ) { throw new IllegalArgumentException() } if ( n == 2 ) { throw new IllegalArgumentException() } if ( n == 3 ) { throw new IllegalArgumentException() } if ( n == 4 ) { throw new IllegalArgumentException() } if ( n == 5 ) { throw new IllegalArgumentException() } if ( n == 6 ) { throw new IllegalArgumentException() } if ( n == 7 ) { throw new IllegalArgumentException() } if ( n == 8 ) { throw new IllegalArgumentException() } if
{ if ( n < 0 ) { throw new IllegalArgumentException( "dropLastCols: n < 0" ) } if ( n > this.size ) { throw new IllegalArgumentException( "dropLastCols: n > size" ) } if ( n < 1 ) { throw new IllegalArgumentException( "dropLastCols: n < 1" ) } if ( n > this.size - 1 ) { throw new IllegalArgumentException( "dropLastCols: n > size - 1" ) } if ( n < 0 ) { throw new IllegalArgumentException( "dropLastCols: n < 0" ) } if ( n > this.size ) { throw new IllegalArgumentException( "dropLastCols: n > size" ) } if ( n < 1 ) { throw new IllegalArgumentException( "dropLastCols: n < 1" ) } if ( n > this.size - 1 ) { throw new IllegalArgumentException
m { if ( n < 0 ) { throw new IllegalArgumentException( "dropLastCols must be non-negative" ) } if ( n < 1 ) { throw new IllegalArgumentException( "dropLastCols must be greater than or equal to 1" ) } if ( n < 2 ) { throw new IllegalArgumentException( "dropLastCols must be greater than or equal to 2" ) } if ( n < 3 ) { throw new IllegalArgumentException( "dropLastCols must be greater than or equal to 3" ) } if ( n < 4 ) { throw new IllegalArgumentException( "dropLastCols must be greater than or equal to 4" ) } if ( n < 5 ) { throw new IllegalArgumentException( "dropLastCols must be greater than or equal to 5" ) } if ( n < 6 ) { throw new IllegalArgumentException( "dropLastCols must be greater than or equal to 6" ) } if ( n
m { if ( n < 0 ) { throw new IllegalArgumentException( "dropLastCols: n must be >= 0" ) } if ( n < 1 ) { throw new IllegalArgumentException( "dropLastCols: n must be >= 1" ) } if ( n < 2 ) { throw new IllegalArgumentException( "dropLastCols: n must be >= 2" ) } if ( n < 3 ) { throw new IllegalArgumentException( "dropLastCols: n must be >= 3" ) } if ( n < 4 ) { throw new IllegalArgumentException( "dropLastCols: n must be >= 4" ) } if ( n < 5 ) { throw new IllegalArgumentException( "dropLastCols: n must be >= 5" ) } if ( n < 6 ) { throw new IllegalArgumentException( "dropLastCols: n must be >= 6" ) } if ( n < 7 ) { throw new IllegalArgument












Protected : ArrayList<String> = ArrayList<String>() { var args : ArrayList<String> = ArrayList<String>() args.add( klibPath ) return args } /** Args passed to the compiler at the second stage of two-stage compilation (klib building). */ klibprotected fun buildSecondStageArgs ( klibPath : String ) klibProtected : ArrayList<String> = ArrayList<String>() { var args : ArrayList<String> = ArrayList<String>() args.add( klibPath ) return args } /** Args passed to the compiler at the first stage of two-stage compilation (klib building). */ klibprotected fun buildFirstStageArgs ( klibPath : String ) klibProtected : ArrayList<String> = ArrayList<String>() { var args : ArrayList<String> = ArrayList<String>() args.add( klibPath ) return args } /** Args passed to the compiler at the second stage of two-stage compilation
Protected : ArrayList<String> = ArrayList<String>() { var args = ArrayList<String>() args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( klibPath ) args.add( k
protected void buildCommonArgs ( ) { if ( this.args != null ) { for ( int i = 0; i < this.args.length; i++ ) { if ( this.args[i] == null ) { this.args[i] = ""; } else { this.args[i] = this.args[i].trim(); } } } else { for ( int i = 0; i < this.args.length; i++ ) { if ( this.args[i] == null ) { this.args[i] = ""; } else { this.args[i] = this.args[i].trim(); } } } if ( this.args[0] == null ) { this.args[0] = ""; } else { this.args[0] = this.args[0].trim();
fun buildArgs ( ) { int i; for ( i = 0; i < 2; i++ ) { if ( args[i] == NULL ) { fprintf ( stderr, "error: argument %d is NULL\n", i ); exit ( EXIT_FAILURE ); } } return args; } int main ( int argc, char *argv[] ) { if ( argc < 2 ) { fprintf ( stderr, "error: insufficient arguments\n" ); exit ( EXIT_FAILURE ); } int i; for ( i = 0; i < 2; i++ ) { if ( argv[i] == NULL ) { fprintf ( stderr, "error: argument %d is NULL\n", i ); exit ( EXIT_FAILURE ); } } if ( args[0] == NULL ) { fprintf ( stderr, "error
( col : ColumnAccessor < C > ) : ColumnAccessor < C > { * * @param col * @return */ public static < C > col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > { * * @return */ public static < C > col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > { * * @return */ public static < C > col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > { * * @return */ public static < C > col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > { * * @return */ public static < C > col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > { * * @return */ public static < C > col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > { * * @return */ public static < C > col ( col : ColumnAccessor < C > ) : ColumnAcce
{ return SingleColumn<C>(col) } /** * @include [ColReferenceDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ mongopublic fun < C > SingleColumn < DataRow < * > > . col ( col : ColumnAccessor < C > ) : SingleColumn<C>(col) /** * @include [ColReferenceDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ mongopublic fun < C > SingleColumn < DataRow < * > > . col ( col : ColumnAccessor < C > ) : SingleColumn<C>(col) /** * @include [ColReferenceDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ mongopublic fun < C > SingleColumn < DataRow < * > > . col ( col : ColumnAccessor < C > ) : SingleColumn<C>(col) /** * @include [ColReferenceDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ mongopublic fun < C
( col ) : AnyColumnGroupAccessor < C > { @Override public AnyColumnGroupAccessor < C > get ( col : ColumnAccessor < C > ) : AnyColumnGroupAccessor < C > { return this } @Override public AnyColumnGroupAccessor < C > set ( col : ColumnAccessor < C > ) : AnyColumnGroupAccessor < C > { return this } @Override public AnyColumnGroupAccessor < C > add ( col : ColumnAccessor < C > ) : AnyColumnGroupAccessor < C > { return this } @Override public AnyColumnGroupAccessor < C > remove ( col : ColumnAccessor < C > ) : AnyColumnGroupAccessor < C > { return this } @Override public AnyColumnGroupAccessor < C > update ( col : ColumnAccessor < C > ) : AnyColumnGroupAccessor < C > { return this } @Override public AnyColumnGroupAccessor < C > delete ( col : ColumnAccessor < C > ) : Any
( col : ColumnAccessor < C > ) { return this } /** * @include [ColReferenceDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} */ colprivate fun < C > String . col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > { return this } /** * @include [ColReferenceDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} */ colprivate fun < C > String . col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > { return this } /** * @include [ColReferenceDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} */ colprivate fun < C > String . col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > { return this } /** * @include [ColReferenceDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} */ colprivate fun
( col : ColumnAccessor < C > ) { return this } /** * @include [ColReferenceDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} */ kpublic fun < C > KProperty < * > . col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > k ( col : ColumnAccessor < C > ) { return this } /** * @include [ColReferenceDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} */ kpublic fun < C > KProperty < * > . col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > k ( col : ColumnAccessor < C > ) { return this } /** * @include [ColReferenceDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} */ kpublic fun < C > KProperty < * > . col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > k ( col : ColumnAccessor < C > )
( col : ColumnAccessor < C > ) : ColumnAccessor < C > { @Override public ColumnAccessor < C > col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > { @Override public ColumnAccessor < C > col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > { @Override public ColumnAccessor < C > col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > { @Override public ColumnAccessor < C > col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > { @Override public ColumnAccessor < C > col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > { @Override public ColumnAccessor < C > col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > { @Override public ColumnAccessor < C > col ( col : ColumnAccessor < C > ) : ColumnAccessor < C > { @Override public ColumnAccessor < C > col
{ /** * @param name * @return */ public ColumnAccessor < * > col ( name : String ) : ColumnAccessor < * > { /** * @param name * @return */ public ColumnAccessor < * > ( name : String ) : ColumnAccessor < * > { /** * @param name * @return */ public ColumnAccessor < * > ( name : String ) : ColumnAccessor < * > { /** * @param name * @return */ public ColumnAccessor < * > ( name : String ) : ColumnAccessor < * > { /** * @param name * @return */ public ColumnAccessor < * > ( name : String ) : ColumnAccessor < * > { /** * @param name * @return */ public ColumnAccessor < * > ( name : String ) : ColumnAccessor < * > {
( name : String ) : ColumnAccessor < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg]} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > col ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg]} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > col ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg]} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > col ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg]} * @include [CommonColDocs.
( name : String ) : DataRow < * > > {@set col ( name : String ) : DataRow < * > > {@set col ( name : String ) : DataRow < * > > {@set col ( name : String ) : DataRow < * > > {@set col ( name : String ) : DataRow < * > > {@set col ( name : String ) : DataRow < * > > {@set col ( name : String ) : DataRow < * > > {@set col ( name : String ) : DataRow < * > > {@set col ( name : String ) : DataRow < * > > {@set col ( name : String ) : DataRow < * > > {@set col ( name : String ) : DataRow < * > > {@set col ( name : String ) : DataRow < * > > {@set col ( name : String ) : DataRow < * > > {@set col ( name : String ) : DataRow < * > > {@set col ( name : String ) : DataRow < * > > {@set col ( name : String ) : DataRow < * > > {@set col
( name : String ) : SingleColumn < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} * @include [CommonColDocs.ColumnTypeParam] */ fun < C > SingleColumn < DataRow < * > > . col ( name : String ) : SingleColumn < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} * @include [CommonColDocs.ColumnTypeParam] */ fun < C > SingleColumn < DataRow < * > > . col ( name : String ) : SingleColumn < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} * @include [CommonColDocs.ColumnTypeParam] */ fun < C > SingleColumn < DataRow < * > > . col ( name : String ) : SingleColumn < C > { return thi
( name : String ) = col ( name : String ) /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] myColumn
( name : String ) : AnyColumnGroupAccessor < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > AnyColumnGroupAccessor . col ( name : String ) : AnyColumnGroupAccessor < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > AnyColumnGroupAccessor . col ( name : String ) : AnyColumnGroupAccessor < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > AnyColumnGroupAccessor . col ( name : String ) : AnyColumnGroupAccessor < C > { return thi
{ return new ColumnAccessor ( name ) { @Override public ColumnAccessor ( name ) { this.name = name; } @Override public ColumnAccessor ( name ) { this.name = name; } @Override public ColumnAccessor ( name ) { this.name = name; } @Override public ColumnAccessor ( name ) { this.name = name; } @Override public ColumnAccessor ( name ) { this.name = name; } @Override public ColumnAccessor ( name ) { this.name = name; } @Override public ColumnAccessor ( name ) { this.name = name; } @Override public ColumnAccessor ( name ) { this.name = name; } @Override public ColumnAccessor ( name ) { this.name = name; } @Override public ColumnAccessor ( name ) { this.name
( name : String ) : ColumnAccessor < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > String . col ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > String . col ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > String . col ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ColNameDoc
( name : String ) : ColumnAccessor < * > * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
( name : String ) : ColumnAccessor < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [CommonColDocs.ColumnTypeParam] */ kpublic fun < C > KProperty < * > . col ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [CommonColDocs.ColumnTypeParam] */ kpublic fun < C > KProperty < * > . col ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [CommonColDocs.ColumnTypeParam] */ kpublic fun < C > KProperty < * > . col ( name : String ) : ColumnAccessor < C > { return
{ /** * @param name * @return */ public ColumnAccessor<*> col ( name : String ) : ColumnAccessor<*> { /** * @param name * @return */ public ColumnAccessor<*> ( name : String ) : ColumnAccessor<*> { /** * @param name * @return */ public ColumnAccessor<*> ( name : String ) : ColumnAccessor<*> { /** * @param name * @return */ public ColumnAccessor<*> ( name : String ) : ColumnAccessor<*> { /** * @param name * @return */ public ColumnAccessor<*> ( name : String ) : ColumnAccessor<*> { /** * @param name * @return */ public ColumnAccessor<*> ( name : String ) : ColumnAccessor<*> {
( name : String ) : ColumnAccessor < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > ColumnPath . col ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > ColumnPath . col ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ColNameDocs] {@set [CommonColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > ColumnPath . col ( name : String ) : ColumnAccessor < C > {
public fun col ( path : ColumnPath ) : ColumnAccessor < * > { if ( path == null ) { throw new ArgumentNullException ( "path" ); } else if ( path.isEmpty() ) { throw new ArgumentException ( "path" ); } else { return new ColumnAccessor < * > ( this, path ); } } public fun col ( path : ColumnPath ) : ColumnAccessor < * > { if ( path == null ) { throw new ArgumentNullException ( "path" ); } else if ( path.isEmpty() ) { throw new ArgumentException ( "path" ); } else { return new ColumnAccessor < * > ( this, path ); } } public fun col ( path : ColumnPath ) : ColumnAccessor < * > { if ( path == null ) { throw new ArgumentNullException ( "path" ); }
( path : ColumnPath ) : ColumnAccessor < C > { return this } /** * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg]} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > col ( path : ColumnPath ) : ColumnAccessor < C > { return this } /** * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg]} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > col ( path : ColumnPath ) : ColumnAccessor < C > { return this } /** * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg]} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > col ( path : ColumnPath ) : ColumnAccessor < C > { return this } /** * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg]} * @include [Common
{ if ( path == null ) { throw new ArgumentNullException ( "path" ); } if ( path.isEmpty() ) { throw new ArgumentNullException ( "path" ); } if ( path.contains ( "*" ) ) { throw new ArgumentException ( "path" ); } if ( path.contains ( "**" ) ) { throw new ArgumentException ( "path" ); } if ( path.contains ( "***" ) ) { throw new ArgumentException ( "path" ); } if ( path.contains ( "****" ) ) { throw new ArgumentException ( "path" ); } if ( path.contains ( "*****" ) ) { throw new ArgumentException ( "path" ); } if ( path.contains ( "******" ) ) { throw new ArgumentException ( "path" ); } if (
( path : ColumnPath ) : SingleColumn < C > { if ( path.isEmpty() ) { return this } else if ( path.size() == 1 ) { return this } else if ( path.size() == 2 ) { return this } else if ( path.size() == 3 ) { return this } else if ( path.size() == 4 ) { return this } else if ( path.size() == 5 ) { return this } else if ( path.size() == 6 ) { return this } else if ( path.size() == 7 ) { return this } else if ( path.size() == 8 ) { return this } else if ( path.size() == 9 ) { return this } else if ( path.size() == 10 ) { return this } else if ( path.size() == 11 ) { return this } else if ( path.size() == 12 ) { return this } else if ( path.size() == 13
/** * @see [ColPathDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ /** * @see [ColPathDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ /** * @see [ColPathDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ /** * @see [ColPathDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ /** * @see [ColPathDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ /** * @see [ColPathDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ /** * @see [ColPathDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ /** * @see [ColPathDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.}
( path : ColumnPath ) : ColumnAccessor < C > { if ( path.isEmpty() ) { return this } else if ( path.size() == 1 ) { return this } else if ( path.size() == 2 ) { return this } else if ( path.size() == 3 ) { return this } else if ( path.size() == 4 ) { return this } else if ( path.size() == 5 ) { return this } else if ( path.size() == 6 ) { return this } else if ( path.size() == 7 ) { return this } else if ( path.size() == 8 ) { return this } else if ( path.size() == 9 ) { return this } else if ( path.size() == 10 ) { return this } else if ( path.size() == 11 ) { return this } else if ( path.size() == 12 ) { return this } else if ( path.size() ==
. col ( path : ColumnPath ) : ColumnAccessor < * > * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
( path : ColumnPath ) : ColumnAccessor < C > { return this } /** * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > String . col ( path : ColumnPath ) : ColumnAccessor < C > { return this } /** * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > String . col ( path : ColumnPath ) : ColumnAccessor < C > { return this } /** * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > String . col ( path : ColumnPath ) : ColumnAccessor < C > { return this } /** * @include [
{ return new ColumnAccessor< * > ( this, path ); } /** * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.}
( path : ColumnPath ) : ColumnAccessor < C > { if ( path.isNullOrEmpty() ) { return this } else { return ColumnAccessor<C>(this, path) } } /** * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [CommonColDocs.ColumnTypeParam] */ kpublic fun < C > KProperty < * > . col ( path : ColumnPath ) : ColumnAccessor < C > { if ( path.isNullOrEmpty() ) { return this } else { return ColumnAccessor<C>(this, path) } } /** * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [CommonColDocs.ColumnTypeParam] */ kpublic fun < C > KProperty < * > . col ( path : ColumnPath ) : ColumnAccessor < C > { if ( path.isNullOrEmpty() )
{ @Override public ColumnAccessor < * > col ( path : ColumnPath ) : ColumnAccessor < * > { @Override public ColumnAccessor < * > col ( path : ColumnPath ) : ColumnAccessor < * > { @Override public ColumnAccessor < * > col ( path : ColumnPath ) : ColumnAccessor < * > { @Override public ColumnAccessor < * > col ( path : ColumnPath ) : ColumnAccessor < * > { @Override public ColumnAccessor < * > col ( path : ColumnPath ) : ColumnAccessor < * > { @Override public ColumnAccessor < * > col ( path : ColumnPath ) : ColumnAccessor < * > { @Override public ColumnAccessor < * > col ( path : ColumnPath ) : ColumnAccessor < * > { @Override public ColumnAccessor < * > col ( path : ColumnPath ) : ColumnAccessor < * > { @Override
( path : ColumnPath ) : ColumnAccessor < C > { return this } /** * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > ColumnPath . col ( path : ColumnPath ) : ColumnAccessor < C > { return this } /** * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > ColumnPath . col ( path : ColumnPath ) : ColumnAccessor < C > { return this } /** * @include [ColPathDocs] {@set [CommonColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > ColumnPath . col ( path : ColumnPath ) : ColumnAccessor
{ return SingleColumn<C>(this, property) } /** * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg]} */ colPublic fun < C > colPublic ( property : KProperty < C > ) : SingleColumn < C > public { return SingleColumn<C>(this, property) } /** * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg]} */ colPublic fun < C > colPublicPublic ( property : KProperty < C > ) : SingleColumn < C > public { return SingleColumn<C>(this, property) } /** * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg]} */ colPublic fun < C > colPublicPublic ( property : KProperty < C > ) : SingleColumn < C > public { return SingleColumn<C>(this, property) } /** * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg]} */ colPublic fun < C
{ return SingleColumn<C>(this, property) } /** * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ kpublic fun < C > SingleColumn < DataRow < * > > . col ( property : KProperty < C > ) : kSingleColumn < C > { return kSingleColumn<C>(this, property) } /** * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ kpublic fun < C > SingleColumn < DataRow < * > > . col ( property : KProperty < C > ) : kSingleColumn < C > { return kSingleColumn<C>(this, property) } /** * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ kpublic fun < C > SingleColumn < DataRow < * > > . col ( property : KProperty < C > ) : kSingleColumn < C > { return kSingleColumn<C>(thi
{ return ColumnAccessor<C>(this, property) } /** * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ kpublic fun < C > AnyColumnGroupAccessor . col ( property : KProperty < C > ) : ColumnAccessor < C > kprivate { return ColumnAccessor<C>(this, property) } /** * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ kpublic fun < C > AnyColumnGroupAccessor . col ( property : KProperty < C > ) : ColumnAccessor < C > kprivate { return ColumnAccessor<C>(this, property) } /** * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ kpublic fun < C > AnyColumnGroupAccessor . col ( property : KProperty < C > ) : ColumnAccessor < C > kprivate { return ColumnAccessor<C>(this, property) }
{ return ColumnAccessor<C>(this, property) } /** * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] "myColumn
{ return ColumnAccessor<C>(this, property) } /** * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} */ kpublic fun < C > KProperty < * > . col ( property : KProperty < C > ) : ColumnAccessor < C > k { return ColumnAccessor<C>(this, property) } /** * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} */ kpublic fun < C > KProperty < * > . col ( property : KProperty < C > ) : ColumnAccessor < C > k { return ColumnAccessor<C>(this, property) } /** * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} */ kpublic fun < C > KProperty < * > . col ( property : KProperty < C > ) : ColumnAccessor < C > k { return ColumnAccessor<C>(this, property
{ return ColumnAccessor<C>(this, property) } /** * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ColKPropertyDocs] {@set [CommonColDocs.ReceiverArg] "pathTo


( index : Int ) : SingleColumn < * > """ class ColumnsSelectionDsl: def __init__(self, index): self.index = index def __repr__(self): return f"ColumnsSelectionDsl(index={self.index})" def __str__(self): return f"ColumnsSelectionDsl(index={self.index})" def __eq__(self, other): return isinstance(other, ColumnsSelectionDsl) and self.index == other.index def __ne__(self, other): return not self.__eq__(other) def __hash__(self): return hash(self.index) def __lt__(self, other): return self.index < other.index def __le__(self, other): return self.index <= other.index def __gt__(self, other): return self.index > other.index def __ge__(self, other): return self.index >= other
( index : Int ) : SingleColumn < C > { if ( index < 0 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 1 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 2 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 3 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 4 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 5 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 6 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 7 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 8 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 9 ) { throw new IndexOutOfBoundsException
= if ( index < 0 ) throw new IllegalArgumentException ( "Index must be non-negative" ) else if ( index >= this.cols ) throw new IllegalArgumentException ( "Index must be less than the number of columns" ) else return this.cols.col ( index ) } /** * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ /** * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ /** * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ /** * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ /** * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} */ /** * @
{ if ( index < 0 || index >= this.size ) throw new IndexOutOfBoundsException() return this[index] } /** * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > SingleColumn < DataRow < * > > . col ( index : Int ) : SingleColumn < C > { if ( index < 0 || index >= this.size ) throw new IndexOutOfBoundsException() return this[index] } /** * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] myColumnGroup.} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > SingleColumn < DataRow < * > > . col ( index : Int ) : SingleColumn < C > { if ( index < 0 || index >= this.size ) throw new IndexOutOfBoundsException() return this[index] } /** * @include [ColIndexDoc
{ if ( index < 0 ) { throw new IndexOutOfBoundsException ( "Index " + index + " is out of bounds" ); } if ( index >= this.cols ) { throw new IndexOutOfBoundsException ( "Index " + index + " is out of bounds" ); } return this.cols.col ( index ); } /** * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} */ col ( index : Int ) : SingleColumn < * > col { if ( index < 0 ) { throw new IndexOutOfBoundsException ( "Index " + index + " is out of bounds" ); } if ( index >= this.cols ) { throw new IndexOutOfBoundsException ( "Index " + index + " is out of bounds" ); } return this.cols.col ( index ); } /** * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] "myColumn
( index : Int ) : SingleColumn < C > { if ( index < 0 ) { throw new IndexOutOfBoundsException () } else if ( index >= this.size ) { throw new IndexOutOfBoundsException () } else { return this[index] } } /** * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C > String . col ( index : Int ) : SingleColumn < C > { if ( index < 0 ) { throw new IndexOutOfBoundsException () } else if ( index >= this.size ) { throw new IndexOutOfBoundsException () } else { return this[index] } } /** * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] "myColumnGroup".} * @include [CommonColDocs.ColumnTypeParam] */ public fun < C
= this.col ( index ) /** * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ColIndexDocs] {@set [
{ if ( index < 0 ) { throw new IndexOutOfBoundsException() } else if ( index >= this.size ) { throw new IndexOutOfBoundsException() } else { return this[index] } } /** * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [CommonColDocs.ColumnTypeParam] */ fun < C > KProperty < * > . col ( index : Int ) : SingleColumn < C > { if ( index < 0 ) { throw new IndexOutOfBoundsException() } else if ( index >= this.size ) { throw new IndexOutOfBoundsException() } else { return this[index] } } /** * @include [ColIndexDocs] {@set [CommonColDocs.ReceiverArg] Type::myColumnGroup.} * @include [CommonColDocs.ColumnTypeParam] */ fun < C > KProperty < * > . col (
{ if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException ()
( index : Int ) : C { if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index < 0 ) throw new
{ if ( ch < 0 ) throw new IllegalArgumentException( "Invalid codepoint: " + ch ); if ( ch < 0x10 ) return 0; if ( ch < 0x20 ) return 1; if ( ch < 0x40 ) return 2; if ( ch < 0x80 ) return 3; if ( ch < 0x100 ) return 4; if ( ch < 0x200 ) return 5; if ( ch < 0x400 ) return 6; if ( ch < 0x800 ) return 7; if ( ch < 0x1000 ) return 8; if ( ch < 0x2000 ) return 9; if ( ch < 0x4000 ) return 10; if ( ch < 0x8000 ) return 11; if ( ch < 0x10000 ) return 12; if ( ch < 0x20000 ) return 13; if ( ch < 0x40000 ) return 14; if ( ch < 0x80000 ) return 15; if ( ch < 0x1000000 ) return 16; if ( ch
{ if ( ch < 0 || ch > 255 ) { return false; } return true; } /** Check if the given character is in table of double decompositions */ fun hasDoubleCodepointDecompositionInternal ( ch : Int ) : Boolean = hasSingleCodepointDecompositionInternal ( ch ) || hasSingleCodepointDecompositionInternal ( ch + 1 ) || hasSingleCodepointDecompositionInternal ( ch + 2 ) || hasSingleCodepointDecompositionInternal ( ch + 3 ) || hasSingleCodepointDecompositionInternal ( ch + 4 ) || hasSingleCodepointDecompositionInternal ( ch + 5 ) || hasSingleCodepointDecompositionInternal ( ch + 6 ) || hasSingleCodepointDecompositionInternal ( ch + 7 ) || hasSingleCodepointDecompositionInternal ( ch + 8 ) || hasSingleCodepointDecompositionInternal ( ch + 9 ) || hasSingleCodepointDecompositionInternal ( ch + 10 ) || hasSingleCodepointDecompositionInternal ( ch + 11 ) || hasSingleCodepointDecompositionInternal ( ch
Length : Int { if ( inputLength == 0 ) { return 0; } if ( inputLength == 1 ) { return 1; } if ( inputLength == 2 ) { return 2; } if ( inputLength == 3 ) { return 3; } if ( inputLength == 4 ) { return 4; } if ( inputLength == 5 ) { return 5; } if ( inputLength == 6 ) { return 6; } if ( inputLength == 7 ) { return 7; } if ( inputLength == 8 ) { return 8; } if ( inputLength == 9 ) { return 9; } if ( inputLength == 10 ) { return 10; } if ( inputLength == 11 ) { return 11; } if ( inputLength == 12 ) { return 12; } if ( inputLength == 13 ) { return 13; }
: Int { if ( fromIndex < 0 ) { throw new IllegalArgumentException ( "fromIndex < 0" ) ; } if ( fromIndex >= outputCodePoints.length ) { throw new IllegalArgumentException ( "fromIndex >= outputCodePoints.length" ) ; } if ( codePoint < 0 ) { throw new IllegalArgumentException ( "codePoint < 0" ) ; } if ( codePoint >= outputCodePoints.length ) { throw new IllegalArgumentException ( "codePoint >= outputCodePoints.length" ) ; } if ( outputCodePoints[fromIndex] != codePoint ) { throw new IllegalArgumentException ( "outputCodePoints[fromIndex] != codePoint" ) ; } return fromIndex + 1 ; } /** * Decomposes the given codepoint. Saves the decomposition into [outputCodepoints] array starting with [fromIndex]. * Returns the length of the decomposition. */ fun funDecomposeCodePoint ( codePoint : Int , outputCodePoints : IntArray
inarySearch ( array , needle , 0 , array.size() - 1 ) : Int { if ( needle < array[0] ) { return -1 } else if ( needle > array[array.size() - 1] ) { return array.size() - 1 } else { int middle = array.size() / 2; if ( array[middle] == needle ) { return middle } else if ( array[middle] > needle ) { return binarySearchRange ( array , needle , 0 , middle - 1 ) } else { return binarySearchRange ( array , needle , middle + 1 , array.size() - 1 ) } } } /** * Returns the index of the largest element in [array] smaller or equal to the specified [needle], * or -1 if [needle] is smaller than the smallest element in [array]. */ binarySearch ( array , needle , 0 , array.size() - 1 ) : Int { if ( needle < array[0] ) { return -1 } else if ( needle > array
{ if ( function instanceof FirFunction ) { return function } else if ( function instanceof FirFunctionTarget ) { return function as FirFunctionTarget } else { return null } } /** * @return [FirFunction] if another function should be used instead of [function] for [FirFunctionTarget] * * @see bindFunctionTarget * @see functionsToRebind */ private fun computeRebindTarget ( function : FirFunctionTarget ) : FirFunction ? sip { if ( function instanceof FirFunction ) { return function } else if ( function instanceof FirFunctionTarget ) { return function as FirFunctionTarget } else { return null } } /** * @return [FirFunction] if another function should be used instead of [function] for [FirFunctionTarget] * * @see bindFunctionTarget * @see functionsToRebind */ private fun computeRebindTarget ( function : FirFunctionTarget ) : FirFunction ? sip { if ( function instanceof FirFunction ) { return function
( ) : List < StubIrElement > { var list : List < StubIrElement > = ArrayList<StubIrElement>() list.add( new StubIrElement( s.name, s.type ) ) list.add( new StubIrElement( s.name, s.type ) ) list.add( new StubIrElement( s.name, s.type ) ) list.add( new StubIrElement( s.name, s.type ) ) list.add( new StubIrElement( s.name, s.type ) ) list.add( new StubIrElement( s.name, s.type ) ) list.add( new StubIrElement( s.name, s.type ) ) list.add( new StubIrElement( s.name, s.type ) ) list.add( new StubIrElement( s.name, s.type ) ) list.add( new StubIrElement( s.name, s.type ) ) list.add( new StubIrElement( s.name, s.type ) ) list.add
: List<StubIrElement> { var list : List<StubIrElement> = ArrayList<StubIrElement>() list.add( new StubIrElement( enumDef.name, enumDef.value ) ) list.add( new StubIrElement( enumDef.name, enumDef.value + 1 ) ) list.add( new StubIrElement( enumDef.name, enumDef.value + 2 ) ) list.add( new StubIrElement( enumDef.name, enumDef.value + 3 ) ) list.add( new StubIrElement( enumDef.name, enumDef.value + 4 ) ) list.add( new StubIrElement( enumDef.name, enumDef.value + 5 ) ) list.add( new StubIrElement( enumDef.name, enumDef.value + 6 ) ) list.add( new StubIrElement( enumDef.name, enumDef.value + 7 ) ) list.add( new StubIrElement( enumDef.name, enumDef.value + 8 ) ) list.add( new StubIrElement(

( snackbarManager : SnackbarManager = SnackbarManager , snackRepository : SnackRepo = SnackRepo ) : ViewModelProvider where type ViewModelProvider = ViewModel type SnackbarManager = SnackbarManager type SnackRepo = SnackRepo type ViewModel = ViewModel type Snack = Snack type SnackBar = SnackBar type SnackBarManager = SnackBarManager type SnackRepository = SnackRepository type Snack = Snack type SnackBar = SnackBar type SnackBarManager = SnackBarManager type SnackRepository = SnackRepository type Snack = Snack type SnackBar = SnackBar type SnackBarManager = SnackBarManager type SnackRepository = SnackRepository type Snack = Snack type SnackBar = SnackBar type SnackBarManager = SnackBarManager type SnackRepository = SnackRepository type Snack = Snack type Sn
= false * * @return true if it should use K2, false otherwise */ public boolean shouldUseK2 ( ) : Boolean { return true; } /** * By default, it is disabled */ k2fun shouldUseK2 ( ) : Boolean * * @return true if it should use K2, false otherwise */ public boolean k2fun shouldUseK2 ( ) : Boolean { return true; } /** * By default, it is disabled */ k3fun shouldUseK3 ( ) : Boolean * * @return true if it should use K3, false otherwise */ public boolean k3fun shouldUseK3 ( ) : Boolean { return true; } /** * By default, it is disabled */ k4fun shouldUseK4 ( ) : Boolean * * @return true if it should use K4, false otherwise */ public boolean k4fun shouldUseK4 ( ) : Boolean { return true; } /** * By default, it is disabled */ k5fun shouldUseK5 (
ine { var array = Array<out T>() for ( var i = 0; i < values.length; i++ ) { array[i] = values[i] } return array } /** * Will only return values if [TestEnvironment.isExhaustive] is set to false */ noninline fun < reified T > ifExhaustive ( vararg values : T ) : Array < out T >noconsole { var array = Array<out T>() for ( var i = 0; i < values.length; i++ ) { array[i] = values[i] } return array } /** * Will only return values if [TestEnvironment.isExhaustive] is set to true */ noninline fun < reified T > ifExhaustive ( vararg values : T ) : Array < out T >noconsole { var array = Array<out T>() for ( var i = 0; i < values.length; i++ ) { array[i] = values[i] }

{ Array < FloatArray > fashionImages = new Array < FloatArray > (); Array < FloatArray > fashionLabels = new Array < FloatArray > (); Array < String > fashionNames = new Array < String > (); Array < String > fashionSizes = new Array < String > (); Array < String > fashionColors = new Array < String > (); Array < String > fashionLabelsColors = new Array < String > (); Array < String > fashionNamesColors = new Array < String > (); Array < String > fashionSizesColors = new Array < String > (); Array < String > fashionColors = new Array < String > (); Array < String > fashionLabelsColors = new Array < String > (); Array < String > fashionNamesColors = new Array < String > (); Array < String > fashionSizesColors = new Array < String > (); Array < String > fashionColors = new Array < String > (); Array < String > fashionLabelsColors = new Array < String > (); Array < String > fashionNamesColors = new Array < String



: PersistentList < E > = this /** * Returns a new persistent list with the specified [element] prepended. */ fun add ( element : @ UnsafeVariance E ) : PersistentList < E > = this /** * Returns a new persistent list with the specified [element] appended. */ fun add ( element : @ UnsafeVariance E ) : PersistentList < E > = this /** * Returns a new persistent list with the specified [element] prepended. */ fun add ( element : @ UnsafeVariance E ) : PersistentList < E > = this /** * Returns a new persistent list with the specified [element] appended. */ fun add ( element : @ UnsafeVariance E ) : PersistentList < E > = this /** * Returns a new persistent list with the specified [element] prepended. */ fun add ( element : @ UnsafeVariance E ) : PersistentList < E > = this /** * Returns a new persistent list with the specified [element] appended. */ fun add ( element : @ UnsafeVariance

: PersistentList < E > = this /** * Returns the result of removing the first appearance of the specified [element] from this list. * * @return a new persistent list with the first appearance of the specified [element] removed; * or this instance if there is no such element in this list. */ /** * Returns the result of removing the first occurrence of the specified [element] from this list. * * @return a new persistent list with the first occurrence of the specified [element] removed; * or this instance if there is no such element in this list. */ /** * Returns the result of removing the first occurrence of the specified [element] from this list. * * @return a new persistent list with the first occurrence of the specified [element] removed; * or this instance if there is no such element in this list. */ /** * Returns the result of removing the first occurrence of the specified [element] from this list. * * @return a new persistent list with the first occurrence of the specified [element] removed; * or this instance if there is no such element in this list.

: PersistentList < E > = this /** * Returns the result of removing all elements in this list that match the specified [predicate]. * * @return a new persistent list with elements matching the specified [predicate] removed; * or this instance if no elements match the predicate. */ /** * Returns the result of removing all elements in this list that match the specified [predicate]. * * @return a new persistent list with elements matching the specified [predicate] removed; * or this instance if no elements match the predicate. */ /** * Returns the result of removing all elements in this list that match the specified [predicate]. * * @return a new persistent list with elements matching the specified [predicate] removed; * or this instance if no elements match the predicate. */ /** * Returns the result of removing all elements in this list that match the specified [predicate]. * * @return a new persistent list with elements matching the specified [predicate] removed; * or this instance if no elements match the predicate. */ /** * Returns the result of removing all elements in this list
override = this.retainAll( elements ) /** * Returns all elements in this list that are also * contained in the specified [elements] collection. * * @return a new persistent list with elements in this list that are also * contained in the specified [elements] collection; * or this instance if no modifications were made in the result of this operation. */ /** * Returns all elements in this list that are also * contained in the specified [elements] collection. * * @return a new persistent list with elements in this list that are also * contained in the specified [elements] collection; * or this instance if no modifications were made in the result of this operation. */ /** * Returns all elements in this list that are also * contained in the specified [elements] collection. * * @return a new persistent list with elements in this list that are also * contained in the specified [elements] collection; * or this instance if no modifications were made in the result of this operation. */ /** * Returns all elements in this list that are also * contained in the specified
: PersistentList < E > */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. */ /** * Returns an empty persistent list. *

throws IndexOutOfBoundsException : IndexOutOfBoundsException { if ( index < 0 || index >= this.size ) { throw new IndexOutOfBoundsException() } else { this[index] = element } } /** * Returns the element at the specified [index]. * * @throws IndexOutOfBoundsException if [index] is out of bounds of this list. */ public E get ( index : Int ) : E { if ( index < 0 || index >= this.size ) { throw new IndexOutOfBoundsException() } else { return this[index] } } /** * Removes the element at the specified [index]. * * @throws IndexOutOfBoundsException if [index] is out of bounds of this list. */ public E remove ( index : Int ) : E { if ( index < 0 || index >= this.size ) { throw new IndexOutOfBoundsException() } else { this[index] = null } }
throws IndexOutOfBoundsException { if ( index < 0 ) throw IndexOutOfBoundsException() if ( index > this.size() ) throw IndexOutOfBoundsException() if ( index < 0 || index > this.size() ) throw IndexOutOfBoundsException() if ( this.get( index ) != element ) throw IndexOutOfBoundsException() this.set( index , element ) return this } /** * Removes the element at the specified [index] from this list. * * @throws IndexOutOfBoundsException if [index] is out of bounds of this list. */ public fun remove ( index : Int ) throws IndexOutOfBoundsException { if ( index < 0 ) throw IndexOutOfBoundsException() if ( index > this.size() ) throw IndexOutOfBoundsException() if ( index < 0 || index > this.size() ) throw IndexOutOfBoundsException() if ( this.get( index ) != element ) throw IndexOutOfBoundsException() this.set( index , null )
throws IndexOutOfBoundsException : IndexOutOfBoundsException { if ( index < 0 || index >= this.size() ) { throw new IndexOutOfBoundsException( "removeAt: index out of bounds" ); } if ( index < 0 || index >= this.size() ) { throw new IndexOutOfBoundsException( "removeAt: index out of bounds" ); } if ( index < 0 || index >= this.size() ) { throw new IndexOutOfBoundsException( "removeAt: index out of bounds" ); } if ( index < 0 || index >= this.size() ) { throw new IndexOutOfBoundsException( "removeAt: index out of bounds" ); } if ( index < 0 || index >= this.size() ) { throw new IndexOutOfBoundsException( "removeAt: index out of bounds" ); } if ( index < 0 || index >= this.size() ) { throw new IndexOutOfBoundsException( "removeAt: index out of bounds" ); }





public fun x ( parameters : AxisParametersWithSetter . ( ) -> Unit = { } ) : Unit { parameters.x.setter( this ) } /** * Applies configurations to y-axis parameters. * * @param parameters the configurations to apply to the y-axis parameters. * * @param parameters the configurations to apply to the y-axis parameters. */ fun y ( parameters : AxisParametersWithSetter . ( ) -> Unit = { } ) : Unit { parameters.y.setter( this ) } /** * Applies configurations to z-axis parameters. * * @param parameters the configurations to apply to the z-axis parameters. * * @param parameters the configurations to apply to the z-axis parameters. */ fun z ( parameters : AxisParametersWithSetter . ( ) -> Unit = { } ) : Unit { parameters.z.setter( this ) } /** * Applies configurations to t-axis parameters. * * @param parameters the configurations to apply to the t-axis parameters. * * @param parameters the configuration







unable ( ) { try { return true; } catch ( Exception e ) { e.printStackTrace(); } return false; } /** * AGP 7+ is compiled with Java 8, but requires Java 11+ to run: * * > EvalIssueException: Android Gradle plugin requires Java 11 to run. You are currently using Java 1.8. * * @param args */ public static void main ( String[] args ) { if ( args.length < 2 ) { System.out.println( "Usage: " + args[0] ); System.exit( 1 ); } try { if ( args[1] == null ) { System.out.println( "Usage: " + args[0] ); System.exit( 1 ); } } catch ( Exception e ) { e.printStackTrace(); } try { if ( args[1].isEmpty() ) { System.out.println( "Usage: " + args[0] );
{ if ( this == other ) return true if ( this == null ) return false if ( other == null ) return false if ( context == null ) return false if ( context == this ) return true if ( context == other.context ) return false if ( context == null ) return false if ( context == this.context ) return false if ( context == other.context ) return false if ( context == null ) return false if ( context == this.context ) return false if ( context == other.context ) return false if ( context == null ) return false if ( context == this.context ) return false if ( context == other.context ) return false if ( context == null ) return false if ( context == this.context ) return false if ( context == other.context ) return false if ( context == null ) return false if ( context == this.context ) return false if ( context == other.context ) return false if ( context == null ) return false if ( context == this.context ) return false
{ if ( l == r ) { return true; } if ( l.isPrimitive() && r.isPrimitive() ) { return true; } if ( l.isPrimitive() && !r.isPrimitive() ) { return false; } if ( !l.isPrimitive() && r.isPrimitive() ) { return false; } if ( !l.isPrimitive() && !r.isPrimitive() ) { return false; } if ( !l.isPrimitive() && !r.isPrimitive() ) { return false; } if ( !l.isPrimitive() && !r.isPrimitive() ) { return false; } if ( !l.isPrimitive() && !r.isPrimitive() ) { return false; } if ( !l.isPrimitive() && !r.isPrimitive() ) { return false; } if ( !l.isPrimitive
File = new FirFile ( sourceFile , linesMapping ) * @param file * @param sourceFile * @param linesMapping * @return */ private fun convertFile ( file : LighterASTNode , sourceFile : KtSourceFile , linesMapping : KtSourceFileLinesMapping ) : FirFile { if ( file == null ) throw new IllegalArgumentException () if ( sourceFile == null ) throw new IllegalArgumentException () if ( linesMapping == null ) throw new IllegalArgumentException () return FirFile ( sourceFile , linesMapping ) } /** * [org.jetbrains.kotlin.parsing.KotlinParsing.parseFile] * [org.jetbrains.kotlin.parsing.KotlinParsing.parsePreamble] */ private fun convertFile ( file : LighterASTNode , sourceFile : KtSourceFile , linesMapping : KtSourceFileLinesMapping ) : FirFile { if ( file == null ) throw new IllegalArgumentException () if ( sourceFile == null
( block ) { if ( block == null ) { return null; } if ( block.isBlock ) { return convertBlockExpression ( block.getBlock () ); } if ( block.isFunction ) { return convertFunctionExpression ( block.getFunction () ); } if ( block.isVariable ) { return convertVariableExpression ( block.getVariable () ); } if ( block.isLiteral ) { return convertLiteralExpression ( block.getLiteral () ); } return null; } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseLiteralExpression */ fun convertLiteralExpression ( literal : LighterASTNode ) : Literal { if ( literal == null ) { return null; } if ( literal.isBlock ) { return convertBlockExpression ( literal.getBlock () ); } if ( literal.isFunction ) { return convert
( packageNode ) = FirPackageDirective ( packageNode ) /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parsePackageName * @see org.jetbrains.kotlin.parsing.KotlinParsing.parsePackageName * @see org.jetbrains.kotlin.parsing.KotlinParsing.parsePackageName * @see org.jetbrains.kotlin.parsing.KotlinParsing.parsePackageName * @see org.jetbrains.kotlin.parsing.KotlinParsing.parsePackageName * @see org.jetbrains.kotlin.parsing.KotlinParsing.parsePackageName * @see org.jetbrains.kotlin.parsing.KotlinParsing.parsePackageName * @see org.jetbrains.kotlin.parsing.KotlinParsing.parsePackageName * @see org.jetbrains.kotlin.par
{ if ( importDirective == null ) { return null } if ( importDirective.isDirective() ) { return importDirective } if ( importDirective.isImportDirective() ) { return importDirective } return null } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseImportStatement */ private fun convertImportStatement ( importStatement : LighterASTNode ) : FirImport statement { if ( importStatement == null ) { return null } if ( importStatement.isDirective() ) { return importStatement } if ( importStatement.isImportDirective() ) { return importStatement } return null } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseImportAlias */ private fun convertImportAlias ( importAlias : LighterASTNode ) : FirImport alias { if ( importAlias == null ) {
{ var result : List< FirImport > = ArrayList< FirImport >() if ( importList == null ) { return result } else if ( importList.isEmpty() ) { return result } else if ( importList.size() == 1 ) { result.add( importList.get( 0 ) ) return result } else if ( importList.size() == 2 ) { result.add( importList.get( 0 ) ) result.add( importList.get( 1 ) ) return result } else if ( importList.size() == 3 ) { result.add( importList.get( 0 ) ) result.add( importList.get( 1 ) ) result.add( importList.get( 2 ) ) return result } else if ( importList.size() == 4 ) { result.add( importList.get( 0 ) ) result.add( importList.get( 1 ) ) result.add( importList.get( 2 ) ) result.add( import
List { if ( isInClass ) { modifiers.filter { it.isInClass() } } else { modifiers.filter { it.isNotInClass() } } return modifiers } /** * Convert only modifiers * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseModifierList */ kotlinprivate fun convertModifierList ( modifiers : LighterASTNode , isInClass : Boolean = false ) : Modifier kotlinList { if ( isInClass ) { modifiers.filter { it.isInClass() } } else { modifiers.filter { it.isNotInClass() } } return modifiers } /** * Convert only modifiers * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseModifierList */ kotlinprivate fun convertModifierList ( modifiers : LighterASTNode , isInClass : Boolean = false ) : Modifier kotlinList { if ( isIn
: List<FirAnnotationCall> { if ( annotations.isEmpty() ) { return listOf( null ) } var result : List<FirAnnotationCall> = mutableListOf<FirAnnotationCall>() for ( annotation in annotations ) { if ( annotation.isModifier() ) { result.add( annotation ) } else { result.add( null ) } } return result } /** * Convert only annotations * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseModifierList */ kotlinprivate fun convertAnnotationList ( annotations : LighterASTNode ) : List<FirAnnotationCall> { if ( annotations.isEmpty() ) { return listOf( null ) } var result : List<FirAnnotationCall> = mutableListOf<FirAnnotationCall>() for ( annotation in annotations ) { if ( annotation.isModifier() ) { result.add( annotation )
List<LighterASTNode> { var result : LighterASTNodeList<LighterASTNode> = LighterASTNodeList<LighterASTNode>() for (modifier in modifiers) { result.add(modifier) } return result } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseTypeModifierList */ kotlinprivate fun convertTypeModifierList ( modifiers : LighterASTNodeList ) : LighterASTNodeList<LighterASTNode> { var result : LighterASTNodeList<LighterASTNode> = LighterASTNodeList<LighterASTNode>() for (modifier in modifiers) { result.add(modifier) } return result } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseTypeModifierList */ kotlinprivate fun convertTypeModifierList ( modifiers : LighterASTNodeListList ) : LighterASTNodeListList<LighterASTNode
( modifiers ) : TypeProjectionModifier { if ( modifiers.isEmpty() ) { return this } else { if ( modifiers.size() == 1 ) { return this } else if ( modifiers.size() == 2 ) { return this } else if ( modifiers.size() == 3 ) { return this } else if ( modifiers.size() == 4 ) { return this } else if ( modifiers.size() == 5 ) { return this } else if ( modifiers.size() == 6 ) { return this } else if ( modifiers.size() == 7 ) { return this } else if ( modifiers.size() == 8 ) { return this } else if ( modifiers.size() == 9 ) { return this } else if ( modifiers.size() == 10 ) { return this } else if ( modifiers.size() == 11 ) { return this } else if ( modifiers.size() == 12 ) { return this } else if ( modifiers.size() == 13
( modifiers ) { if ( modifiers.isEmpty() ) { return TypeParameterModifier.empty() } else if ( modifiers.size() == 1 ) { return modifiers[0] } else if ( modifiers.size() == 2 ) { return TypeParameterModifier( modifiers[0], modifiers[1] ) } else if ( modifiers.size() == 3 ) { return TypeParameterModifier( modifiers[0], modifiers[1], modifiers[2] ) } else if ( modifiers.size() == 4 ) { return TypeParameterModifier( modifiers[0], modifiers[1], modifiers[2], modifiers[3] ) } else if ( modifiers.size() == 5 ) { return TypeParameterModifier( modifiers[0], modifiers[1], modifiers[2], modifiers[3], modifiers[4] ) } else if ( modifiers.size() == 6 ) { return TypeParameterModifier( modifiers[0], modifiers[1], modifiers[2], modifiers[3], modifiers[4], modifiers[5] ) }
( ) : List < FirAnnotationCall > = { } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseAnnotationOrList * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseAnnotationOrList * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseAnnotationOrList * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseAnnotationOrList * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseAnnotationOrList * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseAnnotationOrList * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseAnnotationOrList * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseAnnotationOrList
: AnnotationUseSiteTarget { if ( annotationUseSiteTarget == null ) { annotationUseSiteTarget = new AnnotationUseSiteTarget() } if ( annotationUseSiteTarget.annotationTarget == null ) { annotationUseSiteTarget.annotationTarget = new AnnotationTarget() } if ( annotationUseSiteTarget.annotationTarget.annotationTarget == null ) { annotationUseSiteTarget.annotationTarget.annotationTarget = new AnnotationTarget() } if ( annotationUseSiteTarget.annotationTarget.annotationTarget.annotationTarget == null ) { annotationUseSiteTarget.annotationTarget.annotationTarget.annotationTarget = new AnnotationTarget() } if ( annotationUseSiteTarget.annotationTarget.annotationTarget.annotationTarget.annotationTarget == null ) { annotationUseSiteTarget.annotationTarget.annotationTarget.annotationTarget.annotationTarget = new AnnotationTarget() } if ( annotationUseSiteTarget.annotationTarget.annotationTarget.annotationTarget.annotationTarget.annotation
Entry ( unescapedAnnotation : LighterASTNode , defaultAnnotationUseSiteTarget : AnnotationUseSiteTarget ? = null , diagnostic : ConeDiagnostic ? = null , ) : ConeDiagnostic ( unescapedAnnotation : LighterASTNode , defaultAnnotationUseSiteTarget : AnnotationUseSiteTarget ? = null , diagnostic : ConeDiagnostic ? = null , ) : ConeDiagnostic ( unescapedAnnotation : LighterASTNode , defaultAnnotationUseSiteTarget : AnnotationUseSiteTarget ? = null , diagnostic : ConeDiagnostic ? = null , ) : ConeDiagnostic ( unescapedAnnotation : LighterASTNode , defaultAnnotationUseSiteTarget : AnnotationUseSiteTarget ? = null , diagnostic : ConeDiagnostic ? = null , ) : ConeDiagnostic ( unescapedAnnotation : LighterASTNode , defaultAnnotationUseSiteTarget : AnnotationUseSiteTarget ? = null , diagnostic : ConeDiagnostic ? = null , ) : ConeDiagnostic ( unescapedAnnotation : LighterASTNode , defaultAnnotationUseSiteTarget : AnnotationUseSiteTarget ?
{ if ( classNode == null ) { return null } if ( classNode.getName() == "FirDeclaration" ) { return new FirDeclaration( classNode ) } return null } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseFunctionDeclaration */ fun convertFunctionDeclaration ( functionNode : LighterASTNode ) : FunctionDeclaration { if ( functionNode == null ) { return null } if ( functionNode.getName() == "FunctionDeclaration" ) { return new FunctionDeclaration( functionNode ) } return null } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseClassDeclaration */ fun convertClassDeclaration ( classNode : LighterASTNode ) : ClassDeclaration { if ( classNode == null ) { return null } if ( classNode.getName() == "ClassDeclaration" ) {
( objectLiteral ) { if ( objectLiteral == null ) { return null; } if ( objectLiteral.isLiteral() ) { return objectLiteral; } if ( objectLiteral.isObjectLiteral() ) { return objectLiteral.getObjectLiteral(); } if ( objectLiteral.isArrayLiteral() ) { return objectLiteral.getArrayLiteral(); } if ( objectLiteral.isStringLiteral() ) { return objectLiteral.getStringLiteral(); } if ( objectLiteral.isBooleanLiteral() ) { return objectLiteral.getBooleanLiteral(); } if ( objectLiteral.isIntegerLiteral() ) { return objectLiteral.getIntegerLiteral(); } if ( objectLiteral.isFloatLiteral() ) { return objectLiteral.getFloatLiteral
: FirEnumEntry { if ( enumEntry == null ) { return null } if ( enumEntry.getName() == null ) { return null } if ( enumEntry.getName().isEmpty() ) { return null } if ( classWrapper == null ) { return null } if ( classWrapper.getName() == null ) { return null } if ( classWrapper.getName().isEmpty() ) { return null } if ( enumEntry.getValue() == null ) { return null } if ( enumEntry.getValue().isEmpty() ) { return null } if ( classWrapper.getValue() == null ) { return null } if ( classWrapper.getValue().isEmpty() ) { return null } return new FirEnumEntry( enumEntry.getName(), enumEntry.getValue() ) } /** * @see org.jetbrains.kot
{ if ( initializerList == null || initializerList.isEmpty() ) { return emptyList() } else { return initializerList } } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseInitializerList */ private fun parseInitializerList ( initializerList : List<FirExpression> ) : List<FirExpression> { if ( initializerList == null || initializerList.isEmpty() ) { return emptyList() } else { return initializerList } } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseInitializerList */ private fun parseInitializerList ( initializerList : List<FirExpression> ) : List<FirExpression> { if ( initializerList == null || initializerList.isEmpty() ) { return emptyList() } else { return initializerList } } /** * @
{ var declarations : List<FirDeclaration> = ArrayList<FirDeclaration>() declarations.addAll(classBody.declarations) declarations.addAll(classWrapper.declarations) return declarations } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseFunctionBody * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseClassBody * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseEnumBody * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseClassBody * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseEnumBody * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseEnumBody * @see org.jetbrains.kotlin.parsing.KotlinParsing

: LighterASTNode { var declaration : LighterASTNode = anonymousInitializer declaration.className = classWrapper.className return declaration } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseFunctionDeclaration * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseMethodDeclaration * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseClassDeclaration * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseInterfaceDeclaration * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseEnumDeclaration * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseStructDeclaration * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseUnionDeclaration * @see org.jetbrains.
ype = secondaryConstructor /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parsePrimaryConstructor * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseSecondaryConstructor * @see org.jetbrains.kotlin.parsing.KotlinParsing.parsePrimaryConstructor * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseSecondaryConstructor * @see org.jetbrains.kotlin.parsing.KotlinParsing.parsePrimaryConstructor * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseSecondaryConstructor * @see org.jetbrains.kotlin.parsing.KotlinParsing.parsePrimaryConstructor * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseSecondaryConstructor * @see org.jetbrains.kot
{ return constructorDelegationCall.visit(this) } /** * @see org.jetbrains.kotlin.fir.builder.RawFirBuilder.Visitor.convert( * KtConstructorDelegationCall, FirTypeRef, Boolean) */ private fun convertConstructorDelegationCall ( constructorDelegationCall : LighterASTNode , classWrapper : ClassWrapper ) : FirDelegatedConstructorCall? /** * @see org.jetbrains.kotlin.fir.builder.RawFirBuilder.Visitor.convert( * KtConstructorDelegationCall, FirTypeRef, Boolean) */ private fun convertConstructorDelegationCall ( constructorDelegationCall : LighterASTNode , classWrapper : ClassWrapper ) : FirDelegatedConstructorCall? /** * @see org.jetbrains.kotlin.fir.builder.RawFirBuilder.Visitor.convert( * KtConstructorDelegationCall, FirTypeRef, Boolean) */ private fun convertConstructorDeleg
: LighterASTNode { var declaration : LighterASTNode = this declaration.typeAlias = typeAlias return declaration } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseDeclaration * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseFunctionDeclaration * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseClassDeclaration * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseEnumDeclaration * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseInterfaceDeclaration * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseMethodDeclaration * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseStructDeclaration * @see org.jetbrains.kotlin.parsing
Property ( property , classWrapper ) { if ( classWrapper == null ) { classWrapper = property.getClass () } return new FirDeclaration ( property.getName () , classWrapper ) } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseFunctionDeclaration */ kotlinfun convertFunctionDeclaration ( function : LighterASTNode , classWrapper : ClassWrapper ? = null ) : FunctionDeclaration kotlinFunction ( function , classWrapper ) { if ( classWrapper == null ) { classWrapper = function.getClass () } return new FunctionDeclaration ( function.getName () , classWrapper ) } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseMethodDeclaration */ kotlinfun convertMethodDeclaration ( method : LighterASTNode , classWrapper : ClassWrapper ? = null ) : MethodDeclaration kotlinMethod ( method , classWrapper ) { if
{ if (destructingDeclaration == null) { return null; } if (destructingDeclaration.name == null) { return null; } if (destructingDeclaration.type == null) { return null; } return new DestructuringDeclaration(destructingDeclaration.name, destructingDeclaration.type); } /** * @see org.jetbrains.kotlin.fir.builder.RawFirBuilder.Visitor.visitDestructuringDeclaration */ kotlininternal fun convertDestructingDeclaration ( destructingDeclaration : LighterASTNode ) : DestructuringDeclaration { if (destructingDeclaration == null) { return null; } if (destructingDeclaration.name == null) { return null; } if (destructingDeclaration.type == null) { return null; } return new DestructuringDeclaration(destructingDeclaration.name, destructingDeclaration.type); } /** * @see
: DestructuringEntry { if ( entry == null ) { return null } if ( entry.getName().isEmpty() ) { return null } return new DestructuringEntry( entry.getName() ) } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseMultiDeclarationName */ kotlinprivate fun convertDestructingDeclarationEntry ( entry : LighterASTNode ) : DestructuringEntry { if ( entry == null ) { return null } if ( entry.getName().isEmpty() ) { return null } return new DestructuringEntry( entry.getName() ) } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseMultiDeclarationName */ kotlinprivate fun convertDestructingDeclarationEntry ( entry : LighterASTNode ) : DestructuringEntry { if ( entry == null ) { return null } if (
: LighterASTNode { if (getterOrSetter instanceof PropertyAccessor) { return getterOrSetter } else if (getterOrSetter instanceof LighterASTNode) { return getterOrSetter as LighterASTNode } else if (getterOrSetter instanceof PropertyNode) { return getterOrSetter as PropertyNode } else if (getterOrSetter instanceof PropertyReference) { return getterOrSetter as PropertyReference } else if (getterOrSetter instanceof PropertyAnnotation) { return getterOrSetter as PropertyAnnotation } else if (getterOrSetter instanceof PropertyModifier) { return getterOrSetter as PropertyModifier } else if (getterOrSetter instanceof PropertyVisibility) { return getterOrSetter as PropertyVisibility } else if (getterOrSetter instanceof PropertySymbol) { return getterOrSetter as PropertySymbol } else if (getterOrSetter instanceof Modifier) {
( propertyModifiers : Modifier , propertyReturnType : FirTypeRef , isVar : Boolean , annotationsFromProperty : List < FirAnnotationCall > , property : LighterASTNode , ) : LighterASTNode ( propertyModifiers : Modifier , propertyReturnType : FirTypeRef , isVar : Boolean , annotationsFromProperty : List < FirAnnotationCall > , property : LighterASTNode , ) : LighterASTNode ( propertyModifiers : Modifier , propertyReturnType : FirTypeRef , isVar : Boolean , annotationsFromProperty : List < FirAnnotationCall > , property : LighterASTNode , ) : LighterASTNode ( propertyModifiers : Modifier , propertyReturnType : FirTypeRef , isVar : Boolean , annotationsFromProperty : List < FirAnnotationCall > , property : LighterASTNode , ) : LighterASTNode ( propertyModifiers : Modifier , propertyReturnType : FirTypeRef , isVar : Boolean , annotationsFromProperty : List < FirAnnotationCall > , property : LighterASTNode , ) : LighterASTNode ( propertyModifiers : Modifier , propertyReturnType : FirTypeRef , isVar : Boolean , annotationsFromProperty : List

{ if ( functionDeclaration == null ) { return null; } if ( functionDeclaration.getName() == null ) { return null; } if ( functionDeclaration.getName().length() == 0 ) { return null; } if ( functionDeclaration.getName().startsWith( "public" ) ) { return null; } if ( functionDeclaration.getName().startsWith( "protected" ) ) { return null; } if ( functionDeclaration.getName().startsWith( "private" ) ) { return null; } if ( functionDeclaration.getName().startsWith( "implements" ) ) { return null; } if ( functionDeclaration.getName().startsWith( "interface" ) ) { return null; } if ( functionDeclaration.getName().startsWith( "abstract" ) ) { return null; } if ( functionDeclaration.getName().

nt { if ( block == null ) { return null; } if ( block.getType() == LighterASTNode.TYPE_FUNCTION ) { return parseFunction( block ); } if ( block.getType() == LighterASTNode.TYPE_VARIABLE ) { return parseVariable( block ); } if ( block.getType() == LighterASTNode.TYPE_NUMBER ) { return parseNumber( block ); } if ( block.getType() == LighterASTNode.TYPE_STRING ) { return parseString( block ); } if ( block.getType() == LighterASTNode.TYPE_IDENTIFIER ) { return parseIdentifier( block ); } if ( block.getType() == LighterASTNode.TYPE_OPERATOR ) { return parseOperator( block ); } if ( block.getType() == LighterASTNode.TYPE_LITERAL ) { return parseLiteral( block ); } if (

Ref = delegateFieldsMap[index] * * implicitDelegation * : userType "by" element * ; */ /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseImplicitDelegationSpecifier * * implicitDelegation * : userType "by" element * ; */ /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseImplicitDelegationSpecifier * * implicitDelegation * : userType "by" element * ; */ /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseImplicitDelegationSpecifier * * implicitDelegation * : userType "by" element * ; */ /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseImplicitDelegationSpecifier * * implicitDelegation * : userType "by
private fun convertTypeParameters ( typeParameterList : LighterASTNode , typeConstraints : List < TypeConstraint > , containingDeclarationSymbol : FirBasedSymbol < * > ) : List < FirTypeParameter > /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseTypeParameterList */ /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseTypeParameterList */ /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseTypeParameterList */ /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseTypeParameterList */ /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseTypeParameterList */ /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseTypeParameterList */ /** * @see org.
{ if ( typeConstraints == null || typeConstraints.isEmpty() ) { return ArrayList<TypeConstraint>() } var typeConstraintsList : List<TypeConstraint> = ArrayList<TypeConstraint>() typeConstraints.forEach { typeConstraint -> typeConstraintsList.add( typeConstraint ) } return typeConstraintsList } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseTypeConstraintList */ kotlinprivate fun convertTypeConstraints ( typeConstraints : LighterASTNode ) : List < TypeConstraint > kotlin { if ( typeConstraints == null || typeConstraints.isEmpty() ) { return ArrayList<TypeConstraint>() } var typeConstraintsList : List<TypeConstraint> = ArrayList<TypeConstraint>() typeConstraints.forEach { typeConstraint -> typeCon
: TypeConstraint { if ( typeConstraint == null ) return typeConstraint if ( typeConstraint.isEmpty() ) return typeConstraint if ( typeConstraint.isNull() ) return typeConstraint if ( typeConstraint.isString() ) return typeConstraint if ( typeConstraint.isBoolean() ) return typeConstraint if ( typeConstraint.isInteger() ) return typeConstraint if ( typeConstraint.isLong() ) return typeConstraint if ( typeConstraint.isFloat() ) return typeConstraint if ( typeConstraint.isDouble() ) return typeConstraint if ( typeConstraint.isDate() ) return typeConstraint if ( typeConstraint.isDateTime() ) return typeConstraint if ( typeConstraint.isDate() ) return typeConstraint if ( typeConstraint.isTime() ) return typeConstraint if ( typeConstraint.isDuration() ) return typeCon
Parameter ( typeParameter : LighterASTNode , typeConstraints : List < TypeConstraint > , containingSymbol : FirBasedSymbol < * > ) : FirTypeParameter ( typeParameter : LighterASTNode , typeConstraints : List < TypeConstraint > , containingSymbol : FirBasedSymbol < * > ) : FirTypeParameter ( typeParameter : LighterASTNode , typeConstraints : List < TypeConstraint > , containingSymbol : FirBasedSymbol < * > ) : FirTypeParameter ( typeParameter : LighterASTNode , typeConstraints : List < TypeConstraint > , containingSymbol : FirBasedSymbol < * > ) : FirTypeParameter ( typeParameter : LighterASTNode , typeConstraints : List < TypeConstraint > , containingSymbol : FirBasedSymbol < * > ) : FirTypeParameter ( typeParameter : LighterASTNode , typeConstraints : List < TypeConstraint > , containingSymbol : FirBasedSymbol < * > ) : FirTypeParameter ( typeParameter : LighterASTNode , typeConstraints : List < TypeConstraint > , containingSymbol : Fir
{ if ( type == null ) return null if ( type.getName() == "Fir" ) return FirTypeRef.Fir if ( type.getName() == "Fir1" ) return FirTypeRef.Fir1 if ( type.getName() == "Fir2" ) return FirTypeRef.Fir2 if ( type.getName() == "Fir3" ) return FirTypeRef.Fir3 if ( type.getName() == "Fir4" ) return FirTypeRef.Fir4 if ( type.getName() == "Fir5" ) return FirTypeRef.Fir5 if ( type.getName() == "Fir6" ) return FirTypeRef.Fir6 if ( type.getName() == "Fir7" ) return FirTypeRef.Fir7 if ( type.getName() == "Fir8" ) return FirTypeRef.Fir8 if ( type.getName() == "Fir9" ) return FirTypeRef.Fir9 if ( type.get
{ if ( receiverType == null ) { return null } else if ( receiverType == LighterASTNode.TYPE_REF ) { return LighterASTNode.TYPE_REF } else if ( receiverType == LighterASTNode.TYPE_REF_REF ) { return LighterASTNode.TYPE_REF_REF } else if ( receiverType == LighterASTNode.TYPE_REF_REF_REF ) { return LighterASTNode.TYPE_REF_REF_REF } else if ( receiverType == LighterASTNode.TYPE_REF_REF_REF_REF ) { return LighterASTNode.TYPE_REF_REF_REF_REF } else if ( receiverType == LighterASTNode.TYPE_REF_REF_REF_REF_REF ) { return LighterASTNode.TYPE_REF_REF_REF_REF_REF } else if ( receiverType == LighterASTNode.TYPE_REF_REF_REF_REF_REF_REF_REF ) { return LighterASTNode.
( typeRefSource , nullableType , allTypeModifiers , isNullable ) { if ( nullableType == null ) { return null } if ( allTypeModifiers == null ) { allTypeModifiers = mutableListOf () } allTypeModifiers.add ( nullableType ) return null } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parsePrimitiveTypeSuffix */ ktprivate fun convertPrimitiveType ( typeRefSource : KtSourceElement , primitiveType : LighterASTNode , allTypeModifiers : MutableList < Modifier > , isNullable : Boolean = true ) : FirTypeRef wink ( typeRefSource , primitiveType , allTypeModifiers , isNullable ) { if ( nullableType == null ) { return null } if ( allTypeModifiers == null ) { allTypeModifiers = mutableListOf () } allTypeModifiers.add ( nullableType ) return null }
{ if ( isNullable ) { return null } if ( userType == null ) { return null } if ( typeRefSource == null ) { return null } if ( typeRefSource.typeRef == null ) { return null } if ( typeRefSource.typeRef.typeRef == null ) { return null } if ( typeRefSource.typeRef.typeRef.typeRef == null ) { return null } if ( typeRefSource.typeRef.typeRef.typeRef.typeRef == null ) { return null } if ( typeRefSource.typeRef.typeRef.typeRef.typeRef.typeRef == null ) { return null } if ( typeRefSource.typeRef.typeRef.typeRef.typeRef.typeRef.typeRef == null ) { return null } if ( typeRefSource.typeRef.typeRef.typeRef.typeRef.typeRef.typeRef.typeRef == null ) {
{ if ( allowedUnderscoredTypeArgument ) { typeArguments = typeArguments.filter { it.isUnderscoredTypeArgument } } else { typeArguments = typeArguments.filter { it.isNotUnderscoredTypeArgument } } return typeArguments } /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseTypeArgumentList */ kotlinfun convertTypeArguments ( typeArguments : LighterASTNode , allowedUnderscoredTypeArgument : Boolean ) : List < FirTypeProjection > { if ( allowedUnderscoredTypeArgument ) { typeArguments = typeArguments.filter { it.isUnderscoredTypeArgument } } else { typeArguments = typeArguments.filter { it.isNotUnderscoredTypeArgument } } return typeArguments } /** * @see org.jetbrains.k
Projection = typeProjection /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.tryParseTypeArgumentList * @see org.jetbrains.kotlin.parsing.KotlinParsing.tryParseTypeArgumentList * @see org.jetbrains.kotlin.parsing.KotlinParsing.tryParseTypeArgumentList * @see org.jetbrains.kotlin.parsing.KotlinParsing.tryParseTypeArgumentList * @see org.jetbrains.kotlin.parsing.KotlinParsing.tryParseTypeArgumentList * @see org.jetbrains.kotlin.parsing.KotlinParsing.tryParseTypeArgumentList * @see org.jetbrains.kotlin.parsing.KotlinParsing.tryParseTypeArgumentList * @see org.jetbrains.kotlin.parsing.KotlinPar
( typeRefSource , functionType , isNullable , isSuspend ) /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseFunctionType */ private fun convertFunctionType ( typeRefSource : KtSourceElement , functionType : LighterASTNode , isNullable : Boolean = false , isSuspend : Boolean = false ) : LighterASTNode /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseFunctionType */ private fun convertFunctionType ( typeRefSource : KtSourceElement , functionType : LighterASTNode , isNullable : Boolean = false , isSuspend : Boolean = false ) : LighterASTNode /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseFunctionType */ private fun convertFunctionType ( typeRefSource : KtSourceElement , functionType : LighterASTNode , isNullable : Boolean = false , isSuspend : Boolean = false ) : LighterASTNode
{ if ( additionalAnnotations == emptyList ( ) ) { additionalAnnotations = new ArrayList < FirAnnotation > ( ) } else { additionalAnnotations.addAll ( additionalAnnotations ) } if ( valueParameterDeclaration == null ) { valueParameterDeclaration = new ValueParameterDeclaration () } else { valueParameterDeclaration.addAll ( valueParameterDeclaration ) } if ( functionSymbol == null ) { functionSymbol = new FunctionSymbol () } else { functionSymbol.addAll ( functionSymbol ) } if ( valueParameterDeclaration == null ) { valueParameterDeclaration = new ValueParameterDeclaration () } else { valueParameterDeclaration.addAll ( valueParameterDeclaration ) } if ( functionSymbol == null ) { functionSymbol = new FunctionSymbol () } else { functionSymbol.addAll ( functionSymbol ) } if ( valueParameterDeclaration == null ) { valueParameterDeclaration = new
Parameter ( valueParameter : LighterASTNode , functionSymbol : FirFunctionSymbol < * > ? , valueParameterDeclaration : ValueParameterDeclaration , additionalAnnotations : List < FirAnnotation > = emptyList ( ) ) /** * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseValueParameter * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseValueParameter * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseValueParameter * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseValueParameter * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseValueParameter * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseValueParameter * @see org.jetbrains.kotlin.parsing.KotlinParsing.parseValueParameter * @see org.jetbr

= new OutputStream ( ) /** * Returns an output stream that writes to this sink. Closing the stream will also close this sink. * * @sample kotlinx.io.samples.KotlinxIoSamplesJvm.asStream */ kotlinx.io.samples.KotlinxIoSamplesJvm.asStream /** * Returns an output stream that writes to this sink. Closing the stream will also close this sink. * * @sample kotlinx.io.samples.KotlinxIoSamplesJvm.asStream */ kotlinx.io.samples.KotlinxIoSamplesJvm.asStream /** * Returns an output stream that writes to this sink. Closing the stream will also close this sink. * * @sample kotlinx.io.samples.KotlinxIoSamplesJvm.asStream */ kotlinx.io.samples.KotlinxIoSamplesJvm.asStream /** * Returns an output stream that writes to this sink. Closing the stream will also close thi

: WritableByteChannel { return this } /** * Returns [WritableByteChannel] backed by this sink. Closing the channel will also close the sink. */ sinkpublic fun Sink . asByteChannel ( ) : WritableByteChannel : WritableByteChannel { return this } /** * Returns [WritableByteChannel] backed by this sink. Closing the channel will also close the sink. */ sinkpublic fun Sink . asByteChannel ( ) : WritableByteChannel : WritableByteChannel { return this } /** * Returns [WritableByteChannel] backed by this sink. Closing the channel will also close the sink. */ sinkpublic fun Sink . asByteChannel ( ) : WritableByteChannel : WritableByteChannel { return this } /** * Returns [WritableByteChannel] backed by this sink. Closing the channel will also close the sink. */ sinkpublic fun Sink . asByteChannel ( ) : WritableByteChannel : WritableByteChannel { return this } /** * Returns [WritableByteChannel] backed by this sink. Closing the channel

* * @throws NoSuchElementException if the progression is empty. * * @throws NoSuchElementException if the progression is empty. * * @throws NoSuchElementException if the progression is empty. * * @throws NoSuchElementException if the progression is empty. * * @throws NoSuchElementException if the progression is empty. * * @throws NoSuchElementException if the progression is empty. * * @throws NoSuchElementException if the progression is empty. * * @throws NoSuchElementException if the progression is empty. * * @throws NoSuchElementException if the progression is empty. * * @throws NoSuchElementException if the progression is empty. * * @throws NoSuchElementException if the progression is empty. * * @throws NoSuchElementException if the progression is empty. * * @throws NoSuchElementException if the progression is empty. * * @throws NoSuchElementException if the progression is empty. *
/** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /**
/** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /**
{ if ( this.isEmpty () ) throw new NoSuchElementException () return this.get ( this.size - 1 ) } /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the last element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty
{ if ( this.isEmpty () ) throw new NoSuchElementException () return this[ this.size - 1 ] } /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the last element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty.
{ if ( this.isEmpty () ) return null return this[ this.size - 1 ] } /** * Returns the first element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.firstOrNull ( ) : UInt ? */ fun UIntProgression . firstOrNull ( ) : UInt ? { if ( this.isEmpty () ) return null return this[ 0 ] } /** * Returns the last element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.lastOrNull ( ) : UInt ? */ fun UIntProgression . lastOrNull ( ) : UInt ? { if ( this.isEmpty () ) return null return this[ this.size - 1 ] } /** * Returns the first element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.first ( ) : UInt ? */ fun U
@ SinceKotlin ( " kotlin" ) /** * Returns the first element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.firstOrNull */ /** * Returns the last element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.lastOrNull */ /** * Returns the first element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.firstOrNullOrNull */ /** * Returns the last element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.lastOrNullOrNull */ /** * Returns the first element, or `null` if the progression is empty. * * @
@ kotlin . internal . InlineOnly /** * Returns a random element from this range. * * @throws IllegalArgumentException if this range is empty. */ UIntRange . random ( ) : UInt /** * Returns a random element from this range. * * @throws IllegalArgumentException if this range is empty. */ UIntRange . random ( ) : UInt /** * Returns a random element from this range. * * @throws IllegalArgumentException if this range is empty. */ UIntRange . random ( ) : UInt /** * Returns a random element from this range. * * @throws IllegalArgumentException if this range is empty. */ UIntRange . random ( ) : UInt /** * Returns a random element from this range. * * @throws IllegalArgumentException if this range is empty. */ UIntRange . random ( ) : UInt /** * Returns a random element from this range. * * @throws IllegalArgumentException
{ * * @return a random element from this range. * * @throws IllegalArgumentException if this range is empty. */ public inline fun ULongRange.random () : ULong { if ( this.size == 0 ) { throw IllegalArgumentException( "This range is empty." ) } return this.randomized().next() } /** * Returns a random element from this range. * * @throws IllegalArgumentException if this range is empty. */ public inline fun UIntRange.random () : UInt { if ( this.size == 0 ) { throw IllegalArgumentException( "This range is empty." ) } return this.randomized().next() } /** * Returns a random element from this range. * * @throws IllegalArgumentException if this range is empty. */ public inline fun IntRange.random () : Int { if ( this.size == 0 ) { throw IllegalArgumentException( "This range is empty." ) } return thi
* * @throws IllegalArgumentException if this range is empty. */ public fun UIntRange . random ( random : Random ) : UInt { if ( this.isEmpty() ) throw IllegalArgumentException( "UIntRange is empty" ) return this.random( random ) } /** * Returns a random element from this range using the specified source of randomness. * * @throws IllegalArgumentException if this range is empty. */ public fun UIntRange . random ( random : Random ) : UInt { if ( this.isEmpty() ) throw IllegalArgumentException( "UIntRange is empty" ) return this.random( random ) } /** * Returns a random element from this range using the specified source of randomness. * * @throws IllegalArgumentException if this range is empty. */ public fun UIntRange . random ( random : Random ) : UInt { if ( this.isEmpty() ) throw IllegalArgumentException( "UIntRange is empty" ) return thi
public fun UIntRange . random ( random : Random ) : UInt public fun IntRange . random ( random : Random ) : Int public fun LongRange . random ( random : Random ) : Long public fun FloatRange . random ( random : Random ) : Float public fun DoubleRange . random ( random : Random ) : Double public fun BooleanRange . random ( random : Random ) : Boolean public fun StringRange . random ( random : Random ) : String public fun ByteRange . random ( random : Random ) : Byte public fun ShortRange . random ( random : Random ) : Short public fun IntRange . random ( random : Random ) : Int public fun LongRange . random ( random : Random ) : Long public fun FloatRange . random ( random : Random ) : Float public fun DoubleRange . random ( random : Random ) : Double public fun BooleanRange . random ( random : Random ) : Boolean public fun StringRange . random ( random : Random ) : String public fun ByteRange . random ( random : Random ) : Byte public fun ShortRange . random ( random : Random ) :
*/ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /**
/** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** *
/** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ /** * Returns a
/** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.
/** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. *
*/ public inline operator fun ULongRange.contains ( element : ULong ? ) : Boolean { if ( element == null ) { return false; } if ( element == this ) { return true; } if ( element < this ) { return false; } if ( element > this ) { return true; } return false; } /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ public inline operator fun UIntRange.contains ( element : UInt ? ) : Boolean { if ( element == null ) { return false; } if ( element == this ) { return true; } if ( element < this ) { return false; } if ( element > this ) { return true; } return false; } /** * Returns `true` if this range contains the specified [element]. *
{ if ( value < 0 ) { return false; } if ( value > UByte.MAX_VALUE ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range. */ UByteRange . contains ( value : UByte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UByteRange . contains ( value : UByte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UByteRange . contains ( value : UByte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UByteRange . contains ( value : UByte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UByteRange . contains ( value : UByte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UByteRange . contains ( value : UByte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UByteRange .
{ if ( value < 0 ) { return false; } if ( value > UByte.MAX_VALUE ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range. */ UByteRange . contains ( value : UByte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UByteRange . contains ( value : UByte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UByteRange . contains ( value : UByte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UByteRange . contains ( value : UByte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UByteRange . contains ( value : UByte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UByteRange . contains ( value : UByte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UByteRange .
{ if ( value < 0 ) { return false; } if ( value > UInt.MAX_VALUE ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : UInt ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : UInt ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : UInt ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : UInt ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : UInt ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : UInt ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UIntRange .
{ if ( value < 0 ) { return false; } if ( value > this.max ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : ULong ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : ULong ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : ULong ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : ULong ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : ULong ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : ULong ) : Boolean /** * Checks if the specified [value] belongs to this range. */ U
{ if ( value < 0 ) { return false; } if ( value > this.max ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : UShort ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : UShort ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : UShort ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : UShort ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : UShort ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UIntRange . contains ( value : UShort ) : Boolean /** * Checks if the specified [value] belongs to this range. */ U
{ if ( value < 0 ) { return false; } if ( value > this.size ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range. */ UShortRange . contains ( value : UShort ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UInt16Range . contains ( value : UShort ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UInt32Range . contains ( value : UShort ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UInt64Range . contains ( value : UShort ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UInt128Range . contains ( value : UShort ) : Boolean /** * Checks if the specified [value] belongs to this range. */ UInt256Range . contains ( value : UShort ) : Boolean /** * Checks if the specified [value] belongs to thi




/** * Returns a progression that goes over the same range in the opposite direction with the same step. */ UIntProgression . reversed ( ) : UIntProgression /** * Returns a progression that goes over the same range in the opposite direction with the same step. */ UIntProgression . reversed ( ) : UIntProgression /** * Returns a progression that goes over the same range in the opposite direction with the same step. */ UIntProgression . reversed ( ) : UIntProgression /** * Returns a progression that goes over the same range in the opposite direction with the same step. */ UIntProgression . reversed ( ) : UIntProgression /** * Returns a progression that goes over the same range in the opposite direction with the same step. */ UIntProgression . reversed ( ) : UIntProgression /** * Returns a progression that goes over the same range in the opposite direction with the same step. */ UIntProgression . reversed ( ) : UIntProgression /** * Returns a progression that goes over the same range in the opposite direction with the same
/** * Returns a progression that goes over the same range in the opposite direction with the same step. */ ULongProgression . reversed ( ) : ULongProgression /** * Returns a progression that goes over the same range in the opposite direction with the same step. */ ULongProgression . reversed ( ) : ULongProgression /** * Returns a progression that goes over the same range in the opposite direction with the same step. */ ULongProgression . reversed ( ) : ULongProgression /** * Returns a progression that goes over the same range in the opposite direction with the same step. */ ULongProgression . reversed ( ) : ULongProgression /** * Returns a progression that goes over the same range in the opposite direction with the same step. */ ULongProgression . reversed ( ) : ULongProgression /** * Returns a progression that goes over the same range in the opposite direction with the same step. */ ULongProgression . reversed ( ) : ULongProgression /** * Returns a progression that goes over the same range in the opposite direction with the same
( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) : UIntProgression ( step : Int ) :
( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) : ULongProgression ( step : Long ) :
/** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ until ( to : UByte ) : UIntRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ until ( to : UByte ) : UIntRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ until ( to : UByte ) : UIntRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ until ( to : UByte ) : UIntRange
/** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ until ( to : UInt ) : UIntRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ until ( to : UInt ) : UIntRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ until ( to : UInt ) : UIntRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ until ( to : UInt ) : UIntRange
/** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ until ( to : ULong ) : ULongRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ until ( to : ULong ) : ULongRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ until ( to : ULong ) : ULongRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ until ( to : ULong ) : ULongRange
/** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ until ( to : UShort ) : UIntRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ until ( to : UShort ) : UIntRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ until ( to : UShort ) : UIntRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ until ( to : UShort )


















Internal ( visible : Boolean = false , ) canBeResolved ( visible : Boolean = false , ) canBeConsumed ( visible : Boolean = false , ) canBeDeclared ( visible : Boolean = false , ) : Boolean = false */ /** * Mark this [Configuration] as one that will be consumed by other subprojects. * * Consumable Configurations must extend a [declarable] Configuration. * They should have attributes. * * ``` * isCanBeResolved = false * isCanBeConsumed = true * isCanBeDeclared = false * ``` */ /** * Mark this [Configuration] as one that will be consumed by other subprojects. * * Consumable Configurations must extend a [declarable] Configuration. * They should have attributes. * * ``` * isCanBeResolved = false * isCanBeConsumed = true * isCanBeDeclared = false * ``` */ /** * Mark this [Configuration] as one that will be consumed by other subprojects. * * Consumable Configurations must extend a
Internal ( canBeResolved : Boolean = true , canBeConsumed : Boolean = false , canBeDeclared : Boolean = false ) * * Resolvable Configurations should have attributes. * * ``` * isCanBeResolved = true * isCanBeConsumed = false * isCanBeDeclared = false * ``` */ /** * Mark this [Configuration] as one that will consume artifacts from other subprojects (also known as 'resolving') * * Resolvable Configurations should have attributes. * * ``` * isCanBeResolved = true * isCanBeConsumed = false * isCanBeDeclared = false * ``` */ /** * Mark this [Configuration] as one that will consume artifacts from other subprojects (also known as 'resolving') * * Resolvable Configurations should have attributes. * * ``` * isCanBeResolved = true * isCanBeConsumed = false * isCanBeDeclared = false * ``` */ /** * Mark this [Configuration] as one that will consume


: TimeMark { return this } /** * Marks a point in time on this time source. * * The returned [TimeMark] instance encapsulates the captured time point and allows querying * the duration of time interval [elapsed][TimeMark.elapsedNow] from that point. * * The returned [TimeMark] instance encapsulates the captured time point and allows querying * the duration of time interval [elapsed][TimeMark.elapsedNow] from that point. * * The returned [TimeMark] instance encapsulates the captured time point and allows querying * the duration of time interval [elapsed][TimeMark.elapsedNow] from that point. * * The returned [TimeMark] instance encapsulates the captured time point and allows querying * the duration of time interval [elapsed][TimeMark.elapsedNow] from that point. * * The returned [TimeMark] instance encapsulates the captured time point and allows querying * the duration of time interval [elapsed][TimeMark.elapsedNow] from that point. * * The returned [TimeMark] instance encapsulates the captured time





: Boolean = true /** * Returns true if this time mark has passed according to the time source from which this mark was taken. * * Note that the value returned by this function can change on subsequent invocations. * If the time source is monotonic, it can change only from `false` to `true`, namely, when the time mark becomes behind the current point of the time source. */ /** * Returns true if this time mark has passed according to the time source from which this mark was taken. * * Note that the value returned by this function can change on subsequent invocations. * If the time source is monotonic, it can change only from `false` to `true`, namely, when the time mark becomes behind the current point of the time source. */ /** * Returns true if this time mark has passed according to the time source from which this mark was taken. * * Note that the value returned by this function can change on subsequent invocations. * If the time source is monotonic, it can change only from `false` to `true`, namely, when the time mark becomes behind the current point of the time source.
: Boolean = true /** * Returns false if this time mark has passed according to the time source from which this mark was taken. * * Note that the value returned by this function can change on subsequent invocations. * If the time source is monotonic, it can change only from `false` to `true`, namely, when the time mark becomes ahead of the current point of the time source. */ /** * Returns false if this time mark has passed according to the time source from which this mark was taken. * * Note that the value returned by this function can change on subsequent invocations. * If the time source is monotonic, it can change only from `true` to `false`, namely, when the time mark becomes behind the current point of the time source. */ /** * Returns false if this time mark has passed according to the time source from which this mark was taken. * * Note that the value returned by this function can change on subsequent invocations. * If the time source is monotonic, it can change only from `false` to `true`, namely, when the time mark becomes ahead of the current point of the


override { if ( this == other ) { return true } if ( this == null ) { return false } if ( other == null ) { return false } if ( this.source != other.source ) { return false } if ( this.timeSource != other.timeSource ) { return false } if ( this.time == other.time ) { return true } if ( this.time < other.time ) { return false } if ( this.time > other.time ) { return true } return false } /** * Returns `true` if two time marks from different time sources represent the same moment of time, and `false` otherwise, * including the situation when the time marks were obtained from different time sources. */ timeoverride fun equals ( other : Any ? ) : Boolean timeoverride { if ( this == other ) { return true } if ( this == null ) { return false }
( ) : List < SteppingTestLoggedData > { if ( loggedItems.isEmpty() ) { return ArrayList<SteppingTestLoggedData>() } var result = ArrayList<SteppingTestLoggedData>() for ( loggedItem in loggedItems ) { if ( loggedItem.lineNumber != null ) { result.add( loggedItem ) } } return result } /** * Compresses sequences of the same location without line number in the log: * specifically removes locations without linenumber, that would otherwise * print as byte offsets. This avoids overspecifying code generation * strategy in debug tests. */ /** * Compresses sequences of the same location without line number in the log: * specifically removes locations without linenumber, that would otherwise * print as byte offsets. This avoids overspecifying code generation * strategy in debug tests. */ /** * Compresses sequences of the same location without line number in the log: * specifically removes locations without linenumber, that would otherwise * print as byte offsets. This avoids overspecifying code generation *
one( ) : Boolean { if ( isRuntimeOrCompileConfigurationsAvailable( ) ) { return true } if ( isRuntimeOrCompileConfigurationsAvailable( ) ) { return false } if ( isRuntimeOrCompileConfigurationsAvailable( ) ) { return false } if ( isRuntimeOrCompileConfigurationsAvailable( ) ) { return false } if ( isRuntimeOrCompileConfigurationsAvailable( ) ) { return false } if ( isRuntimeOrCompileConfigurationsAvailable( ) ) { return false } if ( isRuntimeOrCompileConfigurationsAvailable( ) ) { return false } if ( isRuntimeOrCompileConfigurationsAvailable( ) ) { return false } if ( isRuntimeOrCompileConfigurationsAvailable( ) ) { return false } if ( isRuntimeOrCompileConfigurationsAvailable( ) ) { return false } if ( isRuntimeOrCompileConfigurationsAvailable( ) ) { return false
public fun < R > Dataset . map ( transform : ( StringData ) -> R ) : List < R > /** * Applies the given [transform] function to each element of the dataset and returns a list with results. */ /** * Applies the given [transform] function to each element of the dataset and returns a list with results. */ /** * Applies the given [transform] function to each element of the dataset and returns a list with results. */ /** * Applies the given [transform] function to each element of the dataset and returns a list with results. */ /** * Applies the given [transform] function to each element of the dataset and returns a list with results. */ /** * Applies the given [transform] function to each element of the dataset and returns a list with results. */ /** * Applies the given [transform] function to each element of the dataset and returns a list with results. */ /** * Applies the given [transform] function to each element of the dataset and returns a list with results. */ /** * Applies the given [transform] function to each
{ if ( this.isEmpty() ) { return "" } var s = "" var i = 0 while ( i < this.size ) { s += this[i] i += 1 } return s } /** * Creates [OnHeapDataset] string representation for whole data. */ fun onHeapDataset . partialToString ( ) : String { if ( this.isEmpty() ) { return "" } var s = "" var i = 0 while ( i < this.size ) { s += this[i] i += 1 } return s } /** * Creates [OnHeapDataset] string representation for whole data. */ fun onHeapDataset . partialToString ( ) : String { if ( this.isEmpty() ) { return "" } var s = "" var i = 0 while ( i < this.size ) { s +=
{ var s = "" for ( var i = 0; i < this.size; i++ ) { s += this[i] + " " } return s } /** * Creates [OnHeapDataset] string representation for empty of data. */ fun onHeapDataset . emptyToString ( ) : String ict { var s = "" for ( var i = 0; i < this.size; i++ ) { s += this[i] + " " } return s } /** * Creates [OnHeapDataset] string representation for full of data. */ fun onHeapDataset . fullToString ( ) : String ict { var s = "" for ( var i = 0; i < this.size; i++ ) { s += this[i] + " " } return s } /** * Creates [OnHeapDataset] string representation for empty of data. */ fun onHeapDataset . empty
{ if ( xString == null || yString == null ) return "" if ( xString.isEmpty() || yString.isEmpty() ) return "" if ( xString.isBlank() || yString.isBlank() ) return "" if ( xString.isBlank() && yString.isBlank() ) return "" if ( xString.isBlank() && yString.isNotBlank() ) return "" if ( xString.isNotBlank() && yString.isBlank() ) return "" if ( xString.isNotBlank() && yString.isBlank() ) return "" if ( xString.isBlank() && yString.isNotBlank() ) return "" if ( xString.isNotBlank() && yString.isBlank() ) return "" if ( xString.isBlank() && yString.isNotBlank() ) return "" if ( xString.isNotBlank() && yString.isBlank() ) return "" if ( xString.isBlank() && yString


{ * * @param taskOutput debug level output of the task * * @param toolName compiler type * * @return list of dependencies in classpath */ public static List < String > extractNativeCompilerClasspath ( taskOutput : String , toolName : NativeToolKind ) : List < String > ik { * * @param taskOutput debug level output of the task * * @param toolName compiler type * * @return list of dependencies in classpath */ public static List < String > extractNativeCompilerClasspath ( taskOutput : String , toolName : NativeToolKind ) : List < String > ik { * * @param taskOutput debug level output of the task * * @param toolName compiler type * * @return list of dependencies in classpath */ public static List < String > extractNativeCompilerClasspath ( taskOutput : String , toolName : NativeToolKind ) : List < String > ik { * * @param taskOutput debug level output of the task * * @param toolName compiler type * * @return list of dependencies in classpath */
{ var args : List < String > = new ArrayList < String > (); if ( taskOutput == null ) { return args; } if ( toolName == null ) { return args; } if ( taskOutput.length() == 0 ) { return args; } if ( taskOutput.length() == 1 ) { return args; } if ( taskOutput.length() == 2 ) { return args; } if ( taskOutput.length() == 3 ) { return args; } if ( taskOutput.length() == 4 ) { return args; } if ( taskOutput.length() == 5 ) { return args; } if ( taskOutput.length() == 6 ) { return args; } if ( taskOutput.length() == 7 ) { return args; } if ( taskOutput.length() == 8 )
{ if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index >= this.size ) throw new IndexOutOfBoundsException () return this[ index ] } /** * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence. * * @sample samples.collections.Collections.Elements.elementAt */ /** * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence. * * @sample samples.collections.Collections.Elements.elementAt */ /** * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence. * * @sample samples.collections.Collections.Elements.elementAt */ /** * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the
( ) : java . util . SortedSet < Char > /** * Returns a new [SortedSet][java.util.SortedSet] of all characters. */ fun CharSequence . toSortedSet ( ) : java . util . SortedSet < Char > /** * Returns a new [SortedSet][java.util.SortedSet] of all characters. */ fun CharSequence . toSortedSet ( ) : java . util . SortedSet < Char > /** * Returns a new [SortedSet][java.util.SortedSet] of all characters. */ fun CharSequence . toSortedSet ( ) : java . util . SortedSet < Char > /** * Returns a new [SortedSet][java.util.SortedSet] of all characters. */ fun CharSequence . toSortedSet ( ) : java . util . SortedSet < Char > /** * Returns a new [SortedSet][java.util.SortedSet] of all characters. */ fun CharSequence . toSortedSet ( ) : java . util


Fun * * @param testExecutable The test executable to use. * * @return The test executable to use. */ public static TestExecutable setExecutionSourceFrom ( TestExecutable testExecutable ) { return testExecutable; } /** * Sets this test run to use the specified [testExecutable]. * * @param testExecutable The test executable to use. * * @return The test executable to use. */ public static Executable setExecutionSourceFrom ( TestExecutable testExecutable ) { return testExecutable; } /** * Sets this test run to use the specified [testExecutable]. * * @param testExecutable The test executable to use. * * @return The test executable to use. */ public static Executable setExecutionSourceFrom ( Executable testExecutable ) { return testExecutable; } /** * Sets this test run to use the specified [testExecutable]. * * @param testExecutable The test executable to use. * * @return The test executable to use.
fun { typedef struct { int height; int width; int channels; int classes; } MobileNetConfig; typedef struct { int height; int width; int channels; int classes; } MobileNetWeights; typedef struct { int height; int width; int channels; int classes; } MobileNetLabels; typedef struct { int height; int width; int channels; int classes; } MobileNetConfigLabels; typedef struct { int height; int width; int channels; int classes; } MobileNetWeightsLabels; typedef struct { int height; int width; int channels; int classes; } MobileNetConfigLabels; typedef struct { int height; int width; int channels; int classes; } MobileNetWeightsLabels; typed
( ) { var a = [1,2,3,4,5,6,7,8,9] var b = [1,2,3,4,5,6,7,8,9] var c = [1,2,3,4,5,6,7,8,9] var d = [1,2,3,4,5,6,7,8,9] var e = [1,2,3,4,5,6,7,8,9] var f = [1,2,3,4,5,6,7,8,9] var g = [1,2,3,4,5,6,7,8,9] var h = [1,2,3,4,5,6,7,8,9] var i = [1,2,3,4,5,6,7,8,9] var j = [1,2,3,4,5,6,7,8,9] var k = [1,2,3

private { @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked")



private { if ( currentClassSnapshot == null || previousClassSnapshot == null ) { throw new IllegalArgumentException( "The two classes must have the same [ClassId]." ) ; } if ( currentClassSnapshot.getClassId() != previousClassSnapshot.getClassId() ) { throw new IllegalArgumentException( "The two classes must have the same [ClassId]." ) ; } if ( changes == null ) { throw new IllegalArgumentException( "The changes must not be null." ) ; } if ( changes.isEmpty() ) { throw new IllegalArgumentException( "The changes must not be empty." ) ; } if ( changes.size() == 0 ) { throw new IllegalArgumentException( "The changes must not be empty." ) ; } if ( changes.size() == 1 ) { throw new IllegalArgumentException( "The changes must not be empty." ) ; } if ( changes.size() > 1 ) { throw new IllegalArgumentException( "The changes must not
private fun collectClassMemberChanges ( classId : ClassId , currentMemberSnapshots : List < JavaElementSnapshot > , previousMemberSnapshots : List < JavaElementSnapshot > , changes : ProgramSymbolSet . Collector ) : List < JavaElementSnapshot > { val newMemberSnapshots = currentMemberSnapshots.filter { it.classId == classId } val newPreviousMemberSnapshots = previousMemberSnapshots.filter { it.classId == classId } val newChanges = changes.filter { it.classId == classId } if (newMemberSnapshots.isEmpty() || newPreviousMemberSnapshots.isEmpty() || newChanges.isEmpty()) { return currentMemberSnapshots } if (newMemberSnapshots.size() != newPreviousMemberSnapshots.size()) { return currentMemberSnapshots } if (newMemberSnapshots.size() != newChanges.size()) { return currentMemberSnapshots } if (newMemberSnapshots[0].classId != newPreviousMemberSnapshots[0].classId) { return currentMember



fun * * @param resolveAsInput * @return */ public Constraint resolve ( resolveAsInput : Boolean = false ) : Constraint * * @param resolveAsInput * @return */ public Constraint resolve ( resolveAsInput : Boolean = false ) : Constraint * * @param resolveAsInput * @return */ public Constraint resolve ( resolveAsInput : Boolean = false ) : Constraint * * @param resolveAsInput * @return */ public Constraint resolve ( resolveAsInput : Boolean = false ) : Constraint * * @param resolveAsInput * @return */ public Constraint resolve ( resolveAsInput : Boolean = false ) : Constraint * * @param resolveAsInput * @return */ public Constraint resolve ( resolveAsInput : Boolean = false ) : Constraint * * @param resolveAsInput * @return */ public Constraint resolve ( resolveAsInput : Boolean = false ) : Constraint * * @param resolveAsInput * @return */ public
: OptionDescriptor < * , * > { if (descriptor == null) { return null; } if (descriptor == this) { return this; } if (descriptor == this.descriptor) { return this.descriptor; } if (descriptor == this.descriptor.descriptor) { return this.descriptor.descriptor; } if (descriptor == this.descriptor.descriptor.descriptor) { return this.descriptor.descriptor.descriptor; } if (descriptor == this.descriptor.descriptor.descriptor.descriptor) { return this.descriptor.descriptor.descriptor.descriptor; } if (descriptor == this.descriptor.descriptor.descriptor.descriptor.descriptor) { return this.descriptor.descriptor.descriptor.descriptor
( ) : * Allows the option to have several values specified in command line string. * Number of values is unlimited. */ public abstract class MultipleOption < T : Any , TResult , DefaultType : DefaultRequiredType > AbstractSingleOption < T , TResult , DefaultType > . multiple ( ) : * Allows the option to have several values specified in command line string. * Number of values is unlimited. */ public abstract class MultipleOption < T : Any , TResult , DefaultType : DefaultRequiredType > AbstractSingleOption < T , TResult , DefaultType > . multiple ( ) : * Allows the option to have several values specified in command line string. * Number of values is unlimited. */ public abstract class MultipleOption < T : Any , TResult , DefaultType : DefaultRequiredType > AbstractSingleOption < T , TResult , DefaultType > . multiple ( ) : * Allows the option to have several values specified in command line string. * Number of values is unlimited. */ public abstract class MultipleOption < T : Any , TResult , DefaultType : DefaultRequiredType > AbstractSingleOption < T , TResult , DefaultType > . multiple
( ) : * Allows the option to have several values specified in command line string. * Number of values is unlimited. * * @param < T : Any * @param < DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType : DefaultRequiredType > DefaultType :
fun < T : Any > SingleNullableOption < T > . default ( value : T ) : SingleOption < T , DefaultRequiredType . Default > */ public class SingleNullableOption < T , DefaultRequiredType , Default > : SingleOption < T , DefaultRequiredType , Default > { } /** * Specifies the default value for the option, that will be used when no value is provided for it * in command line string. * * @param value the default value. */ public class SingleNullableOption < T , DefaultRequiredType , Default > : SingleOption < T , DefaultRequiredType , Default > { } /** * Specifies the default value for the option, that will be used when no value is provided for it * in command line string. * * @param value the default value. */ public class SingleNullableOption < T , DefaultRequiredType , Default > : SingleOption < T , DefaultRequiredType , Default > { } /** * Specifies the default value for the option, that will be used when no value is provided for it * in command line string. * *

( ) : Option < T , DefaultRequiredType . Required > * * @param name The name of the option. * @param description The description of the option. * @param type The type of the option. * @param default The default value of the option. * @param required The required value of the option. * @param defaultType The type of the default value. * @param requiredType The type of the required value. * * @return The option. */ public static < T > Option<T> singleNullableOption(String name, String description, T type, T default, T defaultType, T required) { return new SingleNullableOption<T>(name, description, type, default, defaultType, required); } /** * @param name The name of the option. * @param description The description of the option. * @param type The type of the option. * @param default The default value of the option. * @param required The required value of the option. * @param defaultType The type of the default value. * @param requiredType The type of the required value.
MultipleOption < T , OptionType , DefaultRequiredType . None > . optional ( ) : * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


: JsName { if ( this == null ) { return null } if ( ident == this.declareName ) { return this.declareFreshName } if ( ident == this.declareFreshName ) { return this.declareName } return null } /** * Overrides JsFunctionScope declareFreshName as it's mapped to declareName */ jsprivate fun JsScope . findOwnNameOrDeclare ( ident : String ) : JsName { if ( this == null ) { return null } if ( ident == this.declareFreshName ) { return this.declareName } if ( ident == this.declareName ) { return this.declareFreshName } return null } /** * Overrides JsFunctionScope declareName as it's mapped to declareFreshName */ jsprivate fun JsScope . findOwnNameOrDeclare ( ident : String ) : JsName { if ( this == null ) {
override fun equals ( ) : Boolean } /** * We provide [equals], so as a matter of style, we should also provide [hashCode]. * However, the implementation from [AbstractSet] is enough. */ /** * We provide [equals], so as a matter of style, we should also provide [hashCode]. * However, the implementation from [AbstractSet] is enough. */ /** * We provide [equals], so as a matter of style, we should also provide [hashCode]. * However, the implementation from [AbstractSet] is enough. */ /** * We provide [equals], so as a matter of style, we should also provide [hashCode]. * However, the implementation from [AbstractSet] is enough. */ /** * We provide [equals], so as a matter of style, we should also provide [hashCode]. * However, the implementation from [AbstractSet] is enough. */ /** * We provide [equals], so as a matter of style, we should also provide [hashCode]. * However, the implementation from [Abstract

: Unit = println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println
: Unit = println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println
: Unit = println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println
: Unit = println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println
: Unit = println( message ) /** Prints the given [message] to the standard output stream. */ public inline fun print ( message : String ) : Unit = println( message ) /** Prints the given [message] to the standard output stream. */ public inline fun print ( message : String ) : Unit = println( message ) /** Prints the given [message] to the standard output stream. */ public inline fun print ( message : String ) : Unit = println( message ) /** Prints the given [message] to the standard output stream. */ public inline fun print ( message : String ) : Unit = println( message ) /** Prints the given [message] to the standard output stream. */ public inline fun print ( message : String ) : Unit = println( message ) /** Prints the given [message] to the standard output stream. */ public inline fun print ( message : String ) : Unit = println( message ) /** Prints the given [message] to the standard output stream. */ public inline fun print ( message : String ) : Unit = println( message ) /** Print
: Unit = println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println
: Unit = println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println
: Unit = println( message ) /** Prints the given [message] to the standard error stream. */ kotlin . internal . InlineOnly /** Prints the given [message] to the standard output stream. */ kotlin . internal . InlineOnly /** Prints the given [message] to the standard error stream. */ kotlin . internal . InlineOnly /** Prints the given [message] to the standard output stream. */ kotlin . internal . InlineOnly /** Prints the given [message] to the standard error stream. */ kotlin . internal . InlineOnly /** Prints the given [message] to the standard output stream. */ kotlin . internal . InlineOnly /** Prints the given [message] to the standard error stream. */ kotlin . internal . InlineOnly /** Prints the given [message] to the standard output stream. */ kotlin . internal . InlineOnly /** Prints the given [message] to the standard error stream. */ kotlin . internal . InlineOnly /** Prints the given [message] to the standard output stream
: Unit = println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println( message ) /** Prints the given [message] to the standard output stream. */ println
( message : CharArray ) : Unit = println( message.joinToString( " " ) ) /** Prints the given [message] to the standard output stream. */ public inline fun print( message : CharArray ) : Unit = println( message.joinToString( " " ) ) /** Prints the given [message] to the standard output stream. */ public inline fun print( message : CharArray ) : Unit = println( message.joinToString( " " ) ) /** Prints the given [message] to the standard output stream. */ public inline fun print( message : CharArray ) : Unit = println( message.joinToString( " " ) ) /** Prints the given [message] to the standard output stream. */ public inline fun print( message : CharArray ) : Unit = println( message.joinToString( " " ) ) /** Prints the given [message] to the standard output stream. */ public inline fun print( message : CharArray ) : Unit = println( message.joinToString( " " ) ) /** Prints the given [message] to the standard output stream
( lineSeparator : Any ? ) = println ( message , lineSeparator ) A: You can do it like this: fun main(args: Array<String>) { println("Hello World!") } Output: Hello World
( lineSeparator : String = " " ) : Unit = println( message, lineSeparator ) A: You can do it like this: fun main(args: Array<String>) { println("Hello World!") } Output: Hello World
( lineSeparator : String = " " ) : Unit = println ( message , lineSeparator ) A: If you want to print to the console, you can use System.out.println(...) If you want to write to a file, you can use System.out.println(...) and System.out.write(...) A: If you want to print to the console, you can use System.out.println(...) If you want to write to a file, you can use System.out.println(...) and System.out.write(...) A: If you want to print to the console, you can use System.out.println(...) If you want to write to a file, you can use System.out.println(...) and System.out.write(...) A: If you want to print to the console, you can use System.out.println(...) If you want to write to a file, you can use System.out.println(...) and System.out.write(...) A: If you want to print to the console, you can use System.out
( lineSeparator : Byte ) : Unit = println ( message , lineSeparator ) } } A: You can do it like this: fun main(args: Array<String>) { println("Hello World!") } Output: Hello World
( lineSeparator : String = " " ) : Unit = println ( message , lineSeparator ) A: You can do it like this: fun main(args: Array<String>) { println("Hello World!") } Output: Hello World
( lineSeparator : Char = '\n' ) : Unit = println ( message , lineSeparator ) A: You can use this: fun main(args: Array<String>) { println("Hello, World!") } Output: Hello, World
( lineSeparator : String = " " ) : Unit = println ( message ) + lineSeparator /** Prints the given [message] and the line separator to the standard output stream. */ kotlin . internal . InlineOnly /** Prints the given [message] and the line separator to the standard output stream. */ kotlin . internal . InlineOnly /** Prints the given [message] and the line separator to the standard output stream. */ kotlin . internal . InlineOnly /** Prints the given [message] and the line separator to the standard output stream. */ kotlin . internal . InlineOnly /** Prints the given [message] and the line separator to the standard output stream. */ kotlin . internal . InlineOnly /** Prints the given [message] and the line separator to the standard output stream. */ kotlin . internal . InlineOnly /** Prints the given [message] and the line separator to the standard output stream. */ kotlin . internal . InlineOnly /** Prints the given [
( lineSeparator : String = " " ) : Unit = println( message, lineSeparator ) /** Prints the given [message] and the line separator to the standard output stream. */ println( message, lineSeparator ) /** Prints the given [message] and the line separator to the standard output stream. */ println( message, lineSeparator ) /** Prints the given [message] and the line separator to the standard output stream. */ println( message, lineSeparator ) /** Prints the given [message] and the line separator to the standard output stream. */ println( message, lineSeparator ) /** Prints the given [message] and the line separator to the standard output stream. */ println( message, lineSeparator ) /** Prints the given [message] and the line separator to the standard output stream. */ println( message, lineSeparator ) /** Prints the given [message] and the line separator to the standard output stream. */ println( message, lineSeparator ) /** Prints the given [message] and the line separator to
( lineSeparator : String = " " ) : Unit = System.out.println( message + lineSeparator ) A: You can use the following code: fun main(args: Array<String>) { println("Hello World!") } Output: Hello World
( lineSeparator : CharArray ) : Unit = println ( message , lineSeparator ) A: You can use this: fun main(args: Array<String>) { println("Hello, World!") } Output: Hello, World
( ) : Unit = System.out.println(this) } } A: You can do it like this: fun main(args: Array<String>) { println("Hello World!") } Output: Hello World




etected : List<Landmark> = ArrayList<Landmark>() /** * Detects [Landmark] objects on the given [imageProxy]. */ private fun detectLandmarks ( imageProxy : ImageProxy ) : List<Landmark> = ArrayList<Landmark>() /** * Detects [Landmark] objects on the given [imageProxy]. */ private fun detectLandmarks ( imageProxy : ImageProxy ) : List<Landmark> = ArrayList<Landmark>() /** * Detects [Landmark] objects on the given [imageProxy]. */ private fun detectLandmarks ( imageProxy : ImageProxy ) : List<Landmark> = ArrayList<Landmark>() /** * Detects [Landmark] objects on the given [imageProxy]. */ private fun detectLandmarks ( imageProxy : ImageProxy ) : List<Landmark> = ArrayList<Landmark>() /** * Detects [Landmark] objects on the given [imageProxy]. */ private fun detectLandmarks ( imageProxy : ImageProxy

{ if ( this.isEmpty() ) { return "" } if ( this.size() == 1 ) { return this[0] } if ( this.size() == 2 ) { return this[0] + " " + this[1] } if ( this.size() == 3 ) { return this[0] + " " + this[1] + " " + this[2] } if ( this.size() == 4 ) { return this[0] + " " + this[1] + " " + this[2] + " " + this[3] } if ( this.size() == 5 ) { return this[0] + " " + this[1] + " " + this[2] + " " + this[3] + " " + this[4] } if ( this.size() == 6 ) { return this[0] + " " + this[1] + " " + this[2] + " " + this[3] + " " +

klib ( ) { return new Iterable < CompiledDependency < KLIB > > ( new CompiledDependency < KLIB > (), new CompiledDependency < KLIB > (), new CompiledDependency < KLIB > (), new CompiledDependency < KLIB > (), new CompiledDependency < KLIB > (), new CompiledDependency < KLIB > (), new CompiledDependency < KLIB > (), new CompiledDependency < KLIB > (), new CompiledDependency < KLIB > (), new CompiledDependency < KLIB > (), new CompiledDependency < KLIB > (), new CompiledDependency < KLIB > (), new CompiledDependency < KLIB > (), new CompiledDependency < KLIB > (), new CompiledDependency < KLIB > (), new CompiledDependency < KLIB > (), new CompiledDependency < KLIB > (), new CompiledDependency < K
( klib : CompiledDependency < KLIB > , useHeaders : Boolean ) : Iterable < CompiledDependency < * > > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > * > *
p { return new Iterable < CompiledDependency < * > > ( new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDependency < * > (), new CompiledDepend
: Iterable < CompiledDependency < * > > ( CompiledDependency < * > * , CompiledDependency < * > * , CompiledDependency < * > * , CompiledDependency < * > * , CompiledDependency < * > * , CompiledDependency < * > * , CompiledDependency < * > * , CompiledDependency < * > * , CompiledDependency < * > * , CompiledDependency < * > * , CompiledDependency < * > * , CompiledDependency < * > * , CompiledDependency < * > * , CompiledDependency < * > * , CompiledDependency < * > * , CompiledDependency < * > * , CompiledDependency < * > * , CompiledDependency < * > * , Compiled
public fun apply ( input : I ) : O { if ( input == null ) { return null; } if ( input.isBlank() ) { return null; } if ( input.isEmpty() ) { return null; } return input; } /** * Performs postprocessing operation on the input. * @param [input] is an input to the operation of type [O]. * @return an output of the operation of type [I]. */ private fun apply ( input : O ) : I { if ( input == null ) { return null; } if ( input.isBlank() ) { return null; } if ( input.isEmpty() ) { return null; } return input; } /** * Performs preprocessing operation on the input. * @param [input] is an input to the operation of type [I]. * @return an output of the operation of type [O]. */ private fun apply ( input : I ) : O
{ return inputShape } /** * Returns the input's shape of the operation having output of shape [outputShape]. * @param [outputShape] is a shape of the output. */ fun getInputShape ( outputShape : TensorShape ) : TensorShape { return outputShape } /** * Returns the output's shape of the operation having input of shape [inputShape] and output of shape [outputShape]. * @param [inputShape] is a shape of the input. * @param [outputShape] is a shape of the output. */ fun getOutputShape ( inputShape : TensorShape, outputShape : TensorShape ) : TensorShape { return inputShape + outputShape } /** * Returns the input's shape of the operation having output of shape [outputShape] and input of shape [inputShape]. * @param [outputShape] is a shape of the output. * @param [inputShape] is a shape of the input. */ fun getInputShape ( outputShape : TensorShape, inputShape : TensorShape ) : TensorShape { return
Public: List<KoverProject> = ArrayList<KoverProject>() /** * Include to the merged report all subprojects of the current project. * * Kover plugin will be automatically applied in all subprojects. */ koverpublic fun subprojects ( ) koverPublic: List<KoverProject> = ArrayList<KoverProject>() /** * Include to the merged report all subprojects of the current project. * * Kover plugin will be automatically applied in all subprojects. */ koverpublic fun subprojects ( ) koverPublic: List<KoverProject> = ArrayList<KoverProject>() /** * Include to the merged report all subprojects of the current project. * * Kover plugin will be automatically applied in all subprojects. */ koverpublic fun subprojects ( ) koverPublic: List<KoverProject> = ArrayList<KoverProject>() /** * Include to the merged report all subprojects of the current project. * * Kover plugin will be automatically applied in all subprojects. */ koverpublic fun subprojects ( ) koverPublic: List

Public { return this.build.allProjects() } /** * Include to the merged report all projects of the build. * * Kover plugin will be automatically applied in all projects. */ koverpublic fun allProjects ( ) koverpublic { return this.build.allProjects() } /** * Include to the merged report all projects of the build. * * Kover plugin will be automatically applied in all projects. */ koverpublic fun allProjects ( ) koverpublic { return this.build.allProjects() } /** * Include to the merged report all projects of the build. * * Kover plugin will be automatically applied in all projects. */ koverpublic fun allProjects ( ) koverpublic { return this.build.allProjects() } /** * Include to the merged report all projects of the build. * * Kover plugin will be automatically applied in all projects. */ koverpublic fun allProjects ( ) koverpublic { return this.build.allProjects() } /** *

Projects( projectNameOrPath: String ) = projectNameOrPath.replace( ":", "/" ) .replace( "\\", "/" ) .replace( "\"", "/" ) .replace( "//", "/" ) .replace( "\\\\", "/" ) .replace( "/", "/" ) .replace( "\\", "/" ) .replace( "/", "/" ) .replace( "\\", "/" ) .replace( "\"", "/" ) .replace( "//", "/" ) .replace( "\\\\", "/" ) .replace( "/", "/" ) .replace( "\\", "/" ) .replace( "\"", "/" ) .replace( "//", "/" ) .replace( "\\\\", "/" ) .replace( "/", "/" ) .replace( "\\", "/" ) .replace( "\"", "/" ) .replace( "//", "/" ) .replace( "\\\\", "/" )



private inline fun FirFile . forEachElement ( crossinline saveDeclaration : ( element : FirElement , owners : List < FirBasedSymbol < * > > ) -> Unit ) -> Unit { for ( element in this ) { saveDeclaration( element , owners ) } } /** * Walks over every [FirClass] in [this] file and invokes [saveDeclaration] on it, passing each element and the list of its containing * declarations (like file, classes, functions/properties and so on). */ /** * Walks over every [FirClass] in [this] file and invokes [saveDeclaration] on it, passing each element and the list of its containing * declarations (like file, classes, functions/properties and so on). */ /** * Walks over every [FirFunction] in [this] file and invokes [saveDeclaration] on it, passing each element and the list of its containing * declarations (like file, classes, functions/properties and so on). */ /** * Walks over every [FirFunction] in [this] file and invokes [
private inline fun FirDeclaration . forEachDirectChildDeclaration ( crossinline action : ( child : FirDeclaration ) -> Unit ) /** * Calls [action] on every direct child declaration of [this] declaration. */ /** * Calls [action] on every direct child declaration of [this] declaration. */ /** * Calls [action] on every direct child declaration of [this] declaration. */ /** * Calls [action] on every direct child declaration of [this] declaration. */ /** * Calls [action] on every direct child declaration of [this] declaration. */ /** * Calls [action] on every direct child declaration of [this] declaration. */ /** * Calls [action] on every direct child declaration of [this] declaration. */ /** * Calls [action] on every direct child declaration of [this] declaration. */ /** * Calls [action] on every direct child declaration of [this] declaration. */ /** * Calls [action] on every direct child declaration of [this] declaration. */ /** * Calls [action] on every direct child declaration of [thi

{ Set < String > packageSet = new HashSet < String > (); packageSet.add( "java.util.Arrays" ); packageSet.add( "java.util.Collections" ); packageSet.add( "java.util.Date" ); packageSet.add( "java.util.List" ); packageSet.add( "java.util.Map" ); packageSet.add( "java.util.Set" ); packageSet.add( "java.util.Scanner" ); packageSet.add( "java.util.StringTokenizer" ); packageSet.add( "java.util.TreeMap" ); packageSet.add( "java.util.TreeSet" ); packageSet.add( "java.util.concurrent.atomic.AtomicInteger" ); packageSet.add( "java.util.concurrent.atomic.AtomicLong" ); packageSet.add( "java.util.concurrent.atomic.AtomicBoolean" ); packageSet.add( "java.util.concurrent
* * @return `true` if [getAllOptionalAnnotationClasses] may return a non-empty list. */ public boolean mayHaveOptionalAnnotationClasses ( ) : Boolean * * @return `true` if [getAllOptionalAnnotationClasses] may return a non-empty list. */ public boolean mayHaveOptionalAnnotationClasses ( ) : Boolean * * @return `true` if [getAllOptionalAnnotationClasses] may return a non-empty list. */ public boolean mayHaveOptionalAnnotationClasses ( ) : Boolean * * @return `true` if [getAllOptionalAnnotationClasses] may return a non-empty list. */ public boolean mayHaveOptionalAnnotationClasses ( ) : Boolean * * @return `true` if [getAllOptionalAnnotationClasses] may return a non-empty list. */ public boolean mayHaveOptionalAnnotationClasses ( ) : Boolean * * @return `true` if [getAllOptionalAnnotationClasses] may return a non-empty list. */ public boolean mayHaveOptionalAnnotationClasses ( )
{ var libsInDistribution : ArrayList<String> = ArrayList<String>() var libsNotInDistribution : ArrayList<String> = ArrayList<String>() var libsNotFoundInDistribution : ArrayList<String> = ArrayList<String>() var libsFoundInDistribution : ArrayList<String> = ArrayList<String>() var libsNotFoundInPlatform : ArrayList<String> = ArrayList<String>() var libsNotFoundOnPlatform : ArrayList<String> = ArrayList<String>() var libsFoundOnPlatform : ArrayList<String> = ArrayList<String>() var libsNotFoundOnDistribution : ArrayList<String> = ArrayList<String>() var libsFoundOnDistribution : ArrayList<String> = ArrayList<String>() var libsNotFoundOnPlatform : ArrayList<String> = ArrayList<String>() var libsFoundOnPlatform : ArrayList<String> = ArrayList<String>() var libsNotFoundOnDistribution : ArrayList
: Boolean { try { return true } catch ( Exception e ) { e.printStackTrace() return false } } /** * Check that caches for all platform libs for [konanPlatform] actually exist in the cache directory. */ konanprivate fun checkCaches ( ) : Boolean aft : Boolean { try { return true } catch ( Exception e ) { e.printStackTrace() return false } } /** * Check that caches for all platform libs for [konanTargetPlatform] actually exist in the cache directory. */ konanprivate fun checkCaches ( ) : Boolean aft : Boolean { try { return true } catch ( Exception e ) { e.printStackTrace() return false } } /** * Check that caches for all platform libs for [konanPlatformPlatform] actually exist in the cache directory. */ konanprivate fun checkCaches ( ) : Boolean aft : Boolean { try { return true }
* * @param path * @return */ public static Boolean isGenerated ( path : File ) : Boolean { if ( path.isDirectory ( ) ) { for ( File f : path.listFiles ( ) ) { if ( f.isDirectory ( ) ) { isGenerated ( f ) ; } else { return false ; } } } else { return false ; } return true ; } /** * Are platform libraries in the given directory (e.g. <dist>/klib/platform/ios_x86_64) generated. */ public static Boolean isGenerated ( path : File ) : Boolean { if ( path.isDirectory ( ) ) { for ( File f : path.listFiles ( ) ) { if ( f.isDirectory ( ) ) { isGenerated ( f ) ; } else { return false ; } }
Generated ( path : File ) { if ( !exists ( path ) ) { mkdir ( path ); } if ( !exists ( path + "/generated" ) ) { mkdir ( path + "/generated" ); } if ( !exists ( path + "/generated/generated" ) ) { mkdir ( path + "/generated/generated/generated" ); } if ( !exists ( path + "/generated/generated/generated/generated/generated" ) ) { mkdir ( path + "/generated/generated/generated/generated/generated/generated" ); } if ( !exists ( path + "/generated/generated/generated/generated/generated/generated/generated" ) ) { mkdir ( path + "/generated/generated/generated/generated/generated/generated/generated" ); } if ( !exists ( path + "/generated/generated/generated/generated/generated/generated/generated/generated" ) ) { mkdir ( path + "/generated/generated/generated/generated
{ if ( kind == NativeCacheKind.CACHE ) { if ( path.exists() ) { return true; } } return false; } /** * Are platform libraries in the given directory (e.g. <dist>/klib/platform/ios_x86_64) cached with the given cache kind. */ isCached ( path : File , kind : NativeCacheKind ) : Boolean /** * Are platform libraries in the given directory (e.g. <dist>/klib/platform/x86_64) cached with the given cache kind. */ isCached ( path : File , kind : NativeCacheKind ) : Boolean /** * Are platform libraries in the given directory (e.g. <dist>/klib/platform/x86_64) cached with the given cache kind. */ isCached ( path : File , kind : NativeCacheKind ) : Boolean /** * Are platform libraries in the given directory (e.g. <dist>/klib/platform/x86_64) cached with the given cache kind. */ i
: NativeCache ( path , kind ) {} /** * Register that platform libraries in the given directory are cached with the given cache kind. */ nativefun setCached ( path : File , kind : NativeCacheKind ) native : NativeCache ( path , kind ) {} /** * Register that platform libraries in the given directory are cached with the given cache kind. */ nativefun setCached ( path : File , kind : NativeCacheKind ) native : NativeCache ( path , kind ) {} /** * Register that platform libraries in the given directory are cached with the given cache kind. */ nativefun setCached ( path : File , kind : NativeCacheKind ) native : NativeCache ( path , kind ) {} /** * Register that platform libraries in the given directory are cached with the given cache kind. */ nativefun setCached ( path : File , kind : NativeCacheKind ) native : NativeCache ( path , kind ) {} /** * Register that platform libraries in the given directory are cached with the given cache kind. */ nativefun setCached ( path : File , kind : NativeCacheKind ) native : NativeCache ( path , kind ) {}
Project . mavenBuildProperties ( configure : MavenBuildProperties . ( ) -> Unit ) . mavenBuildProperties ( configure : MavenBuildProperties . ( ) -> Unit ) . mavenBuildProperties ( configure : MavenBuildProperties . ( ) -> Unit ) . mavenBuildProperties ( configure : MavenBuildProperties . ( ) -> Unit ) . mavenBuildProperties ( configure : MavenBuildProperties . ( ) -> Unit ) . mavenBuildProperties ( configure : MavenBuildProperties . ( ) -> Unit ) . mavenBuildProperties ( configure : MavenBuildProperties . ( ) -> Unit ) . mavenBuildProperties ( configure : MavenBuildProperties . ( ) -> Unit ) . mavenBuildProperties ( configure : MavenBuildProperties . ( ) -> Unit ) . mavenBuildProperties ( configure : MavenBuildProperties . ( ) -> Unit ) . mavenBuildProperties ( configure : MavenBuildProperties . ( ) -> Unit ) . mavenBuildProperties ( configure : MavenBuildProperties . ( ) -> Unit ) . mavenBuildProperties ( configure : MavenBuildProperties .
@ Suppress ( " kover" ) * * @param description : Description of the artifact. * * @param koverVersion : Version of Kover. * * @param snapshotRepos : List of snapshot repositories. * * @param overrideKotlinVersion : Override Kotlin version. * * @return */ private fun patchSettingsFile ( description : String , koverVersion : String , snapshotRepos : List < String > , overrideKotlinVersion : String ? * * @return */ private fun patchSettingsFile ( description : String , koverVersion : String , snapshotRepos : List < String > , overrideKotlinVersion : String ? * * @return */ private fun patchSettingsFile ( description : String , koverVersion : String , snapshotRepos : List < String > , overrideKotlinVersion : String ? * * @return */ private fun patchSettingsFile ( description : String , koverVersion : String , snapshotRepos : List < String > , overrideKotlinVersion : String
Internal { if ( koverVersion == "1.0.0" ) { return } if ( koverVersion == "1.1.0" ) { return } if ( koverVersion == "1.2.0" ) { return } if ( koverVersion == "1.3.0" ) { return } if ( koverVersion == "1.4.0" ) { return } if ( koverVersion == "1.5.0" ) { return } if ( koverVersion == "1.6.0" ) { return } if ( koverVersion == "1.7.0" ) { return } if ( koverVersion == "1.8.0" ) { return } if ( koverVersion == "1.9.0" ) { return } if ( koverVersion == "2.0.0" ) { return }
( ) = let rec loop (s : String) = match s with | "" -> s | x :: xs -> loop (x :: s) xs in loop (String.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSeq (Array.ofSe

/** * Prints the [detailed description][Throwable.stackTraceToString] of this throwable to the standard output or standard error output. */ throwable.printStackTrace ( ) : Unit /** * Prints the [detailed description][Throwable.stackTraceToString] of this throwable to the standard output or standard error output. */ throwable.toString ( ) : Unit /** * Prints the [detailed description][Throwable.stackTraceToString] of this throwable to the standard output or standard error output. */ throwable.toString ( ) : Unit /** * Prints the [detailed description][Throwable.stackTraceToString] of this throwable to the standard output or standard error output. */ throwable.toString ( ) : Unit /** * Prints the [detailed description][Throwable.stackTraceToString] of this throwable to the standard output or standard error output. */ throwable.toString ( ) : Unit /** * Prints the [detailed description][Throwable.stackTr
/** * When supported by the platform, adds the specified exception to the list of exceptions that were * suppressed in order to deliver this exception. * * @param exception The exception to add to the list of suppressed exceptions. */ public addSuppressed ( exception exception ) /** * When supported by the platform, adds the specified exception to the list of exceptions that were * suppressed in order to deliver this exception. * * @param exception The exception to add to the list of suppressed exceptions. */ public addSuppressed ( exception exception ) /** * When supported by the platform, adds the specified exception to the list of exceptions that were * suppressed in order to deliver this exception. * * @param exception The exception to add to the list of suppressed exceptions. */ public addSuppressed ( exception exception ) /** * When supported by the platform, adds the specified exception to the list of exceptions that were * suppressed in order to deliver this exception. * * @param exception The exception to add to the list of suppressed exceptions. */ public addSuppressed ( exception exception ) /** * When supported by the platform, add














public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull ( ) : Nothing public fun decodeNull
: Boolean { return this } /** * Decodes an integer value. * Corresponding kind is [PrimitiveKind.INTEGER]. */ /** * Decodes an integer value. * Corresponding kind is [PrimitiveKind.INTEGER]. */ /** * Decodes an integer value. * Corresponding kind is [PrimitiveKind.INTEGER]. */ /** * Decodes an integer value. * Corresponding kind is [PrimitiveKind.INTEGER]. */ /** * Decodes an integer value. * Corresponding kind is [PrimitiveKind.INTEGER]. */ /** * Decodes an integer value. * Corresponding kind is [PrimitiveKind.INTEGER]. */ /** * Decodes an integer value. * Corresponding kind is [PrimitiveKind.INTEGER]. */ /** * Decodes an integer value. * Corresponding kind is [PrimitiveKind.INTEGER]. */ /** * Decodes an integer value. * Corresponding kind is [PrimitiveKind.INTEGER]. */ /**
public fun decodeByte ( ) : Byte/** * Decodes a single byte value. * Corresponding kind is [PrimitiveKind.BYTE]. */ /** * Decodes a single byte value. * Corresponding kind is [PrimitiveKind.BYTE]. */ /** * Decodes a single byte value. * Corresponding kind is [PrimitiveKind.BYTE]. */ /** * Decodes a single byte value. * Corresponding kind is [PrimitiveKind.BYTE]. */ /** * Decodes a single byte value. * Corresponding kind is [PrimitiveKind.BYTE]. */ /** * Decodes a single byte value. * Corresponding kind is [PrimitiveKind.BYTE]. */ /** * Decodes a single byte value. * Corresponding kind is [PrimitiveKind.BYTE]. */ /** * Decodes a single byte value. * Corresponding kind is [PrimitiveKind.BYTE]. */ /** * Decodes a single byte value. * Corresponding kind is [PrimitiveKind.BYTE]. */ /** * Decode
{ if ( this.kind == PrimitiveKind.SHORT ) { return this.value } else if ( this.kind == PrimitiveKind.UINT16 ) { return this.value } else if ( this.kind == PrimitiveKind.UINT32 ) { return this.value } else if ( this.kind == PrimitiveKind.UINT64 ) { return this.value } else if ( this.kind == PrimitiveKind.INT16 ) { return this.value } else if ( this.kind == PrimitiveKind.INT32 ) { return this.value } else if ( this.kind == PrimitiveKind.INT64 ) { return this.value } else if ( this.kind == PrimitiveKind.FLOAT32 ) { return this.value } else if ( this.kind == PrimitiveKind.FLOAT64 ) { return this.value } else if ( this.kind == PrimitiveKind.DOUBLE ) { return this.value } else if ( this.kind
{ if ( this.kind == PrimitiveKind.CHAR ) { return this.value } else if ( this.kind == PrimitiveKind.BYTE ) { return this.value & 0xFF } else if ( this.kind == PrimitiveKind.WORD ) { return this.value & 0xFF00 } else if ( this.kind == PrimitiveKind.DWORD ) { return this.value & 0xFF0000 } else if ( this.kind == PrimitiveKind.QWORD ) { return this.value & 0xFF00FF } else if ( this.kind == PrimitiveKind.QDWORD ) { return this.value & 0xFF0000FF } else if ( this.kind == PrimitiveKind.QCHAR ) { return this.value & 0xFF } else if ( this.kind == PrimitiveKind.QWORD ) { return this.value & 0xFF00 } else if ( this.kind == PrimitiveKind.QDWORD ) { return this.value & 0x
public { return this } /** * Decodes a 32-bit floating point value. * Corresponding kind is [PrimitiveKind.FLOAT]. */ /** * Decodes a 32-bit floating point value. * Corresponding kind is [PrimitiveKind.FLOAT]. */ /** * Decodes a 32-bit floating point value. * Corresponding kind is [PrimitiveKind.FLOAT]. */ /** * Decodes a 32-bit floating point value. * Corresponding kind is [PrimitiveKind.FLOAT]. */ /** * Decodes a 32-bit floating point value. * Corresponding kind is [PrimitiveKind.FLOAT]. */ /** * Decodes a 32-bit floating point value. * Corresponding kind is [PrimitiveKind.FLOAT]. */ /** * Decodes a 32-bit floating point value. * Corresponding kind is [PrimitiveKind.FLOAT]. */ /** * Decodes a 32-bit floating point value. * Corresponding kind is [PrimitiveKind.FLOAT].
{ return Long.parseLong( this ) } /** * Decodes a 32-bit integer value. * Corresponding kind is [PrimitiveKind.BYTE]. */ byteprivate fun decodeByte ( ) : Byte return Byte.parseByte( this ) } /** * Decodes a 16-bit integer value. * Corresponding kind is [PrimitiveKind.SHORT]. */ shortprivate fun decodeShort ( ) : Short return Short.parseShort( this ) } /** * Decodes a 8-bit integer value. * Corresponding kind is [PrimitiveKind.UINT]. */ uintprivate fun decodeUint ( ) : UInt return UInt.parseUint( this ) } /** * Decodes a 4-bit integer value. * Corresponding kind is [PrimitiveKind.INT]. */ intprivate fun decodeInt ( ) : Int return Int.parseInt( this ) } /** * Decodes a 2-bit integer value. * Corresponding kind is [PrimitiveKind.LONG]. */ longprivate
{ return Float.parseFloat( this ) } /** * Decodes a 32-bit IEEE 754 double value. * Corresponding kind is [PrimitiveKind.DOUBLE]. */ doublepublic fun decodeDouble ( ) : Double { return Double.parseDouble( this ) } /** * Decodes a 32-bit IEEE 754 long value. * Corresponding kind is [PrimitiveKind.LONG]. */ longpublic fun decodeLong ( ) : Long { return Long.parseLong( this ) } /** * Decodes a 32-bit IEEE 754 short value. * Corresponding kind is [PrimitiveKind.SHORT]. */ shortpublic fun decodeShort ( ) : Short { return Short.parseShort( this ) } /** * Decodes a 32-bit IEEE 754 byte value. * Corresponding kind is [PrimitiveKind.BYTE]. */ bytepublic fun decodeByte ( ) : Byte { return Byte.parseByte( this ) } /** * Decodes a 32-bit IEEE 754
: Double { return Double.parseDouble( this ) } /** * Decodes a 32-bit IEEE 754 floating point value. * Corresponding kind is [PrimitiveKind.FLOAT]. */ floatpublic fun decodeFloat ( ) : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float : Float
{ if ( this.isNullOrEmpty() ) { return "" } else if ( this.isBlank() ) { return "" } else if ( this.isBlankOrWhitespace() ) { return "" } else if ( this.isBlankOrWhitespaceOrNull() ) { return "" } else if ( this.isBlankOrWhitespaceOrWhitespaceOrNull() ) { return "" } else if ( this.isBlankOrWhitespaceOrWhitespaceOrWhitespaceOrNull() ) { return "" } else if ( this.isBlankOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhite





EndStructure ( descriptor : SerialDescriptor ) : Boolean = false /** * Denotes the end of the structure associated with current decoder. * For example, composite decoder of JSON format will expect (and parse) * a closing bracket in the underlying input. */ fun endStructure ( descriptor : SerialDescriptor ) : Boolean = false /** * Denotes the end of the structure associated with current decoder. * For example, composite decoder of JSON format will expect (and parse) * a closing bracket in the underlying input. */ fun endStructure ( descriptor : SerialDescriptor ) : Boolean = false /** * Denotes the end of the structure associated with current decoder. * For example, composite decoder of JSON format will expect (and parse) * a closing bracket in the underlying input. */ fun endStructure ( descriptor : SerialDescriptor ) : Boolean = false /** * Denotes the end of the structure associated with current decoder. * For example, composite decoder of JSON format will expect (and parse) * a closing bracket in the underlying input. */ fun



: Boolean { if (descriptor.kind == PrimitiveKind.BOOLEAN) { if (descriptor.index == index) { return true } else { return false } } else if (descriptor.kind == PrimitiveKind.INTEGER) { if (descriptor.index == index) { return true } else { return false } } else if (descriptor.kind == PrimitiveKind.UINTEGER) { if (descriptor.index == index) { return true } else { return false } } else if (descriptor.kind == PrimitiveKind.FLOAT) { if (descriptor.index == index) { return true } else { return false } } else if (descriptor.kind == PrimitiveKind.DOUBLE) { if (descriptor.index == index) { return true } else { return false } }
public fun decodeByteElement ( descriptor : SerialDescriptor , index : Int ) : Byte { if (descriptor.kind == PrimitiveKind.BYTE) { if (index < 0 || index >= descriptor.length) { throw new IllegalArgumentException("Invalid index: " + index) } return (Byte)descriptor[index] } throw new IllegalArgumentException("Invalid kind: " + descriptor.kind) } /** * Decodes a single short value from the underlying input. * The resulting value is associated with the [descriptor] element at the given [index]. * The element at the given index should have [PrimitiveKind.SHORT] kind. */ budpublic fun decodeShortElement ( descriptor : SerialDescriptor , index : Int ) : Short { if (descriptor.kind == PrimitiveKind.SHORT) { if (index < 0 || index >= descriptor.length) { throw new IllegalArgumentException("Invalid index: " + index) } return (Short
: Char { if (descriptor.kind == PrimitiveKind.CHAR) { if (descriptor.index == index) { return descriptor.value } } throw RuntimeException(descriptor.kind) } /** * Decodes a 32-bit unicode character value from the underlying input. * The resulting value is associated with the [descriptor] element at the given [index]. * The element at the given index should have [PrimitiveKind.CHAR] kind. */ /** * Decodes a 32-bit unicode character value from the underlying input. * The resulting value is associated with the [descriptor] element at the given [index]. * The element at the given index should have [PrimitiveKind.CHAR] kind. */ /** * Decodes a 32-bit unicode character value from the underlying input. * The resulting value is associated with the [descriptor] element at the given [index]. * The element at the given index should have [PrimitiveKind.CHAR] kind. */ /** * Decodes a 32-bit unicode character
: Short { if (descriptor.kind != PrimitiveKind.SHORT ) throw IllegalArgumentException( "descriptor.kind must be PrimitiveKind.SHORT" ) if (index < 0 ) throw IllegalArgumentException( "index must be non-negative" ) if (index >= descriptor.size ) throw IllegalArgumentException( "index must be less than or equal to descriptor.size" ) if (descriptor.size == 0 ) throw IllegalArgumentException( "descriptor.size cannot be zero" ) if (descriptor.size == 1 ) throw IllegalArgumentException( "descriptor.size cannot be one" ) if (descriptor.size == 2 ) throw IllegalArgumentException( "descriptor.size cannot be two" ) if (descriptor.size == 3 ) throw IllegalArgumentException( "descriptor.size cannot be three" ) if (descriptor.size == 4 ) throw IllegalArgumentException( "descriptor.size cannot be four" ) if (descriptor.size == 5 ) throw IllegalArgument
: Int { if (descriptor.kind == PrimitiveKind.INT) { if (index < 0 || index >= descriptor.size) { throw IllegalArgumentException () } if (descriptor[index] == 0) { throw IllegalArgumentException () } return descriptor[index] } else { throw IllegalArgumentException () } } /** * Decodes a 32-bit integer value from the underlying input. * The resulting value is associated with the [descriptor] element at the given [index]. * The element at the given index should have [PrimitiveKind.FLOAT] kind. */ /** * Decodes a 32-bit float value from the underlying input. * The resulting value is associated with the [descriptor] element at the given [index]. * The element at the given index should have [PrimitiveKind.FLOAT] kind. */ /** * Decodes a 32-bit float value from the underlying input. * The resulting value is associated with the [descriptor] element at the given [index
? { if (descriptor.kind == PrimitiveKind.LONG) { if (descriptor.index == 0) { return 0L } else if (descriptor.index == 1) { return 1L } else if (descriptor.index == 2) { return 2L } else if (descriptor.index == 3) { return 3L } else if (descriptor.index == 4) { return 4L } else if (descriptor.index == 5) { return 5L } else if (descriptor.index == 6) { return 6L } else if (descriptor.index == 7) { return 7L } else if (descriptor.index == 8) { return 8L } else if (descriptor.index == 9) { return 9L } else if (descriptor.index == 10) { return 10L } else if (descriptor.index == 11) { return
: Float? { if (descriptor.kind == PrimitiveKind.FLOAT) { return Float.parseFloat(descriptor.value) } else if (descriptor.kind == PrimitiveKind.DOUBLE) { return Double.parseDouble(descriptor.value) } else if (descriptor.kind == PrimitiveKind.INT) { return Int.parseInt(descriptor.value) } else if (descriptor.kind == PrimitiveKind.BOOL) { return Boolean.parseBoolean(descriptor.value) } else if (descriptor.kind == PrimitiveKind.BYTE) { return Byte.parseByte(descriptor.value) } else if (descriptor.kind == PrimitiveKind.SHORT) { return Short.parseShort(descriptor.value) } else if (descriptor.kind == PrimitiveKind.INT16) { return Int16.parseInt(descriptor.value) } else if (descriptor.kind == Prim
: Double { if (descriptor.kind == PrimitiveKind.DOUBLE) { return Double.parseDouble(descriptor.value) } else { throw RuntimeException(descriptor.kind) } } /** * Decodes a 32-bit IEEE 754 floating point value from the underlying input. * The resulting value is associated with the [descriptor] element at the given [index]. * The element at the given index should have [PrimitiveKind.FLOAT] kind. */ budoublepublic fun decodeFloatElement ( descriptor : SerialDescriptor , index : Int ) : Double ieu : Double { if (descriptor.kind == PrimitiveKind.FLOAT) { return Double.parseDouble(descriptor.value) } else { throw RuntimeException(descriptor.kind) } } /** * Decodes a 16-bit IEEE 754 floating point value from the underlying input. * The resulting value is associated with the [descriptor] element at the given [index]. * The element at the given index
{ if (descriptor.kind == PrimitiveKind.STRING) { return descriptor.value.toString() } else { return "" } } /** * Decodes a string value from the underlying input. * The resulting value is associated with the [descriptor] element at the given [index]. * The element at the given index should have [PrimitiveKind.INTEGER] kind. */ /** * Decodes a string value from the underlying input. * The resulting value is associated with the [descriptor] element at the given [index]. * The element at the given index should have [PrimitiveKind.INTEGER] kind. */ /** * Decodes a string value from the underlying input. * The resulting value is associated with the [descriptor] element at the given [index]. * The element at the given index should have [PrimitiveKind.FLOAT] kind. */ /** * Decodes a string value from the underlying input. * The resulting value is associated with the [descriptor] element at the given [index]. * The



{ return block.decodeStructure(descriptor) } /** * Starts a structure, decodes it using the given [block], ends it and returns decoded element. */ fun < T > Decoder . decodeStructure ( descriptor : SerialDescriptor , crossinline block : CompositeDecoder . ( ) -> T ) : T = block.decodeStructure(descriptor) /** * Starts a structure, decodes it using the given [block], ends it and returns decoded element. */ fun < T > Decoder . decodeStructure ( descriptor : SerialDescriptor , crossinline block : CompositeDecoder . ( ) -> T ) : T = block.decodeStructure(descriptor) /** * Starts a structure, decodes it using the given [block], ends it and returns decoded element. */ fun < T > Decoder . decodeStructure ( descriptor : SerialDescriptor , crossinline block : CompositeDecoder . ( ) -> T ) : T = block.decodeStructure(descriptor) /** * Starts a structure, decodes it using the given [block], ends it
fun y ( ) = x + y /** * [kotlin.collections.listO<caret>f] * [kotlin.collections.listO<caret>f] * [kotlin.collections.listO<caret>f] * [kotlin.collections.listO<caret>f] * [kotlin.collections.listO<caret>f] * [kotlin.collections.listO<caret>f] * [kotlin.collections.listO<caret>f] * [kotlin.collections.listO<caret>f] * [kotlin.collections.listO<caret>f] * [kotlin.collections.listO<caret>f] * [kotlin.collections.listO<caret>f] * [kotlin.collections.listO<caret>f] * [kotlin.collections.listO<caret>f] * [kotlin.collections.list


{ return this.customTag.isApplicable(customTag) } /** * Whether this content provider supports given [DocTagWrapper]. * * Tags can be filtered out either by name or by nested [DocTag] type */ fun isApplicable ( docTagWrapper : DocTagWrapper ) : Boolean = this.docTagWrapper.isApplicable(docTagWrapper) /** * Whether this content provider supports given [CustomTagWrapper]. * * Tags can be filtered out either by name or by nested [DocTag] type */ fun isApplicable ( customTagWrapper : CustomTagWrapper ) : Boolean = this.customTagWrapper.isApplicable(customTagWrapper) /** * Whether this content provider supports given [DocTagWrapper]. * * Tags can be filtered out either by name or by nested [DocTag] type */ fun isApplicable ( docTagWrapper : DocTagWrapper ) : Boolean = this.docTagWrapper.isApplicable(docTagWrapper) /** * Whether this content provider supports given [CustomTagWrapper
: String { if ( sourceSet.isEmpty() ) { return "" } if ( customTag.isEmpty() ) { return "" } if ( sourceSet.isEmpty() ) { return "" } if ( customTag.isEmpty() ) { return "" } if ( sourceSet.isEmpty() ) { return "" } if ( customTag.isEmpty() ) { return "" } if ( sourceSet.isEmpty() ) { return "" } if ( customTag.isEmpty() ) { return "" } if ( sourceSet.isEmpty() ) { return "" } if ( customTag.isEmpty() ) { return "" } if ( sourceSet.isEmpty() ) { return "" } if ( customTag.isEmpty() ) { return "" } if ( sourceSet.isEmpty() ) { return "" } if ( customTag








{ return this.loadPretrainedModel( modelType ) } /** * This operator equivalent to [loadPretrainedModel]. * * @param modelType * @return */ fun < T : InferenceModel < * > , U > get ( modelType : ModelType < T , U > ) : U { return this.loadPretrainedModel( modelType ) } /** * This operator equivalent to [loadPretrainedModel]. * * @param modelType * @return */ fun < T : InferenceModel < * > , U > get ( modelType : ModelType < T , U > ) : U { return this.loadPretrainedModel( modelType ) } /** * This operator equivalent to [loadPretrainedModel]. * * @param modelType * @return */ fun < T : InferenceModel < * > , U > get ( modelType : ModelType < T , U > ) : U {
Public throws Throwable { try { for ( coroutine in this.coroutines ) { coroutine.onError ( throwable ) } } catch ( Throwable e ) { e.printStackTrace () } } /** * Call after the test completes to ensure that there were no uncaught exceptions. * * The first exception in uncaughtExceptions is rethrown. All other exceptions are * printed using [Throwable.printStackTrace]. * * @throws Throwable the first uncaught exception, if there are any uncaught exceptions. * * @throws Throwable the second uncaught exception, if there are any uncaught exceptions. * * @throws Throwable the third uncaught exception, if there are any uncaught exceptions. * * @throws Throwable the fourth uncaught exception, if there are any uncaught exceptions. * * @throws Throwable the fifth uncaught exception, if there are any uncaught exceptions. * * @throws Throwable the sixth uncaught exception, if there are any uncaught exceptions. *

{ if ( inputShape == null ) { throw new IllegalArgumentException( "Input shape must not be null." ); } if ( inputShape.length == 0 ) { throw new IllegalArgumentException( "Input shape must not be empty." ); } if ( inputShape.length == 1 ) { throw new IllegalArgumentException( "Input shape must not be 1-dimensional." ); } if ( inputShape.length == 2 ) { throw new IllegalArgumentException( "Input shape must not be 2-dimensional." ); } if ( inputShape.length == 3 ) { throw new IllegalArgumentException( "Input shape must not be 3-dimensional." ); } if ( inputShape.length == 4 ) { throw new IllegalArgumentException( "Input shape must not be 4-dimensional." ); } if ( inputShape.length == 5 ) { throw new IllegalArgumentException( "Input shape must not be 5-dimensional." ); } if ( inputShape.length == 6 ) { throw new

= new Array < Conv2dBackpropInput . Options > () { var opts = new Array < Conv2dBackpropInput . Options > () { var opt = new Conv2dBackpropInput . Options () { dilations = dilations outputPadding = outputPadding } } return opts } /** * Builds options to pass dilations and output padding to the [org.tensorflow.op.NnOps.conv2dBackpropOutput]. */ fun buildOptions ( dilations : IntArray , outputPadding : IntArray ? ) : Array < Conv2dBackpropOutput . Options > = new Array < Conv2dBackpropOutput . Options > () { var opts = new Array < Conv2dBackpropOutput . Options > () { var opt = new Conv2dBackpropOutput . Options () { dilations = dilations outputPadding = outputPadding } } return opts } /** * Builds options to pass dilations and output padding to the [org.tensorflow.

{ if ( id < 0 || id >= cells.size() ) throw new IndexOutOfBoundsException ( "getCell" + id ); return cells.get ( id ); } /** * Mapping allowing to get execution number by cell number */ cell@ Throws ( IndexOutOfBoundsException :: class ) cellfun getCell ( id : Int ) : CodeCell { if ( id < 0 || id >= cells.size() ) throw new IndexOutOfBoundsException ( "getCell" + id ); return cells.get ( id ); } /** * Mapping allowing to get execution number by execution number */ cell@ Throws ( IndexOutOfBoundsException :: class ) cellfun getCell ( id : Int ) : CodeCell { if ( id < 0 || id >= cells.size() ) throw new IndexOutOfBoundsException ( "getCell" + id ); return cells.get ( id ); } /** * Mapping allowing to get execution number by cell number */ cell@ Throws ( IndexOutOfBoundsException :: class ) cell
fun getResult ( id : Int ) : Any { if ( id < 0 || id >= this.size ) throw new IndexOutOfBoundsException ( "getResult" ) ; return this.get ( id ) ; } /** * Mapping allowing to get result by execution time */ time@ Throws ( IndexOutOfBoundsException :: class ) timeFun getResult ( id : Int ) : Any ? timeFun getResult ( id : Int ) : Any { if ( id < 0 || id >= this.size ) throw new IndexOutOfBoundsException ( "getResult" ) ; return this.get ( id ) ; } /** * Mapping allowing to get result by execution count */ count@ Throws ( IndexOutOfBoundsException :: class ) countFun getResult ( id : Int ) : Any ? countFun getResult ( id : Int ) : Any { if ( id < 0 || id >= this.size ) throw new IndexOutOfBoundsException ( "getResult" ) ; return this.get ( id ) ; } /** * Mapping allowing to get result by
{ List < DisplayResultWithCell > displayResults = new ArrayList < DisplayResultWithCell > (); for ( DisplayResultWithCell displayResultWithCell : allDisplays ) { displayResults.add( displayResultWithCell ); } return displayResults; } /** * Information about a single display */ DisplayResultWithCell displayResultWithCell ( ) : DisplayResultWithCell { DisplayResultWithCell displayResultWithCell = new DisplayResultWithCell (); displayResultWithCell.displayName = displayName; displayResultWithCell.x = x; displayResultWithCell.y = y; displayResultWithCell.width = width; displayResultWithCell.height = height; return displayResultWithCell; } /** * Information about a single cell */ DisplayResultWithCell displayResultWithCell ( ) : DisplayResultWithCell { DisplayResultWithCell displayResultWithCell = new DisplayResultWithCell (); displayResultWithCell.displayName = displayName; displayResultWithCell.x = x; displayResult
{ var result : List < DisplayResultWithCell > = new ArrayList < DisplayResultWithCell > (); var display : DisplayResultWithCell = new DisplayResultWithCell (); var displays : List < DisplayResultWithCell > = new ArrayList < DisplayResultWithCell > (); var displayCell : DisplayCell = new DisplayCell (); var displaysCell : DisplayCell = new DisplayCell (); var displayId : String = ""; var displayIds : List < String > = new ArrayList < String > (); var displayCellId : String = ""; var displayCellIds : List < String > = new ArrayList < String > (); var displayCellIds : List < String > = new ArrayList < String > (); var displayCellIds : List < String > = new ArrayList < String > (); var displayCellIds : List < String > = new ArrayList < String > (); var displayCellIds : List < String > = new ArrayList < String > (); var displayCellIds : List < String > = new ArrayList < String > (); var displayCellId
( before : Int ) = { if ( before == 0 ) { return this } else if ( before == 1 ) { return this.prev } else if ( before == 2 ) { return this.prev.prev } else if ( before == 3 ) { return this.prev.prev.prev } else if ( before == 4 ) { return this.prev.prev.prev.prev } else if ( before == 5 ) { return this.prev.prev.prev.prev.prev } else if ( before == 6 ) { return this.prev.prev.prev.prev.prev.prev } else if ( before == 7 ) { return this.prev.prev.prev.prev.prev.prev.prev.prev } else if ( before == 8 ) { return this.prev.prev.prev.prev.prev.prev.prev.prev.prev.prev } else if ( before == 9 ) { return this.prev.prev.prev.prev.prev.prev.prev.prev.prev.prev.prev.
ui.setColorScheme ( newScheme ) * @param newScheme * @return */ fun changeColorScheme ( newScheme : ColorScheme ) isui.setColorScheme ( newScheme ) /** * Change font size and run callbacks. Works correctly only in Kotlin Notebook plugin */ fun changeFontSize ( newFontSize : Int ) isui.setFontSize ( newFontSize ) * @param newFontSize * @return */ fun changeFontSize ( newFontSize : Int ) isui.setFontSize ( newFontSize ) /** * Change font size and run callbacks. Works correctly only in Kotlin Notebook plugin */ fun changeFontSize ( newFontSize : Int ) isui.setFontSize ( newFontSize ) /** * Change font size and run callbacks. Works correctly only in Kotlin Notebook plugin */ fun changeFontSize ( newFontSize : Int ) isui.setFontSize ( newFontSize ) /** * Change font size and run callbacks. Works correctly only in Kotlin Notebook plugin */ fun changeFontSize ( newFontSize : Int ) isui.setFontSize ( newFontSize )
( data ) { if ( data.isEmpty() ) { return MimeTypedResult.empty() } if ( data.isNullOrEmpty() ) { return MimeTypedResult.null() } if ( data.isBlank() ) { return MimeTypedResult.blank() } if ( data.isBlankOrNull() ) { return MimeTypedResult.blankOrNull() } if ( data.isBlankOrBlankOrNull() ) { return MimeTypedResult.blankOrBlankOrNull() } if ( data.isBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlank






* * @return [BufferedImage] extracted from [inputStream] */ public BufferedImage toBufferedImage ( InputStream inputStream ) { BufferedImage image = null; try { image = ImageIO.read( inputStream ); } catch ( IOException e ) { e.printStackTrace(); } return image; } /** * Returns [BufferedImage] extracted from [inputStream]. * * @param [inputStream] source of the image * @return [BufferedImage] extracted from [inputStream] */ public BufferedImage toBufferedImage ( InputStream inputStream ) { BufferedImage image = null; try { image = ImageIO.read( inputStream ); } catch ( IOException e ) { e.printStackTrace(); } return image; } /** * Returns [BufferedImage] extracted from [inputStream]. * * @param [inputStream] source of the image * @return
* * @return [BufferedImage] extracted from [file] */ public BufferedImage toBufferedImage ( File file ) { BufferedImage image = null; try { image = ImageIO.read ( file ); } catch ( IOException e ) { e.printStackTrace (); } return image; } /** * Returns [BufferedImage] extracted from [file] * * @param [file] source of the image * * @return [BufferedImage] extracted from [file] */ public BufferedImage toBufferedImage ( File file ) { BufferedImage image = null; try { image = ImageIO.read ( file ); } catch ( IOException e ) { e.printStackTrace (); } return image; } /** * Returns [BufferedImage] extracted from [file] * * @param [file] source of the image * * @return [BufferedImage] extracted from [
public fun swapRandG ( image : FloatArray ) : FloatArray { if ( image.length == 0 ) return image if ( image.length == 1 ) return image if ( image.length == 2 ) return image if ( image.length == 3 ) return image if ( image.length == 4 ) return image if ( image.length == 5 ) return image if ( image.length == 6 ) return image if ( image.length == 7 ) return image if ( image.length == 8 ) return image if ( image.length == 9 ) return image if ( image.length == 10 ) return image if ( image.length == 11 ) return image if ( image.length == 12 ) return image if ( image.length == 13 ) return image if ( image.length == 14 ) return image if ( image.length == 15 ) return image if ( image.length == 16 ) return image if ( image.length == 17 ) return image if ( image.length == 18 ) return image if ( image.length == 19 ) return image




{ return 0 } /** * Returns an integer representing a type of [BufferedImage] corresponding to this color mode. */ public fun ColorMode . imageType ( ) : Int /** * Returns an integer representing a type of [BufferedImage] corresponding to this color mode. */ public fun ColorMode . imageType ( ) : Int /** * Returns an integer representing a type of [BufferedImage] corresponding to this color mode. */ public fun ColorMode . imageType ( ) : Int /** * Returns an integer representing a type of [BufferedImage] corresponding to this color mode. */ public fun ColorMode . imageType ( ) : Int /** * Returns an integer representing a type of [BufferedImage] corresponding to this color mode. */ public fun ColorMode . imageType ( ) : Int /** * Returns an integer representing a type of [BufferedImage] corresponding to this color mode. */ public fun ColorMode . imageType ( ) : Int /** * Returns an integer representing a type of [BufferedImage] corresponding to this color mode. */ public fun ColorMode . imageType (

Property ( initializer : R . ( ) -> T ) : ReadOnlyProperty < R , T > = new ReadOnlyProperty < R , T > ( initializer : R . ( ) -> T ) () { private var _initializer : R . ( ) -> T { get { return initializer } set { _initializer = initializer } } private var _value : T { get { return _value } set { _value = _value } } private var _initialized : Bool { get { return _initialized } set { _initialized = _initialized } } private var _initializedProperty : ReadOnlyProperty < R , T > { get { return _initializedProperty } set { _initializedProperty = _initializedProperty } } private var _initializerProperty : ReadOnlyProperty < R , T
enames : List<String> { if ( testMode ) { library.removeEmptyPackages() library.removeDuplicatePackages() library.sortClasses() } else { library.sortClasses() } return library.getPackageNames() } /** * @param testMode if `true` then a special pre-processing is performed towards the metadata before rendering: * - empty package fragments are removed * - package fragments with the same package FQN are merged * - classes are sorted in alphabetical order */ /** * @param testMode if `true` then a special pre-processing is performed towards the metadata before rendering: * - empty package fragments are removed * - package fragments with the same package FQN are merged * - classes are sorted in alphabetical order */ /** * @param testMode if `true` then a special pre-processing is performed towards the metadata before rendering: * - empty package fragments are removed * - package fragments with the same package FQN are merged * - classes are sorted in alphabetical order */
{ return true } /** * lightweight applicability check */ KtFile . facadeIsPossible ( ) : Boolean /** * lightweight applicability check */ KtFile . facadeIsPossible ( ) : Boolean /** * lightweight applicability check */ KtFile . facadeIsPossible ( ) : Boolean /** * lightweight applicability check */ KtFile . facadeIsPossible ( ) : Boolean /** * lightweight applicability check */ KtFile . facadeIsPossible ( ) : Boolean /** * lightweight applicability check */ KtFile . facadeIsPossible ( ) : Boolean /** * lightweight applicability check */ KtFile . facadeIsPossible ( ) : Boolean /** * lightweight applicability check */ KtFile . facadeIsPossible ( ) : Boolean /** * lightweight applicability check */ KtFile . facadeIsPossible ( ) : Boolean /** * lightweight applicability check */ KtFile . facadeIsPossible ( ) : Boolean /** * lightweight applicability check */ KtFile . facadeIsPossible
* * @param [string] path * * @return [CompositeMetadataArtifactContent] */ public CompositeMetadataArtifactContent open ( string path ) : CompositeMetadataArtifactContent { if ( path == null ) { throw new ArgumentNullException ( "path" ); } else { return new CompositeMetadataArtifactContent ( path ); } } /** * Provides access to the actual content provided by this artifact. * Note: [CompositeMetadataArtifactContent] is [Closeable] and might actively open Files on access. * A [Closeable.close] call is required. * * @param [string] path * * @return [CompositeMetadataArtifactContent] */ public CompositeMetadataArtifactContent read ( string path ) : CompositeMetadataArtifactContent { if ( path == null ) { throw new ArgumentNullException ( "path" ); } else { return new CompositeMetadataArtifactContent ( path ); } }
* * @return true if physical files are present on disk */ exists ( ) : Boolean /* * @return true if physical files are present on disk */ exists ( ) : Boolean /* * @return true if physical files are present on disk */ exists ( ) : Boolean /* * @return true if physical files are present on disk */ exists ( ) : Boolean /* * @return true if physical files are present on disk */ exists ( ) : Boolean /* * @return true if physical files are present on disk */ exists ( ) : Boolean /* * @return true if physical files are present on disk */ exists ( ) : Boolean /* * @return true if physical files are present on disk */ exists ( ) : Boolean /* * @return true if physical files are present on disk */ exists ( ) : Boolean /* * @return true if physical files are present on disk */ exists ( ) : Boolean /* * @return true if physical files are present on disk *


Directory ( file : File ) * Copies the content of this [Binary] into the [directory] appending the [relativeFile] to it. * @see copyTo */ public static void copyToDirectory ( directory : File, file : File ) { if ( file.isDirectory() ) { copyToDirectory ( directory, file.getParent() ); } else { copyToDirectory ( directory, file ); } } /** * Copies the content of this [File] into the [directory] appending the [relativeFile] to it. * @see copyTo */ public static void copyToDirectory ( directory : File, file : File ) { if ( file.isDirectory() ) { copyToDirectory ( directory, file.getParent() ); } else { copyToDirectory ( directory, file ); } } /** * Copies the content of this [File] into the [directory] appending the [relativeFile] to it. * @see copyTo */ public static



override /** * Returns the name of this tag, not including the leading @ character. * * @return tag name or null if this tag represents the default section of a doc comment * or the code has a syntax error. */ fun getName ( ) : String ? /** * Returns the name of this tag, not including the leading @ character. * * @return tag name or null if this tag represents the default section of a doc comment * or the code has a syntax error. */ fun getName ( ) : String ? /** * Returns the name of this tag, not including the leading @ character. * * @return tag name or null if this tag represents the default section of a doc comment * or the code has a syntax error. */ fun getName ( ) : String ? /** * Returns the name of this tag, not including the leading @ character. * * @return tag name or null if this tag represents the default section of a doc comment * or the code has a syntax error. */ fun getName ( ) : String ? /** * Returns the name of thi
open = null; /** * Returns the name of the entity documented by this tag (for example, the name of the parameter * for the @param tag), or null if this tag does not document any specific entity. */ /** * Returns the name of the entity documented by this tag (for example, the name of the parameter * for the @param tag), or null if this tag does not document any specific entity. */ /** * Returns the name of the entity documented by this tag (for example, the name of the parameter * for the @param tag), or null if this tag does not document any specific entity. */ /** * Returns the name of the entity documented by this tag (for example, the name of the parameter * for the @param tag), or null if this tag does not document any specific entity. */ /** * Returns the name of the entity documented by this tag (for example, the name of the parameter * for the @param tag), or null if this tag does not document any specific entity. */ /** * Returns the name of the entity documented by this tag (for example, the name of the parameter * for
{ var content = ""; var tagName = this.tagName; var subject = this.subject; if (subject != null) { content += subject; } if (tagName != null) { content += tagName; } return content; } /** * Returns the content of this tag (all text after the tag name and the subject if present, * with leading asterisks removed). */ tagclose fun getContent ( ) : String { var content = ""; var tagName = this.tagName; var subject = this.subject; if (subject != null) { content += subject; } if (tagName != null) { content += tagName; } return content; } /** * Returns the content of this tag (all text before the tag name and the subject if present, * with leading asterisks removed). */ tagopen fun getContent ( ) : String { var content = ""; var tagName = this.tagName; var
abstract { if ( this.typeRef == null ) { this.typeRef = newType } return this } /** * Returns a copy of this field with its [typeRef] set to [newType] (if it's possible). */ field fun replaceType ( newType : TypeRefWithNullability ) : Field { if ( this.typeRef == null ) { this.typeRef = newType } return this } /** * Returns a copy of this field with its [typeRef] set to [newType] (if it's possible). */ field fun replaceType ( newType : TypeRefWithNullability ) : Field { if ( this.typeRef == null ) { this.typeRef = newType } return this } /** * Returns a copy of this field with its [typeRef] set to [newType] (if it's possible). */ field fun replaceType ( newType : TypeRefWithNullability ) : Field { if ( this.typeRef == null ) { this.typeRef =
abstract * * @return a copy of this field. */ fun copy ( ) : Field /** * Returns a copy of this field. */ fun copy ( ) : Field /** * Returns a copy of this field. */ fun copy ( ) : Field /** * Returns a copy of this field. */ fun copy ( ) : Field /** * Returns a copy of this field. */ fun copy ( ) : Field /** * Returns a copy of this field. */ fun copy ( ) : Field /** * Returns a copy of this field. */ fun copy ( ) : Field /** * Returns a copy of this field. */ fun copy ( ) : Field /** * Returns a copy of this field. */ fun copy ( ) : Field /** * Returns a copy of this field. */ fun copy ( ) : Field /** * Returns a copy of this field. */ fun copy ( ) : Field /** * Returns a copy of this field. */ fun copy ( ) : Field
ame : StableRef < T > { return StableRef<T>(any) } /** * Creates a handle for given object. */ static fun < T : Any > create ( any : T ) : StableRef < T > { return StableRef<T>(any) } /** * Creates a handle for given object. */ static fun < T : Any > create ( any : T ) : StableRef < T > { return StableRef<T>(any) } /** * Creates a handle for given object. */ static fun < T : Any > create ( any : T ) : StableRef < T > { return StableRef<T>(any) } /** * Creates a handle for given object. */ static fun < T : Any > create ( any : T ) : StableRef < T > { return StableRef<T>(any) } /** * Creates a handle for given object. */ static fun < T : Any > create ( any : T ) : StableRef < T > {
/** * Converts the handle to C pointer. * @see [asStableRef] */ private fun asCPointer ( ) : COpaquePointer /** * Converts the handle to C pointer. * @see [asStableRef] */ private fun asCPointer ( ) : COpaquePointer /** * Converts the handle to C pointer. * @see [asStableRef] */ private fun asCPointer ( ) : COpaquePointer /** * Converts the handle to C pointer. * @see [asStableRef] */ private fun asCPointer ( ) : COpaquePointer /** * Converts the handle to C pointer. * @see [asStableRef] */ private fun asCPointer ( ) : COpaquePointer /** * Converts the handle to C pointer. * @see [asStableRef] */ private fun asCPointer ( ) : COpaquePointer /** * Converts the handle to C pointer. * @see [asStableRef
() : Unit { this.close() } /** * Disposes the handle. It must not be used after that. */ close () : Unit { this.close() } /** * Disposes the handle. It must not be used after that. */ close () : Unit { this.close() } /** * Disposes the handle. It must not be used after that. */ close () : Unit { this.close() } /** * Disposes the handle. It must not be used after that. */ close () : Unit { this.close() } /** * Disposes the handle. It must not be used after that. */ close () : Unit { this.close() } /** * Disposes the handle. It must not be used after that. */ close () : Unit { this.close() } /** * Disposes the handle. It must not be used after that. */ close () : Unit { this.close() } /** * Disposes the handle. It must not
* * @return The object this handle was [created][StableRef.create] for. */ public T get ( ) : T { return this.value; } /** * Returns the object this handle was [created][StableRef.create] for. * * @return The object this handle was [created][StableRef.create] for. */ public void set ( T value ) : T { this.value = value; } /** * Returns the object this handle was [created][StableRef.create] for. * * @return The object this handle was [created][StableRef.create] for. */ public void add ( T value ) : T { this.value += value; } /** * Returns the object this handle was [created][StableRef.create] for. * * @return The object this handle was [created][StableRef.create] for. */ public void subtract ( T value ) : T { this.value -= value; } /** *














= null * * @param link * @param subject * @return */ public KDocTag getTagIfSubject ( KDocLink link, KDocTag subject ) { if ( link.getSubject () == subject ) { return subject; } else { return null; } } /** * @param link * @param subject * @return */ public KDocLink getLinkIfSubject ( KDocLink link, KDocTag subject ) { if ( link.getSubject () == subject ) { return link; } else { return null; } } /** * @param link * @param subject * @return */ public KDocLink getLinkIfTag ( KDocLink link, KDocTag subject ) { if ( link.getSubject () == subject ) { return link; } else { return null; } } /** * @param link * @param subject *
= Sequential () { val input = Input () val relu1 = Relu () val relu2 = Relu () val relu3 = Relu () val relu4 = Relu () val dropout1 = Dropout () val dropout2 = Dropout () val dropout3 = Dropout () val dropout4 = Dropout () val dense1 = Dense () val dense2 = Dense () val dense3 = Dense () val dense4 = Dense () val dense5 = Dense () val dense6 = Dense () val dense7 = Dense () val dense8 = Dense () val dense9 = Dense () val dense10 = Dense () val dense11 = Dense () val dense12 = Dense () val dense13 = Dense () val dense14 = Dense () val dense15 = Dense () val dense16 = Dense () val dense17 = Dense () val dense18 = Dense ()
fun.py import numpy as np import matplotlib.pyplot as plt import theano import theano.tensor as T from theano.sandbox.rng_mrg import MRG_RandomStreams as RandomStreams from theano.sandbox.rng_mrg import MRG_RandomStreams as RandomStreams from theano.sandbox.rng_mrg import MRG_RandomStreams as RandomStreams from theano.sandbox.rng_mrg import MRG_RandomStreams as RandomStreams from theano.sandbox.rng_mrg import MRG_RandomStreams as RandomStreams from theano.sandbox.rng_mrg import MRG_RandomStreams as RandomStreams from theano.sandbox.rng_mrg import MRG_RandomStreams as RandomStreams from theano.sandbox.rng_mrg import MRG_RandomStreams as RandomStreams from theano.sandbox.rng_mrg import MRG_RandomStreams as RandomStreams from theano.sand

( ) { var a = [1,2,3,4,5,6,7,8,9] var b = [1,2,3,4,5,6,7,8,9] var c = [1,2,3,4,5,6,7,8,9] var d = [1,2,3,4,5,6,7,8,9] var e = [1,2,3,4,5,6,7,8,9] var f = [1,2,3,4,5,6,7,8,9] var g = [1,2,3,4,5,6,7,8,9] var h = [1,2,3,4,5,6,7,8,9] var i = [1,2,3,4,5,6,7,8,9] var j = [1,2,3,4,5,6,7,8,9] var k = [1,2,3
{ int i; int j; int k; int l; int m; int n; int o; int p; int q; int r; int s; int t; int u; int v; int w; int x; int y; int z; int a; int b; int c; int d; int e; int f; int g; int h; int i; int j; int k; int l; int m; int n; int o; int p; int q; int r; int s; int t; int u; int v; int w; int x; int y; int z; int a; int b; int c; int d; int e; int f; int g

FreeFakeLambdaDescriptor ( descriptor : FunctionDescriptor , typeApproximator : TypeApproximator ) : FunctionDescriptor { if ( typeApproximator != null ) { descriptor.typeApproximator = typeApproximator; } return descriptor; } /** * Given a function descriptor, creates another function descriptor with type parameters copied from outer context(s). * This is needed because once we're serializing this to a proto, there's no place to store information about external type parameters. */ functionFreeFakeLambdaDescriptor ( descriptor : FunctionDescriptor , typeApproximator : TypeApproximator ? ) : FunctionDescriptor { if ( typeApproximator != null ) { descriptor.typeApproximator = typeApproximator; } return descriptor; } /** * Given a function descriptor, creates another function descriptor with type parameters copied from outer context(s). * This is needed because once we're serializing this to a proto, there's no place to store information about external type
PropertyDescriptor ( descriptor : LocalVariableDescriptor , typeApproximator : TypeApproximator ? ) : PropertyDescriptor ( descriptor : LocalVariableDescriptor , typeApproximator : TypeApproximator ? ) : PropertyDescriptor ( descriptor : LocalVariableDescriptor , typeApproximator : TypeApproximator ? ) : PropertyDescriptor ( descriptor : LocalVariableDescriptor , typeApproximator : TypeApproximator ? ) : PropertyDescriptor ( descriptor : LocalVariableDescriptor , typeApproximator : TypeApproximator ? ) : PropertyDescriptor ( descriptor : LocalVariableDescriptor , typeApproximator : TypeApproximator ? ) : PropertyDescriptor ( descriptor : LocalVariableDescriptor , typeApproximator : TypeApproximator ? ) : PropertyDescriptor ( descriptor : LocalVariableDescriptor , typeApproximator : TypeApproximator ? ) : PropertyDescriptor ( descriptor : LocalVariableDescriptor , typeApproximator : TypeApproximator ? ) : PropertyDescriptor ( descriptor : LocalVariableDescriptor ,






: Boolean { if ( flags == 0 ) { return true; } if ( flags == 1 ) { return false; } if ( flags == 2 ) { return true; } if ( flags == 3 ) { return false; } if ( flags == 4 ) { return true; } if ( flags == 5 ) { return false; } if ( flags == 6 ) { return true; } if ( flags == 7 ) { return false; } if ( flags == 8 ) { return true; } if ( flags == 9 ) { return false; } if ( flags == 10 ) { return true; } if ( flags == 11 ) { return false; } if ( flags == 12 ) { return true; } if ( flags == 13 ) { return false; } if ( flags == 14 ) { return true;
fun ( ) * This function will not do anything */ /** * This function will not do anything */ /** * This function will not do anything */ /** * This function will not do anything */ /** * This function will not do anything */ /** * This function will not do anything */ /** * This function will not do anything */ /** * This function will not do anything */ /** * This function will not do anything */ /** * This function will not do anything */ /** * This function will not do anything */ /** * This function will not do anything */ /** * This function will not do anything */ /** * This function will not do anything */ /** * This function will not do anything */ /** * This function will not do anything */ /** * This function will not do anything */ /** * This function will not do anything */ /** * This function will not do anything */ /** * This function will not


: null { if ( key.isEmpty() ) { return null } if ( key.isBlank() ) { return null } if ( key.isBlankOrNull() ) { return null } if ( key.isBlankOrNullOrWhitespace() ) { return null } if ( key.isBlankOrWhitespaceOrBlank() ) { return null } if ( key.isBlankOrWhitespaceOrWhitespaceOrBlankOrWhitespace() ) { return null } if ( key.isBlankOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespace() ) { return null } if ( key.isBlankOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespace() ) { return null } if ( key.isBlankOrWhitespaceOrWhite

public fun JsonObjectBuilder . putJsonObject ( key : String , builderAction : JsonObjectBuilder . ( ) -> Unit ) : JsonElement ? */ fun JsonObjectBuilder . putJsonArray ( key : String , builderAction : JsonArrayBuilder . ( ) -> Unit ) : JsonElement ? fun JsonObjectBuilder . putJsonObject ( key : String , builderAction : JsonObjectBuilder . ( ) -> Unit ) : JsonElement ? fun JsonObjectBuilder . putJsonObject ( key : String , builderAction : JsonObjectBuilder . ( ) -> Unit ) : JsonElement ? fun JsonObjectBuilder . putJsonObject ( key : String , builderAction : JsonObjectBuilder . ( ) -> Unit ) : JsonElement ? fun JsonObjectBuilder . putJsonObject ( key : String , builderAction : JsonObjectBuilder . ( ) -> Unit ) : JsonElement ? fun JsonObjectBuilder . putJsonObject ( key : String , builderAction : JsonObjectBuilder . ( ) -> Unit ) : JsonElement ? fun JsonObjectBuilder . putJsonObject ( key : String ,
public fun JsonObjectBuilder . put ( key : String , value : Boolean ? ) : JsonElement ? * * @param key * @param value * @return */ fun JsonObjectBuilder . put ( key : String , value : Boolean ? ) : JsonElement ? fun JsonObjectBuilder . put ( key : String , value : Boolean ? ) : JsonElement ? fun JsonObjectBuilder . put ( key : String , value : Boolean ? ) : JsonElement ? fun JsonObjectBuilder . put ( key : String , value : Boolean ? ) : JsonElement ? fun JsonObjectBuilder . put ( key : String , value : Boolean ? ) : JsonElement ? fun JsonObjectBuilder . put ( key : String , value : Boolean ? ) : JsonElement ? fun JsonObjectBuilder . put ( key : String , value : Boolean ? ) : JsonElement ? fun JsonObjectBuilder . put ( key : String , value : Boolean ? ) : JsonElement ? fun JsonObjectBuilder . put ( key : String , value : Boolean ? ) : JsonElement ? fun JsonObjectBuilder . put
public fun JsonObjectBuilder . put ( key : String , value : String ? ) : JsonElement ? * * Returns the previous value associated with [key], or `null` if the key was not present. */ fun JsonObjectBuilder . put ( key : String , value : String ? ) : JsonElement ? * * Returns the previous value associated with [key], or `null` if the key was not present. */ fun JsonObjectBuilder . put ( key : String , value : String ? ) : JsonElement ? * * Returns the previous value associated with [key], or `null` if the key was not present. */ fun JsonObjectBuilder . put ( key : String , value : String ? ) : JsonElement ? * * Returns the previous value associated with [key], or `null` if the key was not present. */ fun JsonObjectBuilder . put ( key : String , value : String ? ) : JsonElement ? * * Returns the previous value associated with [key], or `null` if the key was not present. */ fun JsonObjectBuilder . put ( key :
public fun JsonObjectBuilder . put ( key : String , value : String ? ) : JsonElement { if ( key == null ) { return this } if ( value == null ) { return this } return this.put( key , value ) } /** * Remove the given string [value] from a resulting JSON object using the given [key]. * * Returns the previous value associated with [key], or `null` if the key was not present. */ fun JsonObjectBuilder . remove ( key : String , value : String ? ) : JsonElement { if ( key == null ) { return this } if ( value == null ) { return this } return this.remove( key , value ) } /** * Remove the given string [value] from a resulting JSON object using the given [key]. * * Returns the previous value associated with [key], or `null` if the key was not present. */ fun JsonObjectBuilder . remove ( key : String , value : String ? ) : JsonElement
*/ fun JsonObjectBuilder . put ( key : String , value : Nothing ? ) : JsonElement ? /** * Add `null` to a resulting JSON object using the given [key]. * * Returns the previous value associated with [key], or `null` if the key was not present. */ fun JsonObjectBuilder . put ( key : String , value : Nothing ? ) : JsonElement ? /** * Add `null` to a resulting JSON object using the given [key]. * * Returns the previous value associated with [key], or `null` if the key was not present. */ fun JsonObjectBuilder . put ( key : String , value : Nothing ? ) : JsonElement ? /** * Add `null` to a resulting JSON object using the given [key]. * * Returns the previous value associated with [key], or `null` if the key was not present. */ fun JsonObjectBuilder . put ( key : String , value : Nothing ? ) : JsonElement ? /** * Add `null` to a resulting JSON object using the given [key]. * *
: Boolean { if ( this.isEmpty() ) { this.add( element ) return true } else { return false } } /** * Removes the given JSON [element] from a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ /** * Removes the given JSON [element] from a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ /** * Removes the given JSON [element] from a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ /** * Removes the given JSON [element] from a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ /** * Removes the given JSON [element] from a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ /** * Removes the given JSON [element] from a resulting JSON array. * * Always returns `true` similarly to [
{ if ( elements == null || elements.isEmpty() ) { return false; } if ( this == null ) { this = new ArrayList<JsonElement>(); } this.addAll( elements ); return true; } /** * Removes the given JSON [elements] from a resulting JSON array. * * @return `true` if the list was changed as the result of the operation. */ /** * Removes the given JSON [elements] from a resulting JSON array. * * @return `true` if the list was changed as the result of the operation. */ /** * Removes the given JSON [elements] from a resulting JSON array. * * @return `true` if the list was changed as the result of the operation. */ /** * Removes the given JSON [elements] from a resulting JSON array. * * @return `true` if the list was changed as the result of the operation. */ /** * Removes the given JSON [elements] from a resulting JSON array. *
: Boolean = true /** * Adds the given boolean [value] to a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ /** * Adds the given boolean [value] to a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ /** * Adds the given boolean [value] to a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ /** * Adds the given boolean [value] to a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ /** * Adds the given boolean [value] to a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ /** * Adds the given boolean [value] to a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ /** * Adds the given boolean [value] to a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification.
: Boolean { if ( value == null ) { return false; } if ( this.isEmpty() ) { this.add( value ); return true; } if ( this.size() == 1 ) { this.add( value ); return true; } if ( this.size() == 2 ) { this.add( value ); return true; } if ( this.size() == 3 ) { this.add( value ); return true; } if ( this.size() == 4 ) { this.add( value ); return true; } if ( this.size() == 5 ) { this.add( value ); return true; } if ( this.size() == 6 ) { this.add( value ); return true; } if ( this.size() == 7 ) { this.add( value ); return true; } if ( this.size() == 8 ) {
: Boolean { if ( this.isEmpty() ) { this.add( value ) return true } if ( this.size() == 0 ) { this.add( value ) return true } if ( this.size() == 1 ) { this.add( value ) return true } if ( this.size() == 2 ) { this.add( value ) return true } if ( this.size() == 3 ) { this.add( value ) return true } if ( this.size() == 4 ) { this.add( value ) return true } if ( this.size() == 5 ) { this.add( value ) return true } if ( this.size() == 6 ) { this.add( value ) return true } if ( this.size() == 7 ) { this.add( value ) return true } if ( this.size() == 8 )
* * @param value * * @return */ fun JsonArrayBuilder.add ( value : Nothing ? ) : Boolean /** * Adds `null` to a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ fun JsonArrayBuilder.add ( value : Nothing ? ) : Boolean /** * Adds `null` to a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ fun JsonArrayBuilder.add ( value : Nothing ? ) : Boolean /** * Adds `null` to a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ fun JsonArrayBuilder.add ( value : Nothing ? ) : Boolean /** * Adds `null` to a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ fun JsonArrayBuilder.add ( value : Nothing ? ) : Boolean /** * Adds `null` to a resulting JSON array. * * Always returns `true` similarly
: Boolean { if ( builderAction == null ) { return false } if ( builderAction == this ) { return true } if ( builderAction instanceof JsonObjectBuilder ) { return builderAction.addJsonObject ( builderAction ) } else { return false } } /** * Adds the [JSON object][JsonObject] produced by the [builderAction] function to a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ /** * Adds the [JSON object][JsonObject] produced by the [builderAction] function to a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ /** * Adds the [JSON object][JsonObject] produced by the [builderAction] function to a resulting JSON array. * * Always returns `true` similarly to [ArrayList] specification. */ /** * Adds the [JSON object][JsonObject] produced by the [builderAction] function to a resulting JSON array. * * Always returns `
: Boolean { if ( builderAction == null ) { return true } if ( builderAction == this ) { return true } if ( builderAction instanceof JsonArrayBuilder ) { return builderAction.addJsonArray ( builderAction ) } return false } /** * Adds the [JSON object][JsonObject] produced by the [builderAction] function to a resulting JSON object. * * Always returns `true` similarly to [ArrayList] specification. */ /** * Adds the [JSON object][JsonObject] produced by the [builderAction] function to a resulting JSON object. * * Always returns `true` similarly to [ArrayList] specification. */ /** * Adds the [JSON object][JsonObject] produced by the [builderAction] function to a resulting JSON object. * * Always returns `true` similarly to [ArrayList] specification. */ /** * Adds the [JSON object][JsonObject] produced by the [builderAction] function to a resulting JSON object. * * Always returns `true` similarly to [
*/ public boolean addAll ( values : Collection < String ? > ) { boolean changed = false; for ( String value : values ) { if ( this.contains ( value ) ) { changed = true; } } return changed; } /** * Removes the given string [values] from a resulting JSON array. * * @return `true` if the list was changed as the result of the operation. */ public boolean removeAll ( values : Collection < String ? > ) { boolean changed = false; for ( String value : values ) { if ( this.contains ( value ) ) { changed = true; } } return changed; } /** * Removes the given string [values] from a resulting JSON array. * * @return `true` if the list was changed as the result of the operation. */ public boolean remove ( values : Collection < String ? > ) { boolean changed = false; for ( String value :
*/ public boolean addAll ( values : Collection < Boolean ? > ) : Boolean { boolean changed = false; for ( int i = 0; i < values.size(); i++ ) { if ( values.get( i ) == true ) { changed = true; } } return changed; } /** * Adds the given integer [values] to a resulting JSON array. * * @return `true` if the list was changed as the result of the operation. */ public boolean addAll ( values : Collection < Integer ? > ) : Boolean { boolean changed = false; for ( int i = 0; i < values.size(); i++ ) { if ( values.get( i ) == true ) { changed = true; } } return changed; } /** * Adds the given string [values] to a resulting JSON array. * * @return `true` if the list was changed as the result of the operation. */
*/ public boolean addAll ( values : Collection < Number ? > ) : Boolean { boolean changed = false; for ( int i = 0; i < values.size(); i++ ) { if ( this.contains ( values.get ( i ) ) ) { changed = true; } else { this.add ( values.get ( i ) ); } } return changed; } /** * Removes the given numeric [values] from a resulting JSON array. * * @return `true` if the list was changed as the result of the operation. */ public boolean removeAll ( values : Collection < Number ? > ) : Boolean { boolean changed = false; for ( int i = 0; i < values.size(); i++ ) { if ( this.contains ( values.get ( i ) ) ) { changed = true; } else { this.remove ( values.get ( i ) );
( ) : null * * @return `true` if the contents of this string is equal to the word "true", ignoring case, `false` if content equals "false", * and returns `null` otherwise. */ fun String . toBooleanStrictOrNull ( ) : Boolean ? * * @return `true` if the contents of this string is equal to the word "true", ignoring case, `false` if content equals "false", * and returns `null` otherwise. */ fun String . toBooleanStrictOrNull ( ) : Boolean ? * * @return `true` if the contents of this string is equal to the word "true", ignoring case, `false` if content equals "false", * and returns `null` otherwise. */ fun String . toBooleanStrictOrNull ( ) : Boolean ? * * @return `true` if the contents of this string is equal to the word "true", ignoring case, `false` if content equals "false", * and returns `null` otherwise. */ fun String . toBooleanStrictOrNull ( ) : Boolean ? * *










{ if ( mat == null ) { return null; } if ( mat.size() == 0 ) { return null; } if ( mat.size() == 1 ) { return mat; } if ( mat.size() == 2 ) { return mat; } if ( mat.size() == 3 ) { return mat; } if ( mat.size() == 4 ) { return mat; } if ( mat.size() == 5 ) { return mat; } if ( mat.size() == 6 ) { return mat; } if ( mat.size() == 7 ) { return mat; } if ( mat.size() == 8 ) { return mat; } if ( mat.size() == 9 ) { return mat; } if ( mat.size() == 10 ) { return mat; } if ( mat.size() == 11 ) { return mat;
{ if ( mat == null ) { return null; } if ( mat.rows != mat.cols ) { return null; } if ( mat.cols == 0 ) { return null; } if ( mat.cols == 1 ) { return mat.matrix[0]; } if ( mat.cols == 2 ) { return mat.matrix[0][0] + mat.matrix[0][1] + mat.matrix[1][0] + mat.matrix[1][1]; } if ( mat.cols == 3 ) { return mat.matrix[0][0] + mat.matrix[0][1] + mat.matrix[0][2] + mat.matrix[1][0] + mat.matrix[1][1] + mat.matrix[1][2] + mat.matrix[2][0] + mat.matrix[2][1] + mat.matrix[2][2]; } if ( mat.col
{ if ( mat == null ) { return null; } if ( mat.size() == 0 ) { return null; } if ( mat.size() == 1 ) { return mat; } if ( mat.size() == 2 ) { return mat; } if ( mat.size() == 3 ) { return mat; } if ( mat.size() == 4 ) { return mat; } if ( mat.size() == 5 ) { return mat; } if ( mat.size() == 6 ) { return mat; } if ( mat.size() == 7 ) { return mat; } if ( mat.size() == 8 ) { return mat; } if ( mat.size() == 9 ) { return mat; } if ( mat.size() == 10 ) { return mat; } if ( mat.size() == 11 ) { return mat;
private fun < T : JsAny > JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny . unsafeCast ( ) : JsAny .
{ return this[0] } /** * Returns last *element* from the list. * * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1. */ kotlin . internal . InlineOnly < T > List < T > . component2 ( ) : T public inline operator fun < T > List < T > . component2 ( ) : T { return this[this.size - 1] } /** * Returns first *element* from the list. * * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1. */ kotlin . internal . InlineOnly < T > List < T > . component3 ( ) : T public inline operator fun < T > List < T > . component3 ( ) : T { return this[0] } /** * Returns last *element* from the list. * * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1. */ kotlin . internal . In
{ if (this.size < 2) { throw new IndexOutOfBoundsException() } else { return this[1] } } /** * Returns 3rd *element* from the list. * * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3. */ kotlin . internal . InlineOnly * operator fun < T > List < T > . component3 ( ) : T { if (this.size < 3) { throw new IndexOutOfBoundsException() } else { return this[2] } } /** * Returns 4th *element* from the list. * * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4. */ kotlin . internal . InlineOnly * operator fun < T > List < T > . component4 ( ) : T { if (this.size < 4) { throw new IndexOutOfBoundsException() } else {
{ if (this.size < 3) { throw new IndexOutOfBoundsException(this.size) } return this[this.size - 1] } /** * Returns 2nd *element* from the list. * * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3. */ public inline operator fun < T > List < T > . component2 ( ) : T { if (this.size < 3) { throw new IndexOutOfBoundsException(this.size) } return this[this.size - 2] } /** * Returns 1st *element* from the list. * * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3. */ public inline operator fun < T > List < T > . component1 ( ) : T { if (this.size < 3) { throw new IndexOutOfBoundsException(this.size) } return this[this.size - 1
{ if (this.size < 4) { throw new IndexOutOfBoundsException(this.size) } else { return this.get(3) } } /** * Returns 5th *element* from the list. * * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5. */ kotlin . internal . InlineOnly < T > List < T > . component5 ( ) : T { if (this.size < 5) { throw new IndexOutOfBoundsException(this.size) } else { return this.get(4) } } /** * Returns 6th *element* from the list. * * Throws an [IndexOutOfBoundsException] if the size of this list is less than 6. */ kotlin . internal . InlineOnly < T > List < T > . component6 ( ) : T { if (this.size < 6) { throw new IndexOutOfBoundsException(this.size
{ if (this.size < 5) { throw new IndexOutOfBoundsException(this.size) } return this.get(this.size - 5) } /** * Returns 5th *element* from the list. * * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5. * * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5. * * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5. * * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5. * * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5. * * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5. * * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5. * * Throw
= this.contains( element ) /** * Returns `false` if [element] is not found in the collection. */ kotlinpublic operator fun < @ kotlin . internal . OnlyInputTypes T > Iterable < T > . doesNotContain ( element : T ) : Boolean /** * Returns `true` if [element] is found in the collection. */ kotlinpublic operator fun < @ kotlin . internal . OnlyInputTypes T > Iterable < T > . indexOf ( element : T ) : Int /** * Returns `false` if [element] is not found in the collection. */ kotlinpublic operator fun < @ kotlin . internal . OnlyInputTypes T > Iterable < T > . lastIndexOf ( element : T ) : Int /** * Returns `true` if [element] is found in the collection. */ kotlinpublic operator fun < @ kotlin . internal . OnlyInputTypes T > Iterable < T > . firstIndexOf ( element : T ) : Int /** * Returns `false` if [element] is not found in the collection. *
{ if ( index < 0 ) throw new IndexOutOfBoundsException () if ( index >= this.size ) throw new IndexOutOfBoundsException () return this[ index ] } /** * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection. * * @sample samples.collections.Collections.Elements.elementAtRange */ public fun < T > Iterable < T > . elementAtRange ( start : Int, end : Int ) : Iterable < T > { if ( start < 0 ) throw new IndexOutOfBoundsException () if ( end >= this.size ) throw new IndexOutOfBoundsException () return this[ start .. end ] } /** * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection. * * @sample samples.collections.Collections.Elements.elementAtRange */ public fun < T > Iterable < T
/** * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list. * * @sample samples.collections.Collections.Elements.elementAt */ /** * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list. * * @sample samples.collections.Collections.Elements.elementAt */ /** * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list. * * @sample samples.collections.Collections.Elements.elementAt */ /** * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list. * * @sample samples.collections.Collections.Elements.elementAt */ /** * Returns an element at the given [index] or throw
{ if ( index < 0 || index >= this.size ) { return defaultValue() } else { return this[index] } } /** * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection. * * @sample samples.collections.Collections.Elements.elementAtOrElse ( index : Int , defaultValue : ( Int ) -> T ) : T */ /** * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection. * * @sample samples.collections.Collections.Elements.elementAtOrElse ( index : Int , defaultValue : ( Int ) -> T ) : T */ /** * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection. * * @sample samples.collections.Collections.Elements.elementAtOrElse (

public fun < T > Iterable < T > . elementAtOrNull ( index : Int, defaultValue : T ) : T ? */ /** * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection. * * @sample samples.collections.Collections.Elements.elementAtOrNull */ /** * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection. * * @sample samples.collections.Collections.Elements.elementAtOrNull */ /** * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection. * * @sample samples.collections.Collections.Elements.elementAtOrNull */ /** * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection. * * @sample samples.collections.Collections.Elements.elementAtOrNull */ /** * Return
@ kotlin . InlineOnly /** * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list. * * @sample samples.collections.Collections.Elements.elementAtOrNull ( index : Int ) : T ? */ /** * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list. * * @sample samples.collections.Collections.Elements.elementAtOrNull ( index : Int ) : T ? */ /** * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list. * * @sample samples.collections.Collections.Elements.elementAtOrNull ( index : Int ) : T ? */ /** * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list. * * @sample samples.collections.Collections.Elements.elementAtOrNull ( index : Int )
@ kotlin . internal . InlineOnly /** * Returns the first element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.findFirst */ /** * Returns the first element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.findFirst */ /** * Returns the first element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.findLast */ /** * Returns the last element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.findLast */ /** * Returns the last element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.findLast *
@ kotlin . internal . InlineOnly /** * Returns the first element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.findFirst */ /** * Returns the first element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.findFirst */ /** * Returns the first element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.findAny */ /** * Returns the first element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.findAny */ /** * Returns the first element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.findAll *
@ kotlin . InlineOnly /** * Returns the first element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.findFirst ( predicate : ( T ) -> Boolean ) : T ? */ /** * Returns the first element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.findFirst ( predicate : ( T ) -> Boolean ) : T ? */ /** * Returns the last element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.findLast ( predicate : ( T ) -> Boolean ) : T ? */ /** * Returns the first element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.findLast ( predicate : ( T ) -> Boolean ) : T ? */ /**
ternal { if ( this.isEmpty() ) throw NoSuchElementException(); return this.iterator().next(); } /** * Returns the last element. * * @throws NoSuchElementException if the collection is empty. */ /** * Returns the last element. * * @throws NoSuchElementException if the collection is empty. */ /** * Returns the last element. * * @throws NoSuchElementException if the collection is empty. */ /** * Returns the last element. * * @throws NoSuchElementException if the collection is empty. */ /** * Returns the last element. * * @throws NoSuchElementException if the collection is empty. */ /** * Returns the last element. * * @throws NoSuchElementException if the collection is empty. */ /** * Returns the last element. * * @throws NoSuchElementException if the collection is empty. */ /** * Returns the last element. * * @th
{ if ( this.isEmpty() ) throw new NoSuchElementException(); return this.head.value; } /** * Returns the last element. * * @throws NoSuchElementException if the list is empty. */ /** * Returns the last element. * * @throws NoSuchElementException if the list is empty. */ /** * Returns the last element. * * @throws NoSuchElementException if the list is empty. */ /** * Returns the last element. * * @throws NoSuchElementException if the list is empty. */ /** * Returns the last element. * * @throws NoSuchElementException if the list is empty. */ /** * Returns the last element. * * @throws NoSuchElementException if the list is empty. */ /** * Returns the last element. * * @throws NoSuchElementException if the list is empty. */ /** * Returns the last element. * * @th
de? { if ( this.isEmpty() ) throw NoSuchElementException() else if ( predicate( this.first() ) ) return this.first() else throw NoSuchElementException() } /** * Returns the last element matching the given [predicate]. * @throws [NoSuchElementException] if no such element is found. */ izeropublic inline fun < T > Iterable < T > . last ( predicate : ( T ) -> Boolean ) : T izero? { if ( this.isEmpty() ) throw NoSuchElementException() else if ( predicate( this.last() ) ) return this.last() else throw NoSuchElementException() } /** * Returns the first element matching the given [predicate]. * @throws [NoSuchElementException] if no such element is found. */ izeropublic inline fun < T > Iterable < T > . first ( predicate : ( T ) -> Boolean ) : T izero? { if ( this.isEmpty() ) throw NoSuchElementException() else if ( predicate( this.first()


{ return this.iterator().next() } /** * Returns the last element, or `null` if the collection is empty. */ /** * Returns the last element, or `null` if the collection is empty. */ /** * Returns the last element, or `null` if the collection is empty. */ /** * Returns the last element, or `null` if the collection is empty. */ /** * Returns the last element, or `null` if the collection is empty. */ /** * Returns the last element, or `null` if the collection is empty. */ /** * Returns the last element, or `null` if the collection is empty. */ /** * Returns the last element, or `null` if the collection is empty. */ /** * Returns the last element, or `null` if the collection is empty. */ /** * Returns the last element, or `null` if the collection is empty. */ /** * Returns the last element, or `null` if the collection is empty. */ /** * Returns the last element, or `null
{ if ( this.isEmpty() ) { return null } else { return this.first() } } /** * Returns the last element, or `null` if the list is empty. */ fun < T > List < T > . lastOrNull ( ) : T ? lake { if ( this.isEmpty() ) { return null } else { return this.last() } } /** * Returns the size of the list, or `0` if the list is empty. */ fun < T > List < T > . size ( ) : Int ? lake { if ( this.isEmpty() ) { return 0 } else { return this.size() } } /** * Returns the number of elements in the list, or `0` if the list is empty. */ fun < T > List < T > . count ( ) : Int ? lake { if ( this.isEmpty() ) { return 0 } else { return this.count() }
public inline fun < T > Iterable < T > . lastOrNull ( predicate : ( T ) -> Boolean ) : T ? /** * Returns the last element matching the given [predicate], or `null` if element was not found. */ /** * Returns the first element matching the given [predicate], or `null` if element was not found. */ /** * Returns the first element matching the given [predicate], or `null` if element was not found. */ /** * Returns the first element matching the given [predicate], or `null` if element was not found. */ /** * Returns the first element matching the given [predicate], or `null` if element was not found. */ /** * Returns the first element matching the given [predicate], or `null` if element was not found. */ /** * Returns the first element matching the given [predicate], or `null` if element was not found. */ /** * Returns the first element matching the given [predicate], or `null` if element was not found. */ /** * Returns the first element matching the given [

public fun < T > List < T > . get ( index : Int ) : T ? * * @sample samples.collections.Collections.Elements.getOrNull ( index : Int ) : T ? * * @sample samples.collections.Collections.Elements.getOrNull ( index : Int ) : T ? * * @sample samples.collections.Collections.Elements.getOrNull ( index : Int ) : T ? * * @sample samples.collections.Collections.Elements.getOrNull ( index : Int ) : T ? * * @sample samples.collections.Collections.Elements.getOrNull ( index : Int ) : T ? * * @sample samples.collections.Collections.Elements.getOrNull ( index : Int ) : T ? * * @sample samples.collections.Collections.Elements.getOrNull ( index : Int ) : T ? * * @sample samples.collections.Collections.Elements.getOrNull ( index : Int ) : T ? * *
public fun < @ kotlin . internal . OnlyInputTypes T > Iterable < T > . indexOf ( element : T , start : Int = 0 , end : Int = -1 ) : Int /** * Returns last index of [element], or -1 if the collection does not contain element. */ kotlinpublic fun < @ kotlin . internal . OnlyInputTypes T > Iterable < T > . lastIndexOf ( element : T ) : Int /** * Returns first index of [element], or -1 if the collection does not contain element. */ kotlinpublic fun < @ kotlin . internal . OnlyInputTypes T > Iterable < T > . firstIndexOf ( element : T ) : Int /** * Returns last index of [element], or -1 if the collection does not contain element. */ kotlinpublic fun < @ kotlin . internal . OnlyInputTypes T > Iterable < T > . lastIndexOf ( element : T , start : Int = 0 , end : Int = -1 ) : Int /** * Returns first index of [element], or -1 if the collection does not contain element.
{ var index = -1 for ( var i = 0; i < this.size; i++ ) { if ( this[i] == element ) { index = i break } } return index } /** * Returns last index of [element], or -1 if the list does not contain element. */ kotlin@ Suppress ( " kotlin " ) ikey public fun < @ kotlin . internal . OnlyInputTypes T > List < T > . lastIndexOf ( element : T ) : Int ikey { var index = -1 for ( var i = this.size - 1; i >= 0; i-- ) { if ( this[i] == element ) { index = i break } } return index } /** * Returns first index of [element], or -1 if the list does not contain element. */ kotlin@ Suppress ( " kotlin " ) ikey public fun < @ kotlin . internal . OnlyInputTypes T > List < T > . first
{ var index = 0 for ( element in this ) { if ( predicate( element ) ) { return index } index++ } return -1 } /** * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element. */ /** * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element. */ /** * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element. */ /** * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element. */ /** * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element. */ /** * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element. */ /** * Returns index of the last element matching the given [predicate], or -1 if the
{ var index = -1 for ( var i = 0; i < this.size; i++ ) { if ( predicate( this[i] ) ) { index = i break } } return index } /** * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element. */ /** * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element. */ /** * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element. */ /** * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element. */ /** * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element. */ /** * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element. */ /** * Returns index of the last
{ var index = 0 for ( element in this ) { if ( predicate( element ) ) { return index } index++ } return -1 } /** * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element. */ /** * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element. */ /** * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element. */ /** * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element. */ /** * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element. */ /** * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element. */ /** * Returns index of the first element matching the given [predicate], or -1 if the
{ var index = -1 for ( var i = 0; i < this.size; i++ ) { if ( predicate ( this[i] ) ) { index = i } } return index } /** * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element. */ fun < T > List < T > . indexOfFirst ( predicate : ( T ) -> Boolean ) : Int = indexOfLast ( predicate ) /** * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element. */ fun < T > List < T > . indexOfLast ( predicate : ( T ) -> Boolean ) : Int = indexOfLast ( predicate ) /** * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element. */ fun < T > List < T > . indexOfFirst ( predicate : ( T ) -> Boolean ) : Int = indexOfFirst ( predicate ) /** * Returns index of the last
{ if ( this.isEmpty() ) throw NoSuchElementException() return this.last() } /** * Returns the first element. * * @throws NoSuchElementException if the collection is empty. * * @sample samples.collections.Collections.Elements.first */ fun < T > Iterable < T > . first ( ) : T = this.first() /** * Returns the size of the collection. * * @throws NoSuchElementException if the collection is empty. * * @sample samples.collections.Collections.Elements.size */ fun < T > Iterable < T > . size ( ) : Int = this.size() /** * Returns the number of elements in the collection. * * @throws NoSuchElementException if the collection is empty. * * @sample samples.collections.Collections.Elements.count */ fun < T > Iterable < T > . count ( ) : Int = this.count() /** * Returns true if the collection is empty.
{ if ( this.isEmpty() ) throw NoSuchElementException() return this.get( this.size() - 1 ) } /** * Returns the first element. * * @throws NoSuchElementException if the list is empty. * * @sample samples.collections.Collections.Elements.first */ public fun < T > List < T > . first ( ) : T { if ( this.isEmpty() ) throw NoSuchElementException() return this.get( 0 ) } /** * Returns the size of the list. * * @throws NoSuchElementException if the list is empty. * * @sample samples.collections.Collections.Elements.size */ public fun < T > List < T > . size ( ) : Int { if ( this.isEmpty() ) throw NoSuchElementException() return this.size() } /** * Returns the number of elements in the list. * * @throws NoSuchElementException if the list is empty. *
{ @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @
{ if ( this.isEmpty() ) throw NoSuchElementException() return this.get( this.size() - 1 ) } /** * Returns the first element matching the given [predicate]. * * @throws NoSuchElementException if no such element is found. * * @sample samples.collections.Collections.Elements.first */ fun < T > List < T > . first ( predicate : ( T ) -> Boolean ) : T = this.get( 0 ) /** * Returns the last element matching the given [predicate]. * * @throws NoSuchElementException if no such element is found. * * @sample samples.collections.Collections.Elements.last */ fun < T > List < T > . last ( predicate : ( T ) -> Boolean ) : T = this.get( this.size() - 1 ) /** * Returns the first element matching the given [predicate]. * * @throws NoSuchElementException if no such element is found. * * @sample samples.collections.Col
public fun < @ kotlin . internal . OnlyInputTypes T > Iterable < T > . lastIndexOf ( element : T , start : Int = 0 , end : Int = -1 ) : Int /** * Returns first index of [element], or -1 if the collection does not contain element. */ kotlinpublic fun < @ kotlin . internal . OnlyInputTypes T > Iterable < T > . firstIndexOf ( element : T ) : Int /** * Returns last index of [element], or -1 if the collection does not contain element. */ kotlinpublic fun < @ kotlin . internal . OnlyInputTypes T > Iterable < T > . lastIndexOf ( element : T , start : Int = 0 , end : Int = -1 ) : Int /** * Returns first index of [element], or -1 if the collection does not contain element. */ kotlinpublic fun < @ kotlin . internal . OnlyInputTypes T > Iterable < T > . firstIndexOf ( element : T , start : Int = 0 , end : Int = -1 ) : Int /** * Returns last index of
public fun < @ kotlin . internal . OnlyInputTypes T > List < T > . lastIndexOf ( element : T , start : Int , end : Int ) : Int /** * Returns first index of [element], or -1 if the list does not contain element. */ kotlin@ Suppress ( " kotlin" ) ikey public fun < @ kotlin . internal . OnlyInputTypes T > List < T > . firstIndexOf ( element : T ) : Int /** * Returns last index of [element], or -1 if the list does not contain element. */ kotlin@ Suppress ( " kotlin" ) ikey public fun < @ kotlin . internal . OnlyInputTypes T > List < T > . lastIndexOf ( element : T , start : Int , end : Int ) : Int /** * Returns first index of [element], or -1 if the list does not contain element. */ kotlin@ Suppress ( " kotlin" ) ikey public fun < @ kotlin . internal . OnlyInputTypes T > List < T > . firstIndexOf ( element : T
{ if ( this.isEmpty() ) return null return this.last() } /** * Returns the first element, or `null` if the collection is empty. * * @sample samples.collections.Collections.Elements.first */ fun < T > Iterable < T > . firstOrNull ( ) : T ? sip { if ( this.isEmpty() ) return null return this.first() } /** * Returns the last element, or `null` if the collection is empty. * * @sample samples.collections.Collections.Elements.lastOrNull */ fun < T > Iterable < T > . lastOrNullOrNull ( ) : T ? sip { if ( this.isEmpty() ) return null return this.lastOrNull() } /** * Returns the first element, or `null` if the collection is empty. * * @sample samples.collections.Collections.Elements.firstOrNull */ fun < T > Iterable < T > . firstOrNullOrNull ( ) :
{ if ( this.isEmpty() ) { return null } else { return this.last() } } /** * Returns the first element, or `null` if the list is empty. * * @sample samples.collections.Collections.Elements.first */ fun < T > List < T > . firstOrNull ( ) : T ? trickle { if ( this.isEmpty() ) { return null } else { return this.first() } } /** * Returns the first element, or `null` if the list is empty. * * @sample samples.collections.Collections.Elements.head */ fun < T > List < T > . headOrNull ( ) : T ? trickle { if ( this.isEmpty() ) { return null } else { return this.head() } } /** * Returns the last element, or `null` if the list is empty. * * @sample samples.collections.Collections.Element
public inline fun < T > Iterable < T > . last ( predicate : ( T ) -> Boolean ) : T ? */ /** * Returns the last element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.lastOrNull */ /** * Returns the last element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.lastOrNull */ /** * Returns the last element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.lastOrNull */ /** * Returns the last element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.lastOrNull */ /** * Returns the last element matching the given [predicate], or `null` if no such element was found. *
public inline fun < T > List < T > . last ( predicate : ( T ) -> Boolean ) : T ? */ /** * Returns the last element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.lastOrNull */ /** * Returns the last element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.lastOrNull */ /** * Returns the last element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.lastOrNull */ /** * Returns the last element matching the given [predicate], or `null` if no such element was found. * * @sample samples.collections.Collections.Elements.lastOrNull */ /** * Returns the last element matching the given [predicate], or `null` if no such element was found. *
/** * Returns a random element from this collection. * * @throws NoSuchElementException if this collection is empty. */ /** * Returns a random element from this collection. * * @throws NoSuchElementException if this collection is empty. */ /** * Returns a random element from this collection. * * @throws NoSuchElementException if this collection is empty. */ /** * Returns a random element from this collection. * * @throws NoSuchElementException if this collection is empty. */ /** * Returns a random element from this collection. * * @throws NoSuchElementException if this collection is empty. */ /** * Returns a random element from this collection. * * @throws NoSuchElementException if this collection is empty. */ /** * Returns a random element from this collection. * * @throws NoSuchElementException if this collection is empty. */ /** * Returns a random element from this collection. *
{ if ( this.isEmpty() ) throw new NoSuchElementException () ; return this.get ( random.nextInt ( this.size ) ) ; } /** * Returns a random element from this collection using the specified source of randomness. * * @throws NoSuchElementException if this collection is empty. */ /** * Returns a random element from this collection using the specified source of randomness. * * @throws NoSuchElementException if this collection is empty. */ /** * Returns a random element from this collection using the specified source of randomness. * * @throws NoSuchElementException if this collection is empty. */ /** * Returns a random element from this collection using the specified source of randomness. * * @throws NoSuchElementException if this collection is empty. */ /** * Returns a random element from this collection using the specified source of randomness. * * @throws NoSuchElementException if this collection is empty. */ /** * Returns a random element from this collection
/** * Returns a random element from this collection, or `null` if this collection is empty. */ /** * Returns a random element from this collection, or `null` if this collection is empty. */ /** * Returns a random element from this collection, or `null` if this collection is empty. */ /** * Returns a random element from this collection, or `null` if this collection is empty. */ /** * Returns a random element from this collection, or `null` if this collection is empty. */ /** * Returns a random element from this collection, or `null` if this collection is empty. */ /** * Returns a random element from this collection, or `null` if this collection is empty. */ /** * Returns a random element from this collection, or `null` if this collection is empty. */ /** * Returns a random element from this collection, or `null` if this collection is empty. */ /** * Returns a random element from this collection, or `null` if this collection is empty. */ /** * Returns a random element from this collection, or `
/** * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty. */ /** * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty. */ /** * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty. */ /** * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty. */ /** * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty. */ /** * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty. */ /** * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty. */ /** * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty. */ /** * Returns a random
{ try { return this.first() } catch (IndexOutOfBoundsException e) { throw new IndexOutOfBoundsException(e) } } /** * Returns the single element, or throws an exception if the collection is empty or has more than one element. */ /** * Returns the single element, or throws an exception if the collection is empty or has more than one element. */ /** * Returns the single element, or throws an exception if the collection is empty or has more than one element. */ /** * Returns the single element, or throws an exception if the collection is empty or has more than one element. */ /** * Returns the single element, or throws an exception if the collection is empty or has more than one element. */ /** * Returns the single element, or throws an exception if the collection is empty or has more than one element. */ /** * Returns the single element, or throws an exception if the collection is empty or has more than one element. */ /** * Returns the single element, or throws an exception if the collection is empty or has more than
{ try { return this.first() } catch (IndexOutOfBoundsException e) { throw new IndexOutOfBoundsException(e.getMessage()) } } /** * Returns the last element, or throws an exception if the list is empty or has more than one element. */ /** * Returns the single element, or throws an exception if the list is empty or has more than one element. */ /** * Returns the last element, or throws an exception if the list is empty or has more than one element. */ /** * Returns the last element, or throws an exception if the list is empty or has more than one element. */ /** * Returns the last element, or throws an exception if the list is empty or has more than one element. */ /** * Returns the last element, or throws an exception if the list is empty or has more than one element. */ /** * Returns the last element, or throws an exception if the list is empty or has more than one element. */ /** * Returns the last element, or throws an exception if the list is empty or
{ try { return this.filter { predicate( it ) }.first() } catch ( exception: Exception ) { throw exception } } /** * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element. */ /** * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element. */ /** * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element. */ /** * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element. */ /** * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element. */ /** * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element. */ /** * Returns the single element matching the given [predicate], or throws exception if there is no or more
: null /** * Returns single element, or `null` if the collection is empty or has more than one element. */ /** * Returns single element, or `null` if the collection is empty or has more than one element. */ /** * Returns single element, or `null` if the collection is empty or has more than one element. */ /** * Returns single element, or `null` if the collection is empty or has more than one element. */ /** * Returns single element, or `null` if the collection is empty or has more than one element. */ /** * Returns single element, or `null` if the collection is empty or has more than one element. */ /** * Returns single element, or `null` if the collection is empty or has more than one element. */ /** * Returns single element, or `null` if the collection is empty or has more than one element. */ /** * Returns single element, or `null` if the collection is empty or has more than one element. */ /** * Returns single element, or `null` if the collection is empty or ha
{ if ( this.isEmpty() ) return null else return this[0] } /** * Returns single element, or `null` if the list is empty or has more than one element. */ /** * Returns single element, or `null` if the list is empty or has more than one element. */ /** * Returns single element, or `null` if the list is empty or has more than one element. */ /** * Returns single element, or `null` if the list is empty or has more than one element. */ /** * Returns single element, or `null` if the list is empty or has more than one element. */ /** * Returns single element, or `null` if the list is empty or has more than one element. */ /** * Returns single element, or `null` if the list is empty or has more than one element. */ /** * Returns single element, or `null` if the list is empty or has more than one element. */ /** * Returns single element, or `null` if the list is empty or has more than one element.
public inline fun < T > Iterable < T > . firstOrNull ( predicate : ( T ) -> Boolean ) : T ? * Returns the first element matching the given [predicate], or `null` if element was not found or more than one element was found. */ fun < T > Iterable < T > . firstOrNull ( predicate : ( T ) -> Boolean ) : T ? * Returns the first element matching the given [predicate], or `null` if element was not found or more than one element was found. */ fun < T > Iterable < T > . lastOrNull ( predicate : ( T ) -> Boolean ) : T ? * Returns the last element matching the given [predicate], or `null` if element was not found or more than one element was found. */ fun < T > Iterable < T > . lastOrNull ( predicate : ( T ) -> Boolean ) : T ? * Returns the last element matching the given [predicate], or `null` if element was not found or more than one element was found. */ fun < T > Iterable < T > . lastOrNull ( predicate : ( T ) -> Boolean )
throws IllegalArgumentException { if ( n < 0 ) { throw IllegalArgumentException( "drop: n must be non-negative" ); } if ( n < 0 ) { throw IllegalArgumentException( "drop: n must be non-negative" ); } if ( n < 0 ) { throw IllegalArgumentException( "drop: n must be non-negative" ); } if ( n < 0 ) { throw IllegalArgumentException( "drop: n must be non-negative" ); } if ( n < 0 ) { throw IllegalArgumentException( "drop: n must be non-negative" ); } if ( n < 0 ) { throw IllegalArgumentException( "drop: n must be non-negative" ); } if ( n < 0 ) { throw IllegalArgumentException( "drop: n must be non-negative" ); } if ( n < 0 ) { throw IllegalArgumentException( "drop: n must be non-negative" ); }
throw ( n : Int ) : List < T > { if ( n < 0 ) { throw IllegalArgumentException () } if ( n == 0 ) { return this } if ( n == 1 ) { return this } if ( n == 2 ) { return this } if ( n == 3 ) { return this } if ( n == 4 ) { return this } if ( n == 5 ) { return this } if ( n == 6 ) { return this } if ( n == 7 ) { return this } if ( n == 8 ) { return this } if ( n == 9 ) { return this } if ( n == 10 ) { return this } if ( n == 11 ) { return this } if ( n == 12 ) { return this } if ( n == 13 ) { return this
{ @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @
{ var list = mutableListOf< T >() for ( element in this ) { if ( predicate( element ) ) list.add( element ) } return list } /** * Returns a list containing all elements except first elements that satisfy the given [predicate]. * * @sample samples.collections.Collections.Transformations.dropWhile ( predicate : ( T ) -> Boolean ) : List < T >/** * Returns a list containing all elements except first elements that satisfy the given [predicate]. * * @sample samples.collections.Collections.Transformations.dropWhile ( predicate : ( T ) -> Boolean ) : List < T >/** * Returns a list containing all elements except first elements that satisfy the given [predicate]. * * @sample samples.collections.Collections.Transformations.dropWhile ( predicate : ( T ) -> Boolean ) : List < T >/** * Returns a list containing all elements except first elements that satisfy the given [predicate]. * * @sample samples.collections.Collections.Transformations.dropWhile ( predicate : ( T
ter public inline fun < T > Iterable < T > . filter ( predicate : ( T ) -> Boolean ) : Iterable < T > . filter ( predicate : ( T ) -> Boolean ) : Iterable < T > . filter ( predicate : ( T ) -> Boolean ) : Iterable < T > . filter ( predicate : ( T ) -> Boolean ) : Iterable < T > . filter ( predicate : ( T ) -> Boolean ) : Iterable < T > . filter ( predicate : ( T ) -> Boolean ) : Iterable < T > . filter ( predicate : ( T ) -> Boolean ) : Iterable < T > . filter ( predicate : ( T ) -> Boolean ) : Iterable < T > . filter ( predicate : ( T ) -> Boolean ) : Iterable < T > . filter ( predicate : ( T ) -> Boolean ) : Iterable < T > . filter ( predicate : ( T ) -> Boolean ) : Iterable < T > . filter ( predicate : ( T ) -> Boolean ) : Iterable < T > . filter ( predicate : ( T ) -> Boolean ) : Iterable < T > . filter ( predicate : ( T ) -> Boolean ) : Iterable < T > . filter ( predicate : (


public inline fun < reified R > Iterable < * > . filterIsInstance ( ) : List < @ kotlin . internal . NoInfer R > @ kotlin . internal . filterIsInstance ( ) : List < @ kotlin . internal . NoInfer R > @ kotlin . internal . filterIsInstance ( ) : List < @ kotlin . internal . NoInfer R > @ kotlin . internal . filterIsInstance ( ) : List < @ kotlin . internal . NoInfer R > @ kotlin . internal . filterIsInstance ( ) : List < @ kotlin . internal . NoInfer R > @ kotlin . internal . filterIsInstance ( ) : List < @ kotlin . internal . NoInfer R > @ kotlin . internal . filterIsInstance ( ) : List < @ kotlin . internal . NoInfer R > @ kotlin . internal . filterIsInstance ( ) : List < @ kotlin . internal . NoInfer R > @ kotlin . internal . filterIsInstance ( ) : List < @ kotlin . internal . NoInfer R > @ kotlin . internal
( destination ) { return destination.filter { it.isInstanceOf( reified R ) } } /** * Appends all elements that are instances of specified type parameter R to the given [destination]. * * @sample samples.collections.Collections.Filtering.filterNotIsInstanceTo * * @sample samples.collections.Collections.Filtering.filterNotIsInstanceTo * * @sample samples.collections.Collections.Filtering.filterNotIsInstanceTo * * @sample samples.collections.Collections.Filtering.filterNotIsInstanceTo * * @sample samples.collections.Collections.Filtering.filterNotIsInstanceTo * * @sample samples.collections.Collections.Filtering.filterNotIsInstanceTo * * @sample samples.collections.Collections.Filtering.filterNotIsInstanceTo * * @sample samples.collections.Collections.Filtering.filterNotIsInstanceTo * * @sample samples.collections.Collections.Filtering.filterNotIsInstanceTo
ter public inline fun < T > Iterable < T > . filter ( predicate : ( T ) -> Boolean ) : List < T > /** * Returns a list containing all elements matching the given [predicate]. * * @sample samples.collections.Collections.Filtering.filter */ /** * Returns a list containing all elements matching the given [predicate]. * * @sample samples.collections.Collections.Filtering.filter */ /** * Returns a list containing all elements matching the given [predicate]. * * @sample samples.collections.Collections.Filtering.filter */ /** * Returns a list containing all elements matching the given [predicate]. * * @sample samples.collections.Collections.Filtering.filter */ /** * Returns a list containing all elements matching the given [predicate]. * * @sample samples.collections.Collections.Filtering.filter */ /** * Returns a list containing all elements matching the given [predicate]. * * @sample samples.collections.Collections.Filtering.filter
/** * Returns a list containing all elements that are `null`. * * @sample samples.collections.Collections.Filtering.filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull ( ) : List < T ? > . filterNull
NotNullTo ( destination ) : C /** * Appends all elements that are not `null` to the given [destination]. * * @sample samples.collections.Collections.Filtering.filterNotNullTo */ /** * Appends all elements that are not `null` to the given [destination]. * * @sample samples.collections.Collections.Filtering.filterNotNullTo */ /** * Appends all elements that are not `null` to the given [destination]. * * @sample samples.collections.Collections.Filtering.filterNotNullTo */ /** * Appends all elements that are not `null` to the given [destination]. * * @sample samples.collections.Collections.Filtering.filterNotNullTo */ /** * Appends all elements that are not `null` to the given [destination]. * * @sample samples.collections.Collections.Filtering.filterNotNullTo */ /** * Appends all elements that are not `null` to the given [destination].
To ( destination , predicate ) /** * Appends all elements matching the given [predicate] to the given [destination]. * * @sample samples.collections.Collections.Filtering.filterTo */ /** * Appends all elements matching the given [predicate] to the given [destination]. * * @sample samples.collections.Collections.Filtering.filterTo */ /** * Appends all elements matching the given [predicate] to the given [destination]. * * @sample samples.collections.Collections.Filtering.filterTo */ /** * Appends all elements matching the given [predicate] to the given [destination]. * * @sample samples.collections.Collections.Filtering.filterTo */ /** * Appends all elements matching the given [predicate] to the given [destination]. * * @sample samples.collections.Collections.Filtering.filterTo */ /** * Appends all elements matching the given [predicate] to the given [destination]. *
To ( destination , predicate ) /** * Appends all elements matching the given [predicate] to the given [destination]. * * @sample samples.collections.Collections.Filtering.filterTo */ /** * Appends all elements matching the given [predicate] to the given [destination]. * * @sample samples.collections.Collections.Filtering.filterTo */ /** * Appends all elements matching the given [predicate] to the given [destination]. * * @sample samples.collections.Collections.Filtering.filterTo */ /** * Appends all elements matching the given [predicate] to the given [destination]. * * @sample samples.collections.Collections.Filtering.filterTo */ /** * Appends all elements matching the given [predicate] to the given [destination]. * * @sample samples.collections.Collections.Filtering.filterTo */ /** * Appends all elements matching the given [predicate] to the given [destination]. * * @sample
therange ( indices : IntRange ) : List < T > { if ( indices.isEmpty ) { return emptyList() } if ( indices.isEmpty ) { return emptyList() } if ( indices.isEmpty ) { return emptyList() } if ( indices.isEmpty ) { return emptyList() } if ( indices.isEmpty ) { return emptyList() } if ( indices.isEmpty ) { return emptyList() } if ( indices.isEmpty ) { return emptyList() } if ( indices.isEmpty ) { return emptyList() } if ( indices.isEmpty ) { return emptyList() } if ( indices.isEmpty ) { return emptyList() } if ( indices.isEmpty ) { return emptyList() } if ( indices.isEmpty ) { return emptyList() } if ( indices.isEmpty ) { return empty
ter public fun < T > List < T > . slice ( indices : Iterable < Int >, start : Int = 0, end : Int = -1 ) : List < T > { if ( indices.isEmpty() ) { return this } if ( start < 0 ) { start = 0 } if ( end < 0 ) { end = this.size() } if ( start > end ) { throw new IllegalArgumentException() } if ( start < 0 ) { start = 0 } if ( end < 0 ) { end = this.size() } if ( start > end ) { throw new IllegalArgumentException() } if ( start < 0 ) { start = 0 } if ( end < 0 ) { end = this.size() } if ( start > end ) { throw new IllegalArgumentException() } if ( start < 0 ) { start = 0 } if ( end < 0
throws IllegalArgumentException { if ( n < 0 ) { throw IllegalArgumentException( "n must be non-negative" ) } if ( n < 1 ) { throw IllegalArgumentException( "n must be at least 1" ) } if ( n < 0 ) { throw IllegalArgumentException( "n must be non-negative" ) } if ( n < 0 ) { throw IllegalArgumentException( "n must be non-negative" ) } if ( n < 0 ) { throw IllegalArgumentException( "n must be non-negative" ) } if ( n < 0 ) { throw IllegalArgumentException( "n must be non-negative" ) } if ( n < 0 ) { throw IllegalArgumentException( "n must be non-negative" ) } if ( n < 0 ) { throw IllegalArgumentException( "n must be non-negative" ) } if ( n < 0 ) { throw IllegalArgumentException(
{ if ( n < 0 ) { throw IllegalArgumentException () } if ( n > this.size ) { throw IllegalArgumentException () } return this.subList ( this.size - n, this.size ) } /** * Returns a list containing first [n] elements. * * @throws IllegalArgumentException if [n] is negative. * * @sample samples.collections.Collections.Transformations.takeFirst */ fun < T > List < T > . takeFirst ( n : Int ) : List < T > = takeLast ( n ) /** * Returns a list containing last [n] elements. * * @throws IllegalArgumentException if [n] is negative. * * @sample samples.collections.Collections.Transformations.takeLast */ fun < T > List < T > . takeLast ( n : Int ) : List < T > = takeFirst ( n ) /** * Returns a list containing first [n] elements. * * @throws IllegalArg
{ @SuppressWarnings("unchecked") var list = mutableListOf< T >() @SuppressWarnings("unchecked") var last = null @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarning
{ var list = mutableListOf< T >() for ( element in this ) { if ( predicate( element ) ) { list.add( element ) } } return list } /** * Returns a list containing first elements satisfying the given [predicate]. * * @sample samples.collections.Collections.Transformations.takeWhile ( predicate : ( T ) -> Boolean ) : List < T >/** * Returns a list containing first elements satisfying the given [predicate]. * * @sample samples.collections.Collections.Transformations.takeWhile ( predicate : ( T ) -> Boolean ) : List < T >/** * Returns a list containing first elements satisfying the given [predicate]. * * @sample samples.collections.Collections.Transformations.takeWhile ( predicate : ( T ) -> Boolean ) : List < T >/** * Returns a list containing first elements satisfying the given [predicate]. * * @sample samples.collections.Collections.Transformations.takeWhile ( predicate : ( T ) -> Boolean ) : List < T >/**
{ for ( var i = this.size - 1; i >= 0; i-- ) { var temp = this[i]; this[i] = this[0]; this[0] = temp; } } /** * Reverses elements in the list in-place. */ public fun < T > MutableList < T > . reverse ( ) : Unit public { for ( var i = this.size - 1; i >= 0; i-- ) { var temp = this[i]; this[i] = this[0]; this[0] = temp; } } /** * Reverses elements in the list in-place. */ public fun < T > MutableList < T > . reverse ( ) : Unit public { for ( var i = this.size - 1; i >= 0; i-- ) { var temp = this[i]; this[i] = this[0]; this[0] = temp; } } /** * Reverses elements in the list in-place.
{ var list = mutableListOf< T >() for ( element in this ) { list.add( element ) } return list.reversed() } /** * Returns a list with elements in sorted order. */ fun < T > Iterable < T > . sorted ( ) : List < T > ary { var list = mutableListOf< T >() for ( element in this ) { list.add( element ) } list.sort() return list } /** * Returns a list with elements in ascending order. */ fun < T > Iterable < T > . ascending ( ) : List < T > ary { var list = mutableListOf< T >() for ( element in this ) { list.add( element ) } list.sort() return list } /** * Returns a list with elements in descending order. */ fun < T > Iterable < T > . descending ( ) : List < T > ary { var list = mutable
= mutableListOf < T > () { for ( int i = 0; i < this.size; i++ ) { int j = random.nextInt( this.size ); T temp = this.get( i ); this.set( i, this.get( j ) ); this.set( j, temp ); } } } /** * Randomly shuffles elements in this list in-place using the specified [random] instance as the source of randomness. * * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm */ kotlin@ SinceKotlin ( " kotlin" ) kotlin public fun < T > MutableList < T > . shuffle ( random : Random ) : Unit kotlin = mutableListOf < T > () { for ( int i = 0; i < this.size; i++ ) { int j = random.nextInt( this.size ); T temp = this.get(
public inline fun < T , R : Comparable < R > > MutableList < T > . sort ( crossinline selector : ( T ) -> R ? ) : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit
public inline fun < T , R : Comparable < R > > MutableList < T > . sort ( crossinline selector : ( T ) -> R ? ) : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit : Unit
public fun < T : Comparable < T > > MutableList < T > . sortDescending ( ) : Unit asyncfun public fun < T : Comparable < T > > MutableList < T > . sortDescending ( ) : Unit asyncfun public fun < T : Comparable < T > > MutableList < T > . sortDescending ( ) : Unit asyncfun public fun < T : Comparable < T > > MutableList < T > . sortDescending ( ) : Unit asyncfun public fun < T : Comparable < T > > MutableList < T > . sortDescending ( ) : Unit asyncfun public fun < T : Comparable < T > > MutableList < T > . sortDescending ( ) : Unit asyncfun public fun < T : Comparable < T > > MutableList < T > . sortDescending ( ) : Unit asyncfun public fun < T : Comparable < T > > MutableList < T > . sortDescending ( ) : Unit asyncfun public fun < T : Comparable < T > > MutableList < T > . sortDescending ( ) : Unit asyncfun public fun < T : Comparable < T > > Mut
ter public fun < T : Comparable < T > > Iterable < T > . sorted ( ) : List < T > = this /** * Returns a list of all elements sorted according to their natural sort order. * * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting. */ /** * Returns a list of all elements sorted according to their natural sort order. * * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting. */ /** * Returns a list of all elements sorted according to their natural sort order. * * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting. */ /** * Returns a list of all elements sorted according to their natural sort order. * * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting. */ /** * Returns a list of all elements sorted according to their natural sort order. * * The sort is _stable_. It means that equal elements preserve their order relative to

ter ( crossinline selector : ( T ) -> R ? ) ) : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List
terpublic fun < T : Comparable < T > > Iterable < T > . sortedDescending ( ) : List < T > */ /** * Returns a list of all elements sorted ascending according to their natural sort order. * * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting. */ /** * Returns a list of all elements sorted ascending according to their natural sort order. * * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting. */ /** * Returns a list of all elements sorted ascending according to their natural sort order. * * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting. */ /** * Returns a list of all elements sorted ascending according to their natural sort order. * * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting. */ /** * Returns a list of all elements sorted ascending according to their natural sort order. * * The sort is _stable_. It mean
ter public fun < T > Iterable < T > . sorted ( comparator : Comparator < in T > ) : List < T > */ /** * Returns a list of all elements sorted according to the specified [comparator]. * * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting. */ /** * Returns a list of all elements sorted according to the specified [comparator]. * * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting. */ /** * Returns a list of all elements sorted according to the specified [comparator]. * * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting. */ /** * Returns a list of all elements sorted according to the specified [comparator]. * * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting. */ /** * Returns a list of all elements sorted according to the specified [comparator]. * * The sort i
{ return this.toArrayOfBooleans() } /** * Returns an array of Boolean containing all of the elements of this collection. */ fun Collection < Boolean > . toBooleanArray ( ) : BooleanArray /** * Returns an array of Boolean containing all of the elements of this collection. */ fun Collection < Boolean > . toBooleanArray ( ) : BooleanArray /** * Returns an array of Boolean containing all of the elements of this collection. */ fun Collection < Boolean > . toBooleanArray ( ) : BooleanArray /** * Returns an array of Boolean containing all of the elements of this collection. */ fun Collection < Boolean > . toBooleanArray ( ) : BooleanArray /** * Returns an array of Boolean containing all of the elements of this collection. */ fun Collection < Boolean > . toBooleanArray ( ) : BooleanArray /** * Returns an array of Boolean containing all of the elements of this collection. */ fun Collection < Boolean > . toBooleanArray ( ) : BooleanArray /** * Returns an array
{ return this.toByteArray () } /** * Returns an array of String containing all of the elements of this collection. */ public fun Collection < String > . toString () : String [] { return this.toString () } /** * Returns an array of Int containing all of the elements of this collection. */ public fun Collection < Int > . toIntArray () : Int [] { return this.toIntArray () } /** * Returns an array of Float containing all of the elements of this collection. */ public fun Collection < Float > . toFloatArray () : Float [] { return this.toFloatArray () } /** * Returns an array of Double containing all of the elements of this collection. */ public fun Collection < Double > . toDoubleArray () : Double [] { return this.toDoubleArray () } /** * Returns an array of Boolean containing all of the elements of this collection. */ public fun Collection < Boolean > . toBooleanArray () : Boolean [] { return this.toBooleanArray () } /**
{ return this.toList().toCharArray() } /** * Returns an array of Char containing all of the elements of this collection. * @return */ fun Collection < Char > . toList () : List<Char> /** * Returns an array of Char containing all of the elements of this collection. * @return */ fun Collection < Char > . toArray () : Array<Char> /** * Returns an array of Char containing all of the elements of this collection. * @return */ fun Collection < Char > . toSet () : Set<Char> /** * Returns an array of Char containing all of the elements of this collection. * @return */ fun Collection < Char > . toMap () : Map<Char, Char> /** * Returns an array of Char containing all of the elements of this collection. * @return */ fun Collection < Char > . toList () : List<Char> /** * Returns an array of Char containing all of the elements of this collection. * @return */ fun Collection < Char > . toSet () : Set<Char
{ return this.toList().map { it.toDouble() }.toDoubleArray() } /** * Returns an array of Double containing all of the elements of this collection. */ private fun Collection < Double > . toList () : List<Double> /** * Returns an array of Double containing all of the elements of this collection. */ private fun Collection < Double > . toList () : List<Double> /** * Returns an array of Double containing all of the elements of this collection. */ private fun Collection < Double > . toList () : List<Double> /** * Returns an array of Double containing all of the elements of this collection. */ private fun Collection < Double > . toList () : List<Double> /** * Returns an array of Double containing all of the elements of this collection. */ private fun Collection < Double > . toList () : List<Double> /** * Returns an array of Double containing all of the elements of this collection. */ private fun Collection < Double > . toList () : List<Double> /** * Returns an array of Double containing all of the elements of
( ) : FloatArray () { return this.toFloatArray () } /** * Returns an array of Int containing all of the elements of this collection. */ private fun Collection < Int > . toIntArray ( ) : IntArray ( ) : IntArray () { return this.toIntArray () } /** * Returns an array of String containing all of the elements of this collection. */ private fun Collection < String > . toStringArray ( ) : StringArray ( ) : StringArray () { return this.toStringArray () } /** * Returns an array of Boolean containing all of the elements of this collection. */ private fun Collection < Boolean > . toBooleanArray ( ) : BooleanArray ( ) : BooleanArray () { return this.toBooleanArray () } /** * Returns an array of Double containing all of the elements of this collection. */ private fun Collection < Double > . toDoubleArray ( ) : DoubleArray ( ) : DoubleArray () { return this.toDoubleArray () } /** * Returns an array of Float containing all of the elements of
{ return this.toArrayOfInts() } /** * Returns an array of Int containing all of the elements of this collection. */ private fun Collection < Int > . toIntArray ( ) : IntArray private { return this.toArrayOfInts() } /** * Returns an array of Int containing all of the elements of this collection. */ private fun Collection < Int > . toIntArray ( ) : IntArray private { return this.toArrayOfInts() } /** * Returns an array of Int containing all of the elements of this collection. */ private fun Collection < Int > . toIntArray ( ) : IntArray private { return this.toArrayOfInts() } /** * Returns an array of Int containing all of the elements of this collection. */ private fun Collection < Int > . toIntArray ( ) : IntArray private { return this.toArrayOfInts() } /** * Returns an array of Int containing all of the elements of this collection. */ private fun Collection < Int > . toIntArray ( ) : IntArray private {
/** * Returns an array of Double containing all of the elements of this collection. */ doublepublic fun Collection < Double > . toDoubleArray ( ) : DoubleArray ap /** * Returns an array of Float containing all of the elements of this collection. */ floatpublic fun Collection < Float > . toFloatArray ( ) : FloatArray ap /** * Returns an array of Int containing all of the elements of this collection. */ intpublic fun Collection < Int > . toIntArray ( ) : IntArray ap /** * Returns an array of Boolean containing all of the elements of this collection. */ booleanpublic fun Collection < Boolean > . toBooleanArray ( ) : BooleanArray ap /** * Returns an array of Byte containing all of the elements of this collection. */ bytepublic fun Collection < Byte > . toByteArray ( ) : ByteArray ap /** * Returns an array of Short containing all of the elements of this collection. */ shortpublic fun Collection < Short > . toShortArray ( ) : ShortArray ap /** * Returns an array of Integer containing all of the elements of this collection. */ intpublic fun Collection < Integer
() { return this.toShortArray ( ) } /** * Returns an array of Long containing all of the elements of this collection. */ collection public fun Collection < Long > . toLongArray ( ) : LongArray at () { return this.toLongArray ( ) } /** * Returns an array of Float containing all of the elements of this collection. */ collection public fun Collection < Float > . toFloatArray ( ) : FloatArray at () { return this.toFloatArray ( ) } /** * Returns an array of Double containing all of the elements of this collection. */ collection public fun Collection < Double > . toDoubleArray ( ) : DoubleArray at () { return this.toDoubleArray ( ) } /** * Returns an array of Boolean containing all of the elements of this collection. */ collection public fun Collection < Boolean > . toBooleanArray ( ) : BooleanArray at () { return this.toBooleanArray ( ) } /** * Returns an array of String containing all of the elements of this collection. */ collection public fun Collection < String








( destination ) /** * Appends all elements to the given [destination] collection. * * @param destination Collection to append to. */ public fun < T , C : MutableCollection < in T > > Iterable < T > . toCollection ( destination : C ) : C /** * Appends all elements to the given [destination] collection. * * @param destination Collection to append to. */ public fun < T , C : MutableCollection < in T > > Iterable < T > . toCollection ( destination : C ) : C /** * Appends all elements to the given [destination] collection. * * @param destination Collection to append to. */ public fun < T , C : MutableCollection < in T > > Iterable < T > . toCollection ( destination : C ) : C /** * Appends all elements to the given [destination] collection. * * @param destination Collection to append to. */ public fun < T , C : MutableCollection < in T > > Iterable < T > . toCollection ( destination : C ) : C
{ var hashSet = HashSet<T>() for ( element in this ) { hashSet.add( element ) } return hashSet } /** * Returns a new [Set] of all elements. */ setpublic fun < T > Iterable < T > . toSet ( ) : Set<T> { var set = Set<T>() for ( element in this ) { set.add( element ) } return set } /** * Returns a new [List] of all elements. */ listpublic fun < T > Iterable < T > . toList ( ) : List<T> { var list = List<T>() for ( element in this ) { list.add( element ) } return list } /** * Returns a new [Array] of all elements. */ arraypublic fun < T > Iterable < T > . toArray ( ) : Array<T> { var array = Array<T>() for ( element in this ) { array.add( element
{ val list = mutableListOf< T >() list.addAll( this ) return list } /** * Returns a [List] containing all elements. */ fun < T > Iterable < T > . toList ( ) : List < T > igg { val list = mutableListOf< T >() list.addAll( this ) return list } /** * Returns a [List] containing all elements. */ fun < T > Iterable < T > . toList ( ) : List < T > igg { val list = mutableListOf< T >() list.addAll( this ) return list } /** * Returns a [List] containing all elements. */ fun < T > Iterable < T > . toList ( ) : List < T > igg { val list = mutableListOf< T >() list.addAll( this ) return list } /** * Returns a [List] containing all elements. */ fun < T > Iterable < T > . toList (
( ) : MutableList < T > ( ) { return this } /** * Returns a new [MutableList] filled with all elements of this collection. * * @return a new [MutableList] filled with all elements of this collection. */ fun < T > Iterable < T > . toMutableList ( ) : MutableList < T > ( ) { return this } /** * Returns a new [MutableList] filled with all elements of this collection. * * @return a new [MutableList] filled with all elements of this collection. */ fun < T > Iterable < T > . toMutableList ( ) : MutableList < T > ( ) { return this } /** * Returns a new [MutableList] filled with all elements of this collection. * * @return a new [MutableList] filled with all elements of this collection. */ fun < T > Iterable < T > . toMutableList ( ) : MutableList < T > ( ) { return this } /** * Returns a
{ var list = mutableListOf< T >() for ( element in this ) { list.add( element ) } return list } /** * Returns a new [MutableList] filled with all elements of this collection. */ mutableListOf/** * Returns a new [MutableList] filled with all elements of this collection. */ mutableListOf/** * Returns a new [MutableList] filled with all elements of this collection. */ mutableListOf/** * Returns a new [MutableList] filled with all elements of this collection. */ mutableListOf/** * Returns a new [MutableList] filled with all elements of this collection. */ mutableListOf/** * Returns a new [MutableList] filled with all elements of this collection. */ mutableListOf/** * Returns a new [MutableList] filled with all elements of this collection. */ mutableListOf/** * Returns a new [MutableList] filled with all elements of this collection. */ mutableListOf/** * Returns a new [MutableList] filled with all
throw ( ) : Set<T> { return this.toList().toSet() } /** * Returns a [Set] of all elements. * * The returned set preserves the element iteration order of the original collection. */ private fun < T > Iterable < T > . toSet ( ) : Set<T> { return this.toList().toSet() } /** * Returns a [Set] of all elements. * * The returned set preserves the element iteration order of the original collection. */ private fun < T > Iterable < T > . toSet ( ) : Set<T> { return this.toList().toSet() } /** * Returns a [Set] of all elements. * * The returned set preserves the element iteration order of the original collection. */ private fun < T > Iterable < T > . toSet ( ) : Set<T> { return this.toList().toSet() } /** * Returns a [Set] of all elements. * * The returned set preserves the element iteration order of the
/** * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection. * * @sample samples.collections.Collections.Transformations.map * * @sample samples.collections.Collections.Transformations.flatMap * * @sample samples.collections.Collections.Transformations.map * * @sample samples.collections.Collections.Transformations.map * * @sample samples.collections.Collections.Transformations.map * * @sample samples.collections.Collections.Transformations.map * * @sample samples.collections.Collections.Transformations.map * * @sample samples.collections.Collections.Transformations.map * * @sample samples.collections.Collections.Transformations.map * * @sample samples.collections.Collections.Transformations.map * * @sample samples.collections.Collections.Transformations.map * * @sample samples.collections.Collections.Transformation





( destination , transform ) /** * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination]. * * @param destination * @param transform * * @return */ /** * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination]. * * @param destination * @param transform * * @return */ /** * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination]. * * @param destination * @param transform * * @return */ /** * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination]. * * @param destination * @param transform * * @return */ /** * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination]. * * @param






public inline fun < T , R > Iterable < T > . filter ( transform : ( T ) -> Boolean ) : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List
public inline fun < T , R > Iterable < T > . map ( transform : ( index : Int , T ) -> R ) : List < R > */ /** * Returns a list containing the results of applying the given [transform] function * to each element and its index in the original collection. * @param [transform] function that takes the index of an element and the element itself * and returns the result of the transform applied to the element. */ /** * Returns a list containing the results of applying the given [transform] function * to each element and its index in the original collection. * @param [transform] function that takes the index of an element and the element itself * and returns the result of the transform applied to the element. */ /** * Returns a list containing the results of applying the given [transform] function * to each element and its index in the original collection. * @param [transform] function that takes the index of an element and the element itself * and returns the result of the transform applied to the element. */ /** * Returns a list containing the results of applying the given [transform] function * to each element



public inline fun < T , R : Any > Iterable < T > . map ( transform : ( T ) -> R ) : List < R > /** * Returns a list containing only the non-null results of applying the given [filter] function * to each element in the original collection. * * @sample samples.collections.Collections.Transformations.filterNotNull */ /** * Returns a list containing only the non-null results of applying the given [filter] function * to each element in the original collection. * * @sample samples.collections.Collections.Transformations.filterNotNull */ /** * Returns a list containing only the non-null results of applying the given [map] function * to each element in the original collection. * * @sample samples.collections.Collections.Transformations.mapNotNull */ /** * Returns a list containing only the non-null results of applying the given [map] function * to each element in the original collection. * * @sample samples.collections.Collections.Transformations.mapNotNull */ /** *
( destination , transform ) /** * Applies the given [transform] function to each element in the original collection * and appends only the non-null results to the given [destination]. */ /** * Applies the given [transform] function to each element in the original collection * and appends only the non-null results to the given [destination]. */ /** * Applies the given [transform] function to each element in the original collection * and appends only the non-null results to the given [destination]. */ /** * Applies the given [transform] function to each element in the original collection * and appends only the non-null results to the given [destination]. */ /** * Applies the given [transform] function to each element in the original collection * and appends only the non-null results to the given [destination]. */ /** * Applies the given [transform] function to each element in the original collection * and appends only the non-null results to the given [destination]. */ /** * Applies the given [transform] function to each element in
To ( destination , transform ) /** * Applies the given [transform] function to each element of the original collection * and appends the results to the given [destination]. * * @param destination * @param transform */ public inline fun < T , R , C : MutableCollection < in T > > Iterable < T > . mapTo ( destination : C , transform : ( T ) -> R ) : C /** * Applies the given [transform] function to each element of the original collection * and appends the results to the given [destination]. * * @param destination * @param transform */ public inline fun < T , R , C : MutableCollection < in T > > Iterable < T > . mapTo ( destination : C , transform : ( T ) -> R ) : C /** * Applies the given [transform] function to each element of the original collection * and appends the results to the given [destination]. * * @param destination * @param transform */ public inline fun < T , R , C : MutableCollection < in T > > Iterable
{ @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked")


public infix fun < T > Iterable < T > . union ( other : Iterable < T > ) : Set < T > * * Returns a set containing all elements that are contained by both this collection and the specified collection. * * The returned set preserves the element iteration order of the original collection. * * To get a set containing all elements that are contained at least in one of these collections use [union]. */ public infix fun < T > Iterable < T > . intersect ( other : Iterable < T > ) : Set < T > * * Returns a set containing all elements that are contained by both this collection and the specified collection. * * The returned set preserves the element iteration order of the original collection. * * To get a set containing all elements that are contained at least in one of these collections use [union]. */ public infix fun < T > Iterable < T > . union ( other : Iterable < T > ) : Set < T > * * Returns a set containing all elements that are contained by both this collection and the specified collection. * * The returned set preserve
public infix fun < T > Iterable < T > . subtract ( other : Iterable < T > ) : Set < T > = other.subtract ( this ) * * @return a set containing all elements that are contained by this collection and not contained by the specified collection. */ public infix fun < T > Iterable < T > . subtract ( other : Iterable < T > ) : Set < T > = other.subtract ( this ) * * @return a set containing all elements that are contained by this collection and not contained by the specified collection. */ public infix fun < T > Iterable < T > . subtract ( other : Iterable < T > ) : Set < T > = other.subtract ( this ) * * @return a set containing all elements that are contained by this collection and not contained by the specified collection. */ public infix fun < T > Iterable < T > . subtract ( other : Iterable < T > ) : Set < T > = other.subtract ( this ) * * @return a set containing all elements that are contained by this collection and not contained
{ var set = mutableSetOf< T >() for ( element in this ) { if ( ! set.contains( element ) ) { set.add( element ) } } return set } /** * Returns a new [MutableSet] containing all distinct elements from the given collection. * * The returned set preserves the element iteration order of the original collection. */ private fun < T > Iterable < T > . toMutableSet ( ) : MutableSet < T > { var set = mutableSetOf< T >() for ( element in this ) { if ( ! set.contains( element ) ) { set.add( element ) } } return set } /** * Returns a new [MutableSet] containing all distinct elements from the given collection. * * The returned set preserves the element iteration order of the original collection. */ private fun < T > Iterable < T > . toMutableSet ( ) : MutableSet < T > { var set = mutableSetOf


: Boolean { return this.iterator().hasNext() } /** * Returns `true` if collection has at least one element. * * @sample samples.collections.Collections.Aggregates.count */ public fun < T > Iterable < T > . count ( ) : Int { return this.iterator().count() } /** * Returns `true` if collection has at least one element. * * @sample samples.collections.Collections.Aggregates.min */ public fun < T > Iterable < T > . min ( ) : T? { return this.iterator().min() } /** * Returns `true` if collection has at least one element. * * @sample samples.collections.Collections.Aggregates.max */ public fun < T > Iterable < T > . max ( ) : T? { return this.iterator().max() } /** * Returns `true` if collection has at least one element. * * @sample samples.collections.Collections.Aggregate
: Boolean { if ( this.isEmpty() ) { return false } else { return anyWithPredicate( this, predicate ) } } /** * Returns `true` if all elements match the given [predicate]. * * @sample samples.collections.Collections.Aggregates.allWithPredicate */ public inline fun < T > Iterable < T > . allWithPredicate ( predicate : ( T ) -> Boolean ) : Boolean = anyWithPredicate( this, predicate ) /** * Returns `true` if at least one element does not match the given [predicate]. * * @sample samples.collections.Collections.Aggregates.anyWithoutPredicate */ public inline fun < T > Iterable < T > . anyWithoutPredicate ( predicate : ( T ) -> Boolean ) : Boolean = anyWithPredicate( this, predicate ) /** * Returns `true` if all elements do not match the given [predicate]. * * @sample samples.collections.Collections.Aggregates.allWithoutPredicate */ public
() : Int { return this.size() } /** * Returns the first element in this collection. */ fun < T > Iterable < T > . first () : T? { return this.first() } /** * Returns the last element in this collection. */ fun < T > Iterable < T > . last () : T? { return this.last() } /** * Returns the element at the specified index in this collection. */ fun < T > Iterable < T > . get ( index : Int ) : T? { return this.get( index ) } /** * Returns the element at the specified index in this collection. */ fun < T > Iterable < T > . set ( index : Int, value : T ) : T? { return this.set( index, value ) } /** * Returns the element at the specified index in this collection. */ fun < T > Iterable < T > . remove ( index : Int ) : T? { return this.remove( index ) } /** *
{ return this.size() } /** * Returns the first element in this collection. */ ikey@ kotlin . internal . InlineOnly ikey public inline fun < T > Collection < T > . first ( ) : T ikey { return this[0] } /** * Returns the last element in this collection. */ ikey@ kotlin . internal . InlineOnly ikey public inline fun < T > Collection < T > . last ( ) : T ikey { return this[this.size() - 1] } /** * Returns a copy of this collection. */ ikey@ kotlin . internal . InlineOnly ikey public inline fun < T > Collection < T > . copy ( ) : Collection < T > ikey { return this.toList() } /** * Returns a view of this collection. */ ikey@ kotlin . internal . InlineOnly ikey public inline fun < T > Collection < T > . view ( ) : Collection < T > ikey { return this.
{ var count = 0 for ( element in this ) { if ( predicate( element ) ) { count++ } } return count } /** * Returns the first element matching the given [predicate]. */ fun < T > Iterable < T > . first ( predicate : ( T ) -> Boolean ) : T? { for ( element in this ) { if ( predicate( element ) ) { return element } } return null } /** * Returns the last element matching the given [predicate]. */ fun < T > Iterable < T > . last ( predicate : ( T ) -> Boolean ) : T? { for ( element in reversed( this ) ) { if ( predicate( element ) ) { return element } } return null } /** * Returns the first element matching the given [predicate]. */ fun < T > Iterable < T > . firstOf ( predicate : ( T ) -> Boolean ) : T? { for ( element in this ) {




{ for ( var i = 0; i < this.size; i++ ) { action( this[i] ) } } /** * Performs the given [action] on each element. */ fun < T > Iterable < T > . forEach ( action : ( T ) -> Unit ) : Unit { for ( var i = 0; i < this.size; i++ ) { action( this[i] ) } } /** * Performs the given [action] on each element. */ fun < T > Iterable < T > . forEach ( action : ( T ) -> Unit ) : Unit { for ( var i = 0; i < this.size; i++ ) { action( this[i] ) } } /** * Performs the given [action] on each element. */ fun < T > Iterable < T > . forEach ( action : ( T ) -> Unit ) : Unit { for ( var i = 0; i < this.size; i++ ) { action( this[i]

fun Iterable < Double > . min ( ) : Double * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws No
( ) { * * @return the largest element. * * If any of elements is `NaN` returns `NaN`. * * @throws NoSuchElementException if the collection is empty. */ /** * Returns the smallest element. * * If any of elements is `NaN` returns `NaN`. * * @throws NoSuchElementException if the collection is empty. */ /** * Returns the largest element. * * If any of elements is `NaN` returns `NaN`. * * @throws NoSuchElementException if the collection is empty. */ /** * Returns the smallest element. * * If any of elements is `NaN` returns `NaN`. * * @throws NoSuchElementException if the collection is empty. */ /** * Returns the largest element. * * If any of elements is `NaN` returns `NaN`. * * @throws NoSuchElementException if the collection is empty. */ /** * Returns the
* * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. *

@ SinceKotlin ( " lite" ) public inline fun < T , R : Comparable < R > > Iterable < T > . maxByOrNull ( selector : ( T ) -> R ) : T ?








{ if ( ! this.isEmpty() ) { return this.max() } return null } /** * Returns the smallest element or `null` if there are no elements. * * If any of elements is `NaN` returns `NaN`. */ fun Iterable < Double > . minOrNull ( ) : Double ? lava { if ( ! this.isEmpty() ) { return this.min() } return null } /** * Returns the sum of all elements or `null` if there are no elements. * * If any of elements is `NaN` returns `NaN`. */ fun Iterable < Double > . sumOrNull ( ) : Double ? lava { if ( ! this.isEmpty() ) { return this.sum() } return null } /** * Returns the product of all elements or `null` if there are no elements. * * If any of elements is `NaN` returns `NaN`. */ fun Iterable < Double > . productOrNull
{ return this.filter { it != null }.maxOrNull { it } } /** * Returns the smallest element or `null` if there are no elements. * * If any of elements is `NaN` returns `NaN`. */ fun Iterable < Float > . minOrNull ( ) : Float ? Iterable < Float > { return this.filter { it != null }.minOrNull { it } } /** * Returns the sum of all elements or `null` if there are no elements. * * If any of elements is `NaN` returns `NaN`. */ fun Iterable < Float > . sumOrNull ( ) : Float ? Iterable < Float > { return this.filter { it != null }.sumOrNull { it } } /** * Returns the product of all elements or `null` if there are no elements. * * If any of elements is `NaN` returns `NaN`. */ fun Iterable < Float > . productOrNull ( ) : Float ? Iterable < Float > { return this.
/** * Returns the smallest element or `null` if there are no elements. */ /** * Returns the largest element or `null` if there are no elements. */ /** * Returns the largest element or `null` if there are no elements. */ /** * Returns the largest element or `null` if there are no elements. */ /** * Returns the largest element or `null` if there are no elements. */ /** * Returns the largest element or `null` if there are no elements. */ /** * Returns the largest element or `null` if there are no elements. */ /** * Returns the largest element or `null` if there are no elements. */ /** * Returns the largest element or `null` if there are no elements. */ /** * Returns the largest element or `null` if there are no elements. */ /** * Returns the largest element or `null` if there are no elements. */ /** * Returns the largest element or `null` if there are no elements. */ /** * Returns the largest element or `null` if there are



( ) { * * @return the smallest element. * * If any of elements is `NaN` returns `NaN`. * * @throws NoSuchElementException if the collection is empty. * @throws IllegalArgumentException if the collection is empty. * @throws IndexOutOfBoundsException if the collection is empty. * @throws IllegalArgumentException if the collection is empty. * @throws IllegalArgumentException if the collection is empty. * @throws IllegalArgumentException if the collection is empty. * @throws IllegalArgumentException if the collection is empty. * @throws IllegalArgumentException if the collection is empty. * @throws IllegalArgumentException if the collection is empty. * @throws IllegalArgumentException if the collection is empty. * @throws IllegalArgumentException if the collection is empty. * @throws IllegalArgumentException if the collection is empty. * @throws IllegalArgumentException if the collection is empty. * @throws IllegalArgumentException if the collection is empty. * @throws IllegalArgument
* * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. * * @throws NoSuchElementException if the collection is empty. *

@ SinceKotlin ( " lite" )








{ if ( ! this.isEmpty() ) { return this.min() } return null } /** * Returns the largest element or `null` if there are no elements. * * If any of elements is `NaN` returns `NaN`. */ fun Iterable < Double > . maxOrNull ( ) : Double ? lava { if ( ! this.isEmpty() ) { return this.max() } return null } /** * Returns the sum of all elements or `null` if there are no elements. * * If any of elements is `NaN` returns `NaN`. */ fun Iterable < Double > . sumOrNull ( ) : Double ? lava { if ( ! this.isEmpty() ) { return this.sum() } return null } /** * Returns the product of all elements or `null` if there are no elements. * * If any of elements is `NaN` returns `NaN`. */ fun Iterable < Double > . productOrNull
{ if ( ! this.isEmpty() ) { return this.min() } else { return null } } /** * Returns the largest element or `null` if there are no elements. * * If any of elements is `NaN` returns `NaN`. */ fun Iterable < Float > . maxOrNull ( ) : Float ? flow { if ( ! this.isEmpty() ) { return this.max() } else { return null } } /** * Returns the sum of all elements or `null` if there are no elements. * * If any of elements is `NaN` returns `NaN`. */ fun Iterable < Float > . sumOrNull ( ) : Float ? flow { if ( ! this.isEmpty() ) { return this.sum() } else { return null } } /** * Returns the product of all elements or `null` if there are no elements. * * If any of elements is `NaN` returns `Na
/** * Returns the largest element or `null` if there are no elements. */

.minWithOrNull ( comparator ) : null /** * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements. */ /** * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements. */ /** * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements. */ /** * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements. */ /** * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements. */ /** * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements. */ /** * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements. */ /** * Returns the first element having the smallest value according
: Boolean { return this.isEmpty() } /** * Returns `true` if the collection has one element. * * @sample samples.collections.Collections.Aggregates.one */ fun < T > Iterable < T > . one ( ) : Boolean = this.size == 1 /** * Returns `true` if the collection has two elements. * * @sample samples.collections.Collections.Aggregates.two */ fun < T > Iterable < T > . two ( ) : Boolean = this.size == 2 /** * Returns `true` if the collection has three elements. * * @sample samples.collections.Collections.Aggregates.three */ fun < T > Iterable < T > . three ( ) : Boolean = this.size == 3 /** * Returns `true` if the collection has four elements. * * @sample samples.collections.Collections.Aggregates.four */ fun < T > Iterable < T > . four ( ) : Boolean = this.size == 4 /**
: Boolean { if ( this.isEmpty() ) { return true } else if ( predicate( this.first() ) ) { return true } else { return false } } /** * Returns `true` if all elements match the given [predicate]. * * @sample samples.collections.Collections.Aggregates.allWithPredicate */ public inline fun < T > Iterable < T > . allWithPredicate ( predicate : ( T ) -> Boolean ) : Boolean { if ( this.isEmpty() ) { return true } else if ( predicate( this.first() ) ) { return true } else { return false } } /** * Returns `true` if any elements match the given [predicate]. * * @sample samples.collections.Collections.Aggregates.anyWithPredicate */ public inline fun < T > Iterable < T > . anyWithPredicate ( predicate : ( T ) -> Boolean ) : Boolean { if ( this.isEmpty() ) {
( action ( this ) ) /** * Performs the given [action] on each element and returns the collection itself afterwards. */ onEach ( action : ( T ) -> Unit ) : C /** * Performs the given [action] on each element and returns the collection itself afterwards. */ onEach ( action : ( T ) -> Unit ) : C /** * Performs the given [action] on each element and returns the collection itself afterwards. */ onEach ( action : ( T ) -> Unit ) : C /** * Performs the given [action] on each element and returns the collection itself afterwards. */ onEach ( action : ( T ) -> Unit ) : C /** * Performs the given [action] on each element and returns the collection itself afterwards. */ onEach ( action : ( T ) -> Unit ) : C /** * Performs the given [action] on each element and returns the collection itself afterwards. */ onEach ( action : ( T ) -> Unit ) : C /** * Performs the given [action] on each element and returns the collection itself afterwards. */ onEach ( action















( collection : Iterable<T> ) : Int { var sum = 0 for ( element in collection ) { sum += selector( element ) } return sum } /** * Returns the sum of all values produced by [selector] function applied to each element in the collection. */ sumBy ( selector : ( T ) -> Int ) : Int { var sum = 0 for ( element in this ) { sum += selector( element ) } return sum } /** * Returns the sum of all values produced by [selector] function applied to each element in the collection. */ sumBy ( selector : ( T ) -> Int ) : Int { var sum = 0 for ( element in this ) { sum += selector( element ) } return sum } /** * Returns the sum of all values produced by [selector] function applied to each element in the collection. */ sumBy ( selector : ( T ) -> Int ) : Int { var sum = 0 for ( element in this ) { sum += selector( element
{ var sum = 0.0 for ( element in this ) { sum += selector( element ) } return sum } /** * Returns the sum of all values produced by [selector] function applied to each element in the collection. */ sumByDouble ( selector : ( T ) -> Double ) : Double /** * Returns the sum of all values produced by [selector] function applied to each element in the collection. */ sumByDouble ( selector : ( T ) -> Double ) : Double /** * Returns the sum of all values produced by [selector] function applied to each element in the collection. */ sumByDouble ( selector : ( T ) -> Double ) : Double /** * Returns the sum of all values produced by [selector] function applied to each element in the collection. */ sumByDouble ( selector : ( T ) -> Double ) : Double /** * Returns the sum of all values produced by [selector] function applied to each element in the collection. */ sumByDouble ( selector : ( T ) -> Double ) : Double /** * Return





ull ( ) : Iterable<T> { return this.filter { it != null } } /** * Returns an original collection containing all the `null` elements, throwing an [IllegalArgumentException] if there are any `non-null` elements. */ fun < T : Any > Iterable < T ? > . requireNoNulls ( ) : Iterable < T > nullull ( ) : Iterable<T> { return this.filter { it == null } } /** * Returns an original collection containing all the `null` elements, throwing an [IllegalArgumentException] if there are any `non-null` elements. */ fun < T : Any > Iterable < T ? > . requireNoNulls ( ) : Iterable < T > nullull ( ) : Iterable<T> { return this.filter { it == null } } /** * Returns an original collection containing all the `null` elements, throwing an [IllegalArgumentException] if there are any `non-null` elements. */ fun < T : Any > Iterable < T ? > . requireNo
ull ( ) : List < T > /** * Returns an original collection containing all the `null` elements, throwing an [IllegalArgumentException] if there are any `non-null` elements. */ fun < T : Any > List < T ? > . requireNoNulls ( ) : List < T > /** * Returns an original collection containing all the `null` elements, throwing an [IllegalArgumentException] if there are any `non-null` elements. */ fun < T : Any > List < T ? > . requireNoNulls ( ) : List < T > /** * Returns an original collection containing all the `null` elements, throwing an [IllegalArgumentException] if there are any `non-null` elements. */ fun < T : Any > List < T ? > . requireNoNulls ( ) : List < T > /** * Returns an original collection containing all the `null` elements, throwing an [IllegalArgumentException] if there are any `non-null` elements. */ fun < T : Any > List < T ? > . requireNoNulls ( ) :


public operator fun < T > Iterable < T > . minus ( element : T ) : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List
public operator fun < T > Iterable < T > . minus ( elements : Array < out T > ) : List < T > -> List < T > { return this.minus( elements ) } /** * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array. */ private fun < T > Iterable < T > . minus ( elements : Array < out T > ) : List < T > -> List < T > { return this.minus( elements ) } /** * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array. */ private fun < T > Iterable < T > . minus ( elements : Array < out T > ) : List < T > -> List < T > { return this.minus( elements ) } /** * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array. */ private fun < T > Iterable < T > . minus ( elements : Array < out T > ) : List < T > -> List < T > { return thi
public operator fun < T > Iterable < T > . minus ( elements : Iterable < T > ) : List < T > -> List < T > { return this.minus( elements ) } /** * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection. */ public operator fun < T > Iterable < T > . minus ( elements : Iterable < T > ) : List < T > -> List < T > { return this.minus( elements ) } /** * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection. */ public operator fun < T > Iterable < T > . minus ( elements : Iterable < T > ) : List < T > -> List < T > { return this.minus( elements ) } /** * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection. */ public operator fun < T > Iterable < T > . minus ( elements : Iterable < T > ) : List < T > -> List < T
{ return this.filter { it !in elements } } /** * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence. */ fun < T > Iterable < T > . minus ( elements : Sequence < T > ) : List < T > /** * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence. */ fun < T > Iterable < T > . minus ( elements : Sequence < T > ) : List < T > /** * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence. */ fun < T > Iterable < T > . minus ( elements : Sequence < T > ) : List < T > /** * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence. */ fun < T > Iterable < T > . minus ( elements : Sequence < T > ) : List < T > /** * Returns a list containing all elements of the original collection except the elements contained in the given [element
@ kotlin . internal . InlineOnly * Returns a list containing all elements of the original collection without the first occurrence of the given [element]. */ /** * Returns a list containing all elements of the original collection without the first occurrence of the given [element]. */ /** * Returns a list containing all elements of the original collection without the first occurrence of the given [element]. */ /** * Returns a list containing all elements of the original collection without the first occurrence of the given [element]. */ /** * Returns a list containing all elements of the original collection without the first occurrence of the given [element]. */ /** * Returns a list containing all elements of the original collection without the first occurrence of the given [element]. */ /** * Returns a list containing all elements of the original collection without the first occurrence of the given [element]. */ /** * Returns a list containing all elements of the original collection without the first occurrence of the given [element]. */ /** * Returns a list containing all elements of the original collection without the first occurrence of the given [element]. */ /** * Returns a list containing all elements of the original

public operator fun < T > Iterable < T > . plus ( element : T ) : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List
public operator fun < T > Collection < T > . plus ( element : T ) : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T
public operator fun < T > Iterable < T > . minus ( elements : Array < out T > ) : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T
public operator fun < T > Collection < T > . minus ( elements : Array < out T > ) : List < T > */ /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] array. */ /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] array. */ /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] array. */ /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] array. */ /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] array. */ /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] array. */ /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] array. */ /** * Returns a list containing all elements of the original collection and then all
public operator fun < T > Iterable < T > . minus ( elements : Iterable < T > ) : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T > : List < T
public operator fun < T > Collection < T > . minus ( elements : Iterable < T > ) : List < T > */ /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection. */ /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection. */ /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection. */ /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection. */ /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection. */ /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection. */ /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection. */ /** * Returns a list containing all elements of the original collection and then all
public operator fun < T > Iterable < T > . minus ( elements : Sequence < T > ) : List < T > = elements.minus( this ).plus( this ) /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence. */ plus /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence. */ minus /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence. */ plus /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence. */ minus /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence. */ plus /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence. */ minus /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence. */ plus
{ return this + elements } /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence. */ plus( elements : Sequence < T > ) : List < T > /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence. */ plus( elements : Sequence < T > ) : List < T > /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence. */ plus( elements : Sequence < T > ) : List < T > /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence. */ plus( elements : Sequence < T > ) : List < T > /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence. */ plus( elements : Sequence < T > ) : List < T > /** * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence
@ kotlin . internal . InlineOnly * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the
@ kotlin . internal . InlineOnly * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the given [element]. */ /** * Returns a list containing all elements of the original collection and then the


public infix fun < T , R > Iterable < T > . zip ( other : Array < out R > ) : List < Pair < T , R > > = * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

public infix fun < T , R > Iterable < T > . zip ( other : Iterable < R > ) : List < Pair < T , R > > * * @sample samples.collections.Iterables.Operations.zip ( other : Iterable < R > ) : List < Pair < T , R > > * * @sample samples.collections.Iterables.Operations.zip ( other : Iterable < R > ) : List < Pair < T , R > > * * @sample samples.collections.Iterables.Operations.zip ( other : Iterable < R > ) : List < Pair < T , R > > * * @sample samples.collections.Iterables.Operations.zip ( other : Iterable < R > ) : List < Pair < T , R > > * * @sample samples.collections.Iterables.Operations.zip ( other : Iterable < R > ) : List < Pair < T , R > > * * @sample samples.collections.Iterables.Operations.zip ( other : Iterable

{



: Iterable<T> { return this.iterator().asIterable() } /** * Returns this collection as an [ArrayList]. */ kotlin . internal . InlineOnly akell public inline fun < T > ArrayList < T > . asArrayList ( ) : ArrayList < T > akell : ArrayList<T> { return this.iterator().asArrayList() } /** * Returns this collection as an [MutableList]. */ kotlin . internal . InlineOnly akell public inline fun < T > MutableList < T > . asMutableList ( ) : MutableList < T > akell : MutableList<T> { return this.iterator().asMutableList() } /** * Returns this collection as an [MutableSet]. */ kotlin . internal . InlineOnly akell public inline fun < T > MutableSet < T > . asMutableSet ( ) : MutableSet < T > akell : MutableSet<T> { return this.iterator().asMutableSet()
throw ( ) : Sequence < T > { @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @SuppressLint("unchecked") @Supp
{ var sum = 0.0 var count = 0 for ( element in this ) { sum += element count++ } return sum / count } /** * Returns an average value of elements in the collection. */ kotlin . jvm . JvmName ( " kotlin" ) public fun Iterable < Byte > . average ( ) : Double { var sum = 0.0 var count = 0 for ( element in this ) { sum += element count++ } return sum / count } /** * Returns an average value of elements in the collection. */ kotlin . jvm . JvmName ( " jvm" ) public fun Iterable < Byte > . average ( ) : Double { var sum = 0.0 var count = 0 for ( element in this ) { sum += element count++ } return sum / count } /** * Returns an average value of elements in the collection. */ kotlin . jvm
{ var sum = 0.0 var count = 0.0 for ( element in this ) { sum += element count++ } return sum / count } /** * Returns an average value of elements in the collection. */ kotlin . jvm . JvmName ( " kotlin" ) public fun Iterable < Short > . average ( ) : Double kotlin ( ) : Double { var sum = 0.0 var count = 0.0 for ( element in this ) { sum += element count++ } return sum / count } /** * Returns an average value of elements in the collection. */ kotlin . jvm . JvmName ( " kotlin" ) public fun Iterable < Short > . average ( ) : Double kotlin ( ) : Double { var sum = 0.0 var count = 0.0 for ( element in this ) { sum += element count++ } return sum / count } /** * Return
{ var sum = 0 var count = 0 for ( element in this ) { sum += element count++ } if ( count > 0 ) { return sum / count } else { return 0.0 } } /** * Returns an average value of elements in the collection. */ kotlin . jvm . JvmName ( " kotlin" ) ik public fun Iterable < Int > . average ( ) : Double ik { var sum = 0 var count = 0 for ( element in this ) { sum += element count++ } if ( count > 0 ) { return sum / count } else { return 0.0 } } /** * Returns an average value of elements in the collection. */ kotlin . jvm . JvmName ( " java" ) ik public fun Iterable < Int > . average ( ) : Double ik { var sum = 0 var count = 0 for ( element in this ) { sum
{ var sum = 0L var count = 0L for ( element in this ) { sum += element count++ } return sum / count } /** * Returns an average value of elements in the collection. */ kotlin . jvm . JvmName ( " iphone" ) iphone public fun Iterable < Long > . average ( ) : Double iphone { var sum = 0L var count = 0L for ( element in this ) { sum += element count++ } return sum / count } /** * Returns an average value of elements in the collection. */ kotlin . jvm . JvmName ( " android" ) android public fun Iterable < Long > . average ( ) : Double android { var sum = 0L var count = 0L for ( element in this ) { sum += element count++ } return sum / count } /** * Returns an average value of elements in the collection. */ kotlin . jvm .
{ var sum = 0.0f var count = 0.0f for ( element in this ) { sum += element count += 1.0f } return sum / count } /** * Returns an average value of elements in the collection. */ kotlin . jvm . JvmName ( " kotlin" ) ik public fun Iterable < Float > . average ( ) : Double ik { var sum = 0.0f var count = 0.0f for ( element in this ) { sum += element count += 1.0f } return sum / count } /** * Returns an average value of elements in the collection. */ kotlin . jvm . JvmName ( " java" ) ik public fun Iterable < Float > . average ( ) : Double ik { var sum = 0.0f var count = 0.0f for ( element in this ) { sum += element count += 1.0f } return sum / count
{ var sum = 0.0 var count = 0.0 for ( element in this ) { sum += element count++ } return sum / count } /** * Returns an average value of elements in the collection. */ kotlin . jvm . JvmName ( " kotlin" ) ik public fun Iterable < Double > . average ( ) : Double ik { var sum = 0.0 var count = 0.0 for ( element in this ) { sum += element count++ } return sum / count } /** * Returns an average value of elements in the collection. */ kotlin . jvm . JvmName ( " java" ) ik public fun Iterable < Double > . average ( ) : Double ik { var sum = 0.0 var count = 0.0 for ( element in this ) { sum += element count++ } return sum / count } /** * Returns an average value of elements in the collection. *
{ var sum = 0 for ( element in this ) { sum += element } return sum } /** * Returns the product of all elements in the collection. */ kotlin@ kotlin . jvm . JvmName ( " kotlin" ) ike public fun Iterable < Byte > . product ( ) : Int ike { var product = 1 for ( element in this ) { product *= element } return product } /** * Returns the sum of all elements in the collection. */ kotlin@ kotlin . jvm . JvmName ( " kotlin" ) ike public fun Iterable < Byte > . sum ( ) : Int ike { var sum = 0 for ( element in this ) { sum += element } return sum } /** * Returns the product of all elements in the collection. */ kotlin@ kotlin . jvm . JvmName ( " kotlin" ) ike public fun Iterable < Byte > . product ( ) : Int
{ var sum = 0 for ( element in this ) { sum += element } return sum } /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */
{ var sum = 0 for ( element in this ) { sum += element } return sum } /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */ /** * Returns the average of all elements in the collection. */
{ var sum = 0L for ( element in this ) { sum += element } return sum } /** * Returns the product of all elements in the collection. */ kotlin . jvm . JvmName ( " kotlin" ) kotlin public fun Iterable < Long > . product ( ) : Long kotlin { var product = 1L for ( element in this ) { product *= element } return product } /** * Returns the average of all elements in the collection. */ kotlin . jvm . JvmName ( " kotlin" ) kotlin public fun Iterable < Long > . average ( ) : Long kotlin { var average = 0L for ( element in this ) { average += element } return average / this.size() } /** * Returns the maximum of all elements in the collection. */ kotlin . jvm . JvmName ( " kotlin" ) kotlin public fun Iterable < Long > . max ( )
{ var sum = 0.0f for ( element in this ) { sum += element } return sum } /** * Returns the product of all elements in the collection. */ kotlin . jvm . JvmName ( " kotlin" ) kotlin public fun Iterable < Float > . product ( ) : Float kotlin { var product = 1.0f for ( element in this ) { product *= element } return product } /** * Returns the average of all elements in the collection. */ kotlin . jvm . JvmName ( " kotlin" ) kotlin public fun Iterable < Float > . average ( ) : Float kotlin { var average = 0.0f for ( element in this ) { average += element } return average / this.size() } /** * Returns the maximum of all elements in the collection. */ kotlin . jvm . JvmName ( " kotlin" ) kotlin public fun Iterable
{ var sum = 0.0 for ( element in this ) { sum += element } return sum } /** * Returns the product of all elements in the collection. */ kotlin@ kotlin . jvm . JvmName ( " kotlin" ) public fun Iterable < Double > . product ( ) : Double { var product = 1.0 for ( element in this ) { product *= element } return product } /** * Returns the average of all elements in the collection. */ kotlin@ kotlin . jvm . JvmName ( " kotlin" ) public fun Iterable < Double > . average ( ) : Double { var sum =
ardelivered = false * * This is a special `send(e)` implementation that returns `true` if the element * has been successfully sent, and `false` if the channel is closed. * * In case of coroutine cancellation, the element may be undelivered -- * the [onUndeliveredElement] feature is unsupported in this implementation. * */ /** * This is a special `send(e)` implementation that returns `true` if the element * has been successfully sent, and `false` if the channel is closed. * * In case of coroutine cancellation, the element may be undelivered -- * the [onUndeliveredElement] feature is unsupported in this implementation. * */ /** * This is a special `send(e)` implementation that returns `true` if the element * has been successfully sent, and `false` if the channel is closed. * * In case of coroutine cancellation, the element may be undelivered -- * the [onUndeliveredElement] feature is unsupported in this implementation. * */ /** * This is a special

ender ( segment , index , element , s , waiter , closed ) : Int /** * Updates the working cell of an abstract receive operation. */ private fun updateCellReceiveSlow ( segment : ChannelSegment < E > , index : Int , element : E , s : Long , waiter : Any ? , closed : Boolean ) : Int /** * Updates the working cell of an abstract send operation. */ private fun updateCellSendFast ( segment : ChannelSegment < E > , index : Int , element : E , s : Long , waiter : Any ? , closed : Boolean ) : Int /** * Updates the working cell of an abstract receive operation. */ private fun updateCellReceiveFast ( segment : ChannelSegment < E > , index : Int , element : E , s : Long , waiter : Any ? , closed : Boolean ) : Int /** * Updates the working cell of an abstract send operation. */ private fun updateCellSendFast ( segment : ChannelSegment < E > , index : Int , element : E , s : Long , waiter : Any ? , closed : Boolean ) : Int

{ if ( curSenders == 0 ) { return true } if ( curSenders == 1 ) { return false } if ( curSenders == 2 ) { return false } if ( curSenders == 3 ) { return false } if ( curSenders == 4 ) { return false } if ( curSenders == 5 ) { return false } if ( curSenders == 6 ) { return false } if ( curSenders == 7 ) { return false } if ( curSenders == 8 ) { return false } if ( curSenders == 9 ) { return false } if ( curSenders == 10 ) { return false } if ( curSenders == 11 ) { return false } if ( curSenders == 12 ) { return false } if ( curSenders == 13 ) { return false } if

{ if ( element == null ) { return false; } try { return true; } catch ( Exception e ) { return false; } } /** * Resumes this receiver with the specified [element] as a result. * Returns `true` on success and `false` otherwise. */ tryResumeReceiver ( element : E ) : Boolean /** * Resumes this receiver with the specified [element] as a result. * Returns `true` on success and `false` otherwise. */ tryResumeReceiver ( element : E ) : Boolean /** * Resumes this receiver with the specified [element] as a result. * Returns `true` on success and `false` otherwise. */ tryResumeReceiver ( element : E ) : Boolean /** * Resumes this receiver with the specified [element] as a result. * Returns `true` on success and `false` otherwise. */ tryResumeReceiver ( element : E ) : Boolean /** * Resumes this receiver with the specified [element] as a result. * Return
{ /* * This function is invoked when a receiver is added as a waiter in this channel. */ } /** * This function is invoked when a receiver is added as a waiter in this channel. */ /** * This function is invoked when a receiver is added as a waiter in this channel. */ /** * This function is invoked when a receiver is added as a waiter in this channel. */ /** * This function is invoked when a receiver is added as a waiter in this channel. */ /** * This function is invoked when a receiver is added as a waiter in this channel. */ /** * This function is invoked when a receiver is added as a waiter in this channel. */ /** * This function is invoked when a receiver is added as a waiter in this channel. */ /** * This function is invoked when a receiver is added as a waiter in this channel. */ /** * This function is invoked when a receiver is added as a waiter in this channel. */ /** * This function is invoked when a receiver is added as a waiter in this channel.
closed ( ) * * This function is invoked when a waiting receiver is no longer stored in this channel; * independently on whether it is caused by rendezvous, cancellation, or channel closing. */ /** * This function is invoked when a waiting receiver is no longer stored in this channel; * independently on whether it is caused by rendezvous, cancellation, or channel closing. */ /** * This function is invoked when a waiting receiver is no longer stored in this channel; * independently on whether it is caused by rendezvous, cancellation, or channel closing. */ /** * This function is invoked when a waiting receiver is no longer stored in this channel; * independently on whether it is caused by rendezvous, cancellation, or channel closing. */ /** * This function is invoked when a waiting receiver is no longer stored in this channel; * independently on whether it is caused by rendezvous, cancellation, or channel closing. */ /** * This function is invoked when a waiting receiver is no longer stored in this channel; * independently on whether it is caused by rendezvous, cancellation, or channel closing. */ /** * This function i
protected { if ( globalCellIndex < 0 ) throw new IllegalArgumentException( "dropFirstElementUntilTheSpecifiedCellIsInTheBuffer: globalCellIndex < 0" ) if ( globalCellIndex >= this.size() ) throw new IllegalArgumentException( "dropFirstElementUntilTheSpecifiedCellIsInTheBuffer: globalCellIndex >= this.size()" ) if ( globalCellIndex < 0 ) throw new IllegalArgumentException( "dropFirstElementUntilTheSpecifiedCellIsInTheBuffer: globalCellIndex < 0" ) if ( globalCellIndex >= this.size() ) throw new IllegalArgumentException( "dropFirstElementUntilTheSpecifiedCellIsInTheBuffer: globalCellIndex >= this.size()" ) if ( globalCellIndex < 0 ) throw new IllegalArgumentException( "dropFirstElementUntilTheSpecifiedCellIsInTheBuffer: globalCellIndex < 0" ) if ( globalCellIndex >= this.size() ) throw new IllegalArgumentException( "dropFirstElementUntilTheSpecifiedCellIsInTheBuffer: globalCellIndex >= this.size()" ) if ( globalCellIndex



* Invoked when channel is closed as the last action of [close] invocation. * This method should be idempotent and can be called multiple times. */ /** * Invoked when channel is closed as the last action of [close] invocation. * This method should be idempotent and can be called multiple times. */ /** * Invoked when channel is closed as the last action of [close] invocation. * This method should be idempotent and can be called multiple times. */ /** * Invoked when channel is closed as the last action of [close] invocation. * This method should be idempotent and can be called multiple times. */ /** * Invoked when channel is closed as the last action of [close] invocation. * This method should be idempotent and can be called multiple times. */ /** * Invoked when channel is closed as the last action of [close] invocation. * This method should be idempotent and can be called multiple times. */ /** * Invoked when channel is closed as the last action of [close]

CloseHandler () { if ( this.closeHandler != null ) { this.closeHandler.invoke() this.closeHandler = null } } /** * Invokes the installed open handler, * updating the [openHandler] state correspondingly. */ kvprivate fun invokeOpenHandler ( ) kvopenHandler () { if ( this.openHandler != null ) { this.openHandler.invoke() this.openHandler = null } } /** * Invokes the installed close handler, * updating the [closeHandler] state correspondingly. */ kvprivate fun invokeCloseHandler ( ) kvcloseHandler () { if ( this.closeHandler != null ) { this.closeHandler.invoke() this.closeHandler = null } } /** * Invokes the installed open handler, * updating the [openHandler] state correspondingly. */ kvprivate fun invokeOpenHandler ( ) kvopenHandler () { if ( this.openHandler != null ) { this.openHandler.invoke() this.openHandler
private { if ( this.isClosed ) { this.isClosed = true } else { this.isClosed = false } } /** * Marks this channel as closed. * In case [cancelImpl] has already been invoked, * and this channel is marked with [CLOSE_STATUS_CANCELLATION_STARTED], * this function marks the channel as cancelled. * * All operation that notice this channel in the closed state, * must help to complete the closing via [completeCloseOrCancel]. */ private fun markClosed ( ) : Unit private { if ( this.isClosed ) { this.isClosed = true } else { this.isClosed = false } } /** * Marks this channel as closed. * In case [cancelImpl] has already been invoked, * and this channel is marked with [CLOSE_STATUS_CANCELLATION_STARTED], * this function marks the channel as cancelled. * * All operation that notice this channel in the closed state,
/** * Marks this channel as cancelled. * * All operation that notice this channel in the cancelled state, * must help to complete the cancellation via [completeCloseOrCancel]. */ private fun markCancelled ( ) : Unit /** * Marks this channel as cancelled. * * All operation that notice this channel in the cancelled state, * must help to complete the cancellation via [completeCloseOrCancel]. */ private fun markCancelled ( ) : Unit /** * Marks this channel as cancelled. * * All operation that notice this channel in the cancelled state, * must help to complete the cancellation via [completeCloseOrCancel]. */ private fun markCancelled ( ) : Unit /** * Marks this channel as cancelled. * * All operation that notice this channel in the cancelled state, * must help to complete the cancellation via [completeCloseOrCancel]. */ private fun markCancelled ( ) : Unit /** * Marks this channel as cancelled. * * All operation that notice this channel in the cancelled state, * must help to complete the cancellation via [completeCloseOrC
( ) { if ( isCancellationStarted ) { cancellationStarted = false } else { cancellationStarted = true } } /** * When the cancellation procedure starts, it is critical * to mark the closing status correspondingly. Thus, other * operations, which may help to complete the cancellation, * always correctly update the status to `CANCELLED`. */ private fun markCancellationStarted ( ) : Unit private( ) { if ( isCancellationStarted ) { cancellationStarted = false } else { cancellationStarted = true } } /** * When the cancellation procedure starts, it is critical * to mark the closing status correspondingly. Thus, other * operations, which may help to complete the cancellation, * always correctly update the status to `CANCELLED`. */ private fun markCancellationStarted ( ) : Unit private( ) { if ( isCancellationStarted ) { cancellationStarted = false
( ) = { if ( isClosed ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) { if ( isCanceled ) {
: ChannelSegment < E > { if ( sendersCur == 0 ) { return null } if ( sendersCur < 0 ) { return null } if ( sendersCur == 1 ) { return null } if ( sendersCur == 2 ) { return null } if ( sendersCur == 3 ) { return null } if ( sendersCur == 4 ) { return null } if ( sendersCur == 5 ) { return null } if ( sendersCur == 6 ) { return null } if ( sendersCur == 7 ) { return null } if ( sendersCur == 8 ) { return null } if ( sendersCur == 9 ) { return null } if ( sendersCur == 10 ) { return null } if ( sendersCur == 11 ) { return null } if ( sendersCur == 12 ) { return
: Long { if ( sendersCur == 0 ) { return sendersCur } else { sendersCur = sendersCur - 1 if ( sendersCur < 0 ) { sendersCur = 0 } else { sendersCur = sendersCur - 1 } return completeCancel ( sendersCur ) } } /** * Completes the channel reset procedure. */ private fun completeReset ( sendersCur : Long ) : Long { if ( sendersCur == 0 ) { return sendersCur } else { sendersCur = sendersCur - 1 if ( sendersCur < 0 ) { sendersCur = 0 } else { sendersCur = sendersCur - 1 } return completeReset ( sendersCur ) } } /** * Completes the channel reset procedure. */ private fun completeReset ( sendersCur : Long ) : Long { if ( sendersCur == 0 ) { return sendersCur
: LinkedList< ChannelSegment < E > > { val list = LinkedList< ChannelSegment < E > >() list.add( this ) return list } /** * Adds a new segment to the underlying linked list of segments for further segment addition. * * @param newSegment The new segment to add. */ private fun addSegment ( newSegment : ChannelSegment < E > ) : LinkedList< ChannelSegment < E > > { val list = LinkedList< ChannelSegment < E > >() list.add( this ) list.add( newSegment ) return list } /** * Adds a new segment to the underlying linked list of segments for further segment addition. * * @param newSegment The new segment to add. */ private fun addSegment ( newSegment : ChannelSegment < E > ) : LinkedList< ChannelSegment < E > > { val list = LinkedList< ChannelSegment < E > >() list.add( this ) list.add( newSeg

private { if ( lastSegment == null ) { return } if ( lastSegment.isEmpty() ) { return } if ( lastSegment.size() == 1 ) { return } if ( lastSegment.size() == 2 ) { return } if ( lastSegment.size() == 3 ) { return } if ( lastSegment.size() == 4 ) { return } if ( lastSegment.size() == 5 ) { return } if ( lastSegment.size() == 6 ) { return } if ( lastSegment.size() == 7 ) { return } if ( lastSegment.size() == 8 ) { return } if ( lastSegment.size() == 9 ) { return } if ( lastSegment.size() == 10 ) { return } if ( lastSegment.size() == 11 ) { return
q : Queue<ChannelSegment < E > > = Queue<ChannelSegment < E > >() { if ( sendersCounter == 0 ) { cancelSuspendedReceiveRequests( lastSegment , sendersCounter - 1 ) } else { cancelSuspendedReceiveRequests( lastSegment , sendersCounter - 1 ) cancelSuspendedReceiveRequests( lastSegment , sendersCounter - 1 ) cancelSuspendedReceiveRequests( lastSegment , sendersCounter - 1 ) cancelSuspendedReceiveRequests( lastSegment , sendersCounter - 1 ) cancelSuspendedReceiveRequests( lastSegment , sendersCounter - 1 ) cancelSuspendedReceiveRequests( lastSegment , sendersCounter - 1 ) cancelSuspendedReceiveRequests( lastSegment , sendersCounter - 1 ) cancelSuspendedReceiveRequests( lastSegment , sendersCounter - 1 ) cancelSuspendedReceiveRequ
private fun Waiter . resumeReceiverOnCancelledChannel ( ) /** * Resumes this receiver because this channel is closed. * This function does not take any effect if the operation has already been resumed or cancelled. */ waiter private fun Waiter . resumeReceiverOnClosedChannel ( ) /** * Resumes this receiver because this channel is closed. * This function does not take any effect if the operation has already been resumed or cancelled. */ waiter private fun Waiter . resumeReceiverOnCancelledChannel ( ) /** * Resumes this receiver because this channel is closed. * This function does not take any effect if the operation has already been resumed or cancelled. */ waiter private fun Waiter . resumeReceiverOnClosedChannel ( ) /** * Resumes this receiver because this channel is closed. * This function does not take any effect if the operation has already been resumed or cancelled. */ waiter private fun Waiter . resumeReceiverOnClosedChannel ( ) /** * Resumes this receiver because this channel is closed. * This function does not take any effect if the operation has already been resumed or cancelled. *
: Waiter = this /** * Resumes this sender because this channel is cancelled. * This function does not take any effect if the operation has already been resumed or cancelled. */ waitprivate fun Waiter . resumeSenderOnCancelledChannel ( ) : Waiter = this /** * Resumes this sender because this channel is cancelled. * This function does not take any effect if the operation has already been resumed or cancelled. */ waitprivate fun Waiter . resumeSenderOnCancelledChannel ( ) : Waiter = this /** * Resumes this sender because this channel is cancelled. * This function does not take any effect if the operation has already been resumed or cancelled. */ waitprivate fun Waiter . resumeSenderOnCancelledChannel ( ) : Waiter = this /** * Resumes this sender because this channel is cancelled. * This function does not take any effect if the operation has already been resumed or cancelled. */ waitprivate fun Waiter . resumeSenderOnCancelledChannel ( ) : Waiter = this /** * Resumes this sender because this channel is cancelled. * This function does not take any
le = false * * @return true iff this channel contains elements to retrieve. */ fun hasElements ( ) : Boolean = this.receivers > 0 /** * Returns the number of elements in this channel. * * @return the number of elements in this channel. */ fun size ( ) : Int = this.receivers /** * Returns the number of active elements in this channel. * * @return the number of active elements in this channel. */ fun active ( ) : Int = this.receivers /** * Returns the number of elements in this channel. * * @return the number of elements in this channel. */ fun size ( ) : Int = this.receivers /** * Returns the number of active elements in this channel. * * @return the number of active elements in this channel. */ fun active ( ) : Int = this.receivers /** * Returns the number of elements in this channel. * * @return the number of elements in this channel. */ fun size ( ) : Int = this.rece



private fun findSegmentBufferStart ( id : Long , startFrom : ChannelSegment < E > , currentBufferStartCounter : Long ) : ChannelSegment < E > ? * * @param id * @param startFrom * @param currentBufferEndCounter * @return */ private fun findSegmentBufferStart ( id : Long , startFrom : ChannelSegment < E > , currentBufferStartCounter : Long ) : ChannelSegment < E > ? private fun findSegmentBufferEnd ( id : Long , startFrom : ChannelSegment < E > , currentBufferEndCounter : Long ) : ChannelSegment < E > ? /** * @param id * @param startFrom * @param currentBufferStartCounter * @param currentBufferEndCounter * @return */ private fun expandBuffer ( id : Long , startFrom : ChannelSegment < E > , currentBufferStartCounter : Long , currentBufferEndCounter : Long ) : ChannelSegment < E > ? private fun expandBuffer ( id : Long , startFrom : ChannelSegment < E > , currentBufferStartCounter : Long , currentBufferEndCounter : Long ) : ChannelSegment
private { if ( startFrom == null ) { startFrom = this.bufferEndSegment } if ( startFrom == this.bufferEndSegment ) { startFrom = this.bufferStartSegment } if ( startFrom == this.bufferStartSegment ) { startFrom = this.bufferEndSegment } if ( startFrom == this.bufferEndSegment ) { startFrom = this.bufferStartSegment } if ( startFrom == this.bufferStartSegment ) { startFrom = this.bufferEndSegment } if ( startFrom == this.bufferEndSegment ) { startFrom = this.bufferStartSegment } if ( startFrom == this.bufferStartSegment ) { startFrom = this.bufferEndSegment } if ( startFrom == this.bufferEndSegment ) { startFrom = this.bufferStartSegment } if ( startFrom == this.bufferStartSegment ) { startFrom = this.bufferEndSegment
private { if ( this.senders < value ) { this.senders = value; } } /** * Updates the `receivers` counter if its value * is lower that the specified one. * * Receivers use this function to efficiently skip * a sequence of cancelled senders. */ private fun updateReceiversCounterIfLower ( value : Long ) : Unit receiverprivate { if ( this.receivers < value ) { this.receivers = value; } } /** * Updates the `senders` counter if its value * is lower that the specified one. * * Senders use this function to efficiently skip * a sequence of cancelled senders. */ private fun updateSendersCounterIfLower ( value : Long ) : Unit sendersprivate { if ( this.senders < value ) { this.senders = value; } } /** * Updates the `receivers` counter if its value * is lower that the specified one. * * Receivers use this function to efficiently skip *
: Unit = { if ( this.receiversCounter < value ) { this.receiversCounter = value } } /** * Updates the `senders` counter if its value * is lower that the specified one. * * Senders use this function to efficiently skip * a sequence of cancelled senders. * * Senders use this function to efficiently skip * a sequence of cancelled senders. * * Senders use this function to efficiently skip * a sequence of cancelled senders. * * Senders use this function to efficiently skip * a sequence of cancelled senders. * * Senders use this function to efficiently skip * a sequence of cancelled senders. * * Senders use this function to efficiently skip * a sequence of cancelled senders. * * Senders use this function to efficiently skip * a sequence of cancelled senders. * * Senders use this function to efficiently skip * a sequence of cancelled senders. * * Senders use this function to efficiently skip * a sequence of cancelled senders. * * Senders use this function to
. * * Invokes `onSlotCleaned()` preceded by a `waitExpandBufferCompletion(..)` call * in case the cancelled request is receiver. * * Invokes `onSlotCleaned()` preceded by a `waitExpandBufferCompletion(..)` call * in case the cancelled request is receiver. * * Invokes `onSlotCleaned()` preceded by a `waitExpandBufferCompletion(..)` call * in case the cancelled request is receiver. * * Invokes `onSlotCleaned()` preceded by a `waitExpandBufferCompletion(..)` call * in case the cancelled request is receiver. * * Invokes `onSlotCleaned()` preceded by a `waitExpandBufferCompletion(..)` call * in case the cancelled request is receiver. * * Invokes `onSlotCleaned()` preceded by a `waitExpandBufferCompletion(..)` call * in case the cancelled request is receiver. * * Invokes `onSlotCleaned()` preceded by a `waitExpandBufferCompletion(..)`
: CancellableContinuation<T> { if ( value == null ) return CancellableContinuation<T>() if ( onCancellation != null ) { onCancellation( cause ) return CancellableContinuation<T>() } else { return CancellableContinuation<T>() } } /** * Tries to resume this continuation with the specified * value. Returns `true` on success and `false` on failure. */ private fun < T > CancellableContinuation < T > . tryResume1 ( value : T , onCancellation : ( ( cause : Throwable ) -> Unit ) ? = null ) : CancellableContinuation<T> { if ( value == null ) return CancellableContinuation<T>() if ( onCancellation != null ) { onCancellation( cause ) return CancellableContinuation<T>() } else { return CancellableContinuation<T>() } } /** * Tries to resume thi
{ if ( array.isNullOrEmpty() ) { return ByteString.empty() } else if ( array.size == 0 ) { return ByteString.empty() } else if ( array.size == 1 ) { return ByteString( array[0] ) } else if ( array.size == 2 ) { return ByteString( array[0], array[1] ) } else if ( array.size == 3 ) { return ByteString( array[0], array[1], array[2] ) } else if ( array.size == 4 ) { return ByteString( array[0], array[1], array[2], array[3] ) } else if ( array.size == 5 ) { return ByteString( array[0], array[1], array[2], array[3], array[4] ) } else if ( array.size == 6 ) { return ByteString( array[0], array[1], array[2], array[3], array[4], array[5] ) } else if ( array.size
public inline fun withByteArraySafe ( byteString : ByteString , block : ( ByteArray ) -> Unit ) : Unit = if ( byteString.isEmpty() ) return if ( byteString.isNullOrBlank() ) return if ( byteString.isBlank() ) return if ( byteString.length() == 0 ) return if ( byteString.length() == 1 ) return if ( byteString.length() == 2 ) return if ( byteString.length() == 3 ) return if ( byteString.length() == 4 ) return if ( byteString.length() == 5 ) return if ( byteString.length() == 6 ) return if ( byteString.length() == 7 ) return if ( byteString.length() == 8 ) return if ( byteString.length() == 9 ) return if ( byteString.length() == 10 ) return if ( byteString.length() == 11 ) return if (
. appendLine ( value : Byte ) : StringBuilder /** Appends [value] to this [StringBuilder], followed by a line feed character (`\n`) */ /** Appends [value] to this [StringBuilder], followed by a line feed character (`\n`) */ /** Appends [value] to this [StringBuilder], followed by a line feed character (`\n`) */ /** Appends [value] to this [StringBuilder], followed by a line feed character (`\n`) */ /** Appends [value] to this [StringBuilder], followed by a line feed character (`\n`) */ /** Appends [value] to this [StringBuilder], followed by a line feed character (`\n`) */ /** Appends [value] to this [StringBuilder], followed by a line feed character (`\n`) */ /** Appends [value] to this [StringBuilder], followed by a line feed character (`\n`) */ /** Appends [value] to this [StringBuilder], followed by a line feed character (`\n`) */
. appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine ( value : Short ) : StringBuilder . appendLine
. appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine ( value : Int ) : StringBuilder . appendLine
. appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine ( value : Long ) : StringBuilder . appendLine
. appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine ( value : Float ) : StringBuilder . appendLine
. appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine ( value : Double ) : StringBuilder . appendLine
ondef ( function : SimpleFunctionDescriptor ) : Boolean { if ( isDeclaredFunctionAvailable ( function ) ) { return true; } else { return false; } } /** * Can be overridden to filter specific declared variables. Not called on non-declared variables. */ vardeclared open fun isDeclaredVariableAvailable ( variable : SimpleVariableDescriptor ) : Boolean { if ( isDeclaredVariableAvailable ( variable ) ) { return true; } else { return false; } } /** * Can be overridden to filter specific declared functions. Not called on non-declared functions. */ vardeclared open fun isDeclaredFunctionAvailable ( function : SimpleFunctionDescriptor ) : Boolean { if ( isDeclaredFunctionAvailable ( function ) ) { return true; } else { return false; } } /** * Can be overridden to filter specific declared variables. Not called on non-declared variable
protected * * This function has the next contract: * * It can only add to the end of the [functions] list and shall not modify it otherwise (e.g. remove from it). * Before the call, [functions] should already contain all declared functions with the [name] name. */ /** * This function has the next contract: * * It can only add to the end of the [functions] list and shall not modify it otherwise (e.g. remove from it). * Before the call, [functions] should already contain all declared functions with the [name] name. */ /** * This function has the next contract: * * It can only add to the end of the [functions] list and shall not modify it otherwise (e.g. remove from it). * Before the call, [functions] should already contain all declared functions with the [name] name. */ /** * This function has the next contract: * * It can only add to the end of the [functions] list and shall not modify it otherwise (e.g. remove from it).
protected { if ( descriptors == null ) { descriptors = new MutableList < PropertyDescriptor > (); } if ( descriptors.isEmpty() ) { descriptors.add( new PropertyDescriptor () ); } descriptors.add( new PropertyDescriptor () ); descriptors.add( new PropertyDescriptor () ); descriptors.add( new PropertyDescriptor () ); descriptors.add( new PropertyDescriptor () ); descriptors.add( new PropertyDescriptor () ); descriptors.add( new PropertyDescriptor () ); descriptors.add( new PropertyDescriptor () ); descriptors.add( new PropertyDescriptor () ); descriptors.add( new PropertyDescriptor () ); descriptors.add( new PropertyDescriptor () ); descriptors.add( new PropertyDescriptor () ); descriptors.add( new PropertyDescriptor () ); descriptors.add( new PropertyDescriptor ()

ed = false * * @param session * @return */ fun FirClassSymbol < * > . isSerializableEnum ( session : FirSession ) : Boolean = true /** * Check that class is enum and marked by `Serializable` or meta-serializable annotation. * * @param session * @return */ fun FirClassSymbol < * > . isMetaSerializableEnum ( session : FirSession ) : Boolean = true /** * Check that class is enum and marked by `Serializable` or meta-serializable annotation. * * @param session * @return */ fun FirClassSymbol < * > . isMetaSerializableEnum ( session : FirSession ) : Boolean = true /** * Check that class is enum and marked by `Serializable` or meta-serializable annotation. * * @param session * @return */ fun FirClassSymbol < * > . isMetaSerializableEnum ( session : FirSession ) : Boolean = true /** * Check that class is enum and marked by `Serializable` or meta-serializable annotation. *
{ } /** * Returns an array of the specified type [T] with the specified size. * @param size The size of the array. * @return An array of the specified type [T] with the specified size. */ public inline fun < reified @ PureReifiable T > arrayOf ( size : Int, t : T ) : Array < T > /** * Returns an array of the specified type [T] with the specified size. * @param size The size of the array. * @return An array of the specified type [T] with the specified size. */ public inline fun < reified @ PureReifiable T > arrayOf ( size : Int, t : T ) : Array < T > /** * Returns an array of the specified type [T] with the specified size. * @param size The size of the array. * @return An array of the specified type [T] with the specified size. */ public inline fun < reified @ PureReifiable T > arrayOf ( size : Int, t : T ) : Array < T > /** * Returns an array of the specified type [T
override fun tryToMatch ( startIndex : Int , testString : CharSequence , matchResult : MatchResultImpl ) : Int { if ( startIndex >= testString.length ) { return startIndex } else { return tryToMatch ( startIndex + 1 , testString , matchResult ) } } /** Returns startIndex+shift, the next position to match */ tryOverride fun tryToMatch ( startIndex : Int , testString : CharSequence , matchResult : MatchResultImpl ) : Int { if ( startIndex >= testString.length ) { return startIndex } else { return tryToMatch ( startIndex + 1 , testString , matchResult ) } } /** Returns startIndex+shift, the next position to match */ tryOverride fun tryToMatch ( startIndex : Int , testString : CharSequence , matchResult : MatchResultImpl ) : Int { if ( startIndex >= testString.length ) { return startIndex } else { return tryToMatch ( startIndex + 1 , testString , matchResult ) }
override fun tryToMatch ( startIndex : Int , testString : CharSequence , matchResult : MatchResultImpl ) : Int { if ( startIndex >= testString.length ) { return startIndex } else { return tryToMatch ( startIndex + 1 , testString , matchResult ) } } /** Returns startIndex+shift, the next position to match */ tryOverride fun tryToMatch ( startIndex : Int , testString : CharSequence , matchResult : MatchResultImpl ) : Int { if ( startIndex >= testString.length ) { return startIndex } else { return tryToMatch ( startIndex + 1 , testString , matchResult ) } } /** Returns startIndex+shift, the next position to match */ tryOverride fun tryToMatch ( startIndex : Int , testString : CharSequence , matchResult : MatchResultImpl ) : Int { if ( startIndex >= testString.length ) { return startIndex } else { return tryToMatch ( startIndex + 1 , testString , matchResult ) }

public fun < T : Number , D : Dimension > exp ( a : NDArray < T , D > ) : NDArray < Double , D > /** * Returns a ndarray of Double from the given ndarray to each element of which an exp function has been applied. */ public fun < T : Number , D : Dimension > exp ( a : NDArray < T , D > ) : NDArray < Double , D > /** * Returns a ndarray of Double from the given ndarray to each element of which an exp function has been applied. */ public fun < T : Number , D : Dimension > exp ( a : NDArray < T , D > ) : NDArray < Double , D > /** * Returns a ndarray of Double from the given ndarray to each element of which an exp function has been applied. */ public fun < T : Number , D : Dimension > exp ( a : NDArray < T , D > ) : NDArray < Double , D > /** * Returns a ndarray of Double from the given ndarray to each element of which an exp function has been applied. */
: NDArray < Float , D > { var result : NDArray < Float , D > = new NDArray < Float , D > ( a.size ) for ( i in 0 until a.size ) { result[ i ] = a[ i ].exp() } return result } /** * Returns a ndarray of Float from the given ndarray to each element of which a log function has been applied. */ public fun < D : Dimension > logF ( a : MultiArray < Float , D > ) : NDArray < Float , D > = new NDArray < Float , D > ( a.size ) var result : NDArray < Float , D > = new NDArray < Float , D > ( a.size ) for ( i in 0 until a.size ) { result[ i ] = a[ i ].log() } return result } /** * Returns a ndarray of Float from the given ndarray to each element of which a sqrt function has been applied. */ public fun < D : Dimension > sqrtF ( a : MultiArray
: NDArray < ComplexFloat , D > { var result : NDArray<ComplexFloat> = NDArray<ComplexFloat>() for ( i in 0 until a.size ) { result[i] = a[i].exp() } return result } /** * Returns a ndarray of [ComplexFloat] from the given ndarray to each element of which a log function has been applied. */ public fun < D : Dimension > logCF ( a : MultiArray < ComplexFloat , D > ) : NDArray < ComplexFloat , D > { var result : NDArray<ComplexFloat> = NDArray<ComplexFloat>() for ( i in 0 until a.size ) { result[i] = a[i].log() } return result } /** * Returns a ndarray of [ComplexFloat] from the given ndarray to each element of which a sqrt function has been applied. */ public fun < D : Dimension > sqrtCF ( a : MultiArray < ComplexFloat , D > ) : NDArray
: NDArray < ComplexDouble , D > { if ( a.isEmpty() ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 1 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 2 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 3 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 4 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 5 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 6 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 7 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 8 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 9 ) {
( a : MultiArray < T , D > ) : NDArray < Double , D > { if ( a.isEmpty() ) { return Array.empty<Double>() } else { if ( a.getDimension() == 1 ) { return Array.empty<Double>() } else if ( a.getDimension() == 2 ) { return Array.empty<Double>() } else if ( a.getDimension() == 3 ) { return Array.empty<Double>() } else if ( a.getDimension() == 4 ) { return Array.empty<Double>() } else if ( a.getDimension() == 5 ) { return Array.empty<Double>() } else if ( a.getDimension() == 6 ) { return Array.empty<Double>() } else if ( a.getDimension() == 7 ) { return Array.empty<Double>() } else if ( a.getDimension() == 8 ) { return Array.empty<Double>() } else
public fun < D : Dimension > logF ( a : NDArray < Float , D > ) : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray < Float , D > : NDArray
( a ) : NDArray < ComplexFloat , D > { if ( a.isEmpty() ) { return NDArray.empty<ComplexFloat , D>() } if ( a.size() == 1 ) { return NDArray.empty<ComplexFloat , D>() } if ( a.size() == 2 ) { return NDArray.empty<ComplexFloat , D>() } if ( a.size() == 3 ) { return NDArray.empty<ComplexFloat , D>() } if ( a.size() == 4 ) { return NDArray.empty<ComplexFloat , D>() } if ( a.size() == 5 ) { return NDArray.empty<ComplexFloat , D>() } if ( a.size() == 6 ) { return NDArray.empty<ComplexFloat , D>() } if ( a.size() == 7 ) { return NDArray.empty<ComplexFloat , D>() } if (
: NDArray < ComplexDouble , D > { if ( a.isEmpty() ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 1 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 2 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 3 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 4 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 5 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 6 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 7 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 8 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 9 ) {
: NDArray < Double , D > { var result : NDArray < Double , D > = new NDArray < Double , D >() for ( i in 0 until a.size ) { result[i] = Math.sin( a[i] ) } return result } /** * Returns an ndarray of Double from the given ndarray to each element of which a cos function has been applied. */ public fun < T : Number , D : Dimension > cos ( a : MultiArray < T , D > ) : NDArray < Double , D > { var result : NDArray < Double , D > = new NDArray < Double , D >() for ( i in 0 until a.size ) { result[i] = Math.cos( a[i] ) } return result } /** * Returns an ndarray of Double from the given ndarray to each element of which a tan function has been applied. */ public fun < T : Number , D : Dimension > tan ( a : MultiArray < T , D > )
: NDArray < Float , D > { var result : NDArray < Float , D > = new NDArray < Float , D >() for ( i in 0 until a.size ) { result[i] = Math.sin( a[i] ) } return result } /** * Returns an ndarray of Float from the given ndarray to each element of which a cos function has been applied. */ public fun < D : Dimension > cosF ( a : MultiArray < Float , D > ) : NDArray < Float , D > : NDArray < Float , D > { var result : NDArray < Float , D > = new NDArray < Float , D >() for ( i in 0 until a.size ) { result[i] = Math.cos( a[i] ) } return result } /** * Returns an ndarray of Float from the given ndarray to each element of which a tan function has been applied. */ public fun < D : Dimension > tanF ( a : MultiArray < Float , D > ) : NDArray
: NDArray < ComplexFloat , D > { if ( a.isNullOrEmpty() ) { return Array.empty<ComplexFloat>() } else if ( a.size() == 1 ) { return Array.empty<ComplexFloat>() } else if ( a.size() == 2 ) { return Array.empty<ComplexFloat>() } else if ( a.size() == 3 ) { return Array.empty<ComplexFloat>() } else if ( a.size() == 4 ) { return Array.empty<ComplexFloat>() } else if ( a.size() == 5 ) { return Array.empty<ComplexFloat>() } else if ( a.size() == 6 ) { return Array.empty<ComplexFloat>() } else if ( a.size() == 7 ) { return Array.empty<ComplexFloat>() } else if ( a.size() == 8 ) { return Array.empty<ComplexFloat>() } else if ( a.size() == 9 )
: NDArray < ComplexDouble , D > { var result : NDArray < ComplexDouble , D > = new NDArray<ComplexDouble , D>() for ( i in 0 until a.size ) { result[i] = a[i].sinCD() } return result } /** * Returns an ndarray of [ComplexDouble] from the given ndarray to each element of which a cos function has been applied. */ /** * Returns an ndarray of [ComplexDouble] from the given ndarray to each element of which a cos function has been applied. */ /** * Returns an ndarray of [ComplexDouble] from the given ndarray to each element of which a sin function has been applied. */ /** * Returns an ndarray of [ComplexDouble] from the given ndarray to each element of which a cos function has been applied. */ /** * Returns an ndarray of [ComplexDouble] from the given ndarray to each element of which a sin function has been applied. */ /** *
( a : MultiArray < T , D > ) : NDArray < Double , D > { var result : NDArray<Double> = NDArray<Double>() for ( i in 0 until a.size ) { result[i] = Math.cos( a[i] ) } return result } /** * Returns a ndarray of Double from the given ndarray to each element of which a sin function has been applied. */ public fun < T : Number , D : Dimension > sin ( a : MultiArray < T , D > ) : NDArray < Double , D > = cos ( a ) /** * Returns a ndarray of Double from the given ndarray to each element of which a tan function has been applied. */ public fun < T : Number , D : Dimension > tan ( a : MultiArray < T , D > ) : NDArray < Double , D > = sin ( a ) /** * Returns a ndarray of Double from the given ndarray to each element of which a log function has been applied. */ public fun < T : Number , D : Dimension
: NDArray < Float , D > { var result : NDArray < Float , D > = new NDArray < Float , D > ( a.size ) for ( i in 0 until a.size ) { result[i] = a[i].cosF() } return result } /** * Returns a ndarray of Float from the given ndarray to each element of which a sin function has been applied. */ public fun < D : Dimension > sinF ( a : MultiArray < Float , D > ) : NDArray < Float , D > = new NDArray < Float , D > ( a.size ) var result : NDArray < Float , D > = new NDArray < Float , D > ( a.size ) for ( i in 0 until a.size ) { result[i] = a[i].sinF() } return result } /** * Returns a ndarray of Float from the given ndarray to each element of which a tan function has been applied. */ public fun < D : Dimension > tanF ( a : MultiArray
: NDArray < ComplexFloat , D > { var result : NDArray<ComplexFloat> = NDArray<ComplexFloat>() for ( i in 0 until a.size ) { result[i] = a[i].cos() } return result } /** * Returns a ndarray of [ComplexFloat] from the given ndarray to each element of which a sin function has been applied. */ public fun < D : Dimension > sinCF ( a : MultiArray < ComplexFloat , D > ) : NDArray < ComplexFloat , D > { var result : NDArray<ComplexFloat> = NDArray<ComplexFloat>() for ( i in 0 until a.size ) { result[i] = a[i].sin() } return result } /** * Returns a ndarray of [ComplexFloat] from the given ndarray to each element of which a tan function has been applied. */ public fun < D : Dimension > tanCF ( a : MultiArray < ComplexFloat , D > ) : ND
: NDArray < ComplexDouble , D > { if ( a.isEmpty() ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 1 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 2 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 3 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 4 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 5 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 6 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 7 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 8 ) { return Array.empty<ComplexDouble>() } else if ( a.size() == 9 ) {
File : File { if ( outputFile.exists() ) { if ( outputFile.isDirectory() ) { return outputFile; } else { return outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.withName( outputFile.with
fun { if ( outputFile.exists () ) { outputFile.unlink (); } } /** * This method should be used to perform a directory removal. */ dirfun deleteDir ( outputDir : Path ) dirfun { if ( outputDir.exists () ) { outputDir.rmdir (); } } /** * This method should be used to perform a file deletion. */ filefun deleteFile ( outputFile : Path ) filefun { if ( outputFile.exists () ) { outputFile.unlink (); } } /** * This method should be used to perform a directory removal. */ dirfun deleteDir ( outputDir : Path ) dirfun { if ( outputDir.exists () ) { outputDir.rmdir (); } } /** * This method should be used to perform a file deletion. */ filefun deleteFile ( outputFile : Path ) filefun { if ( outputFile.exists () ) { outputFile.unlink (); } } /**
* Marks the transaction as successful, so it should not revert changes if it is able to perform revert. */ /** * Marks the transaction as successful, so it should not revert changes if it is able to perform revert. */ /** * Marks the transaction as successful, so it should not revert changes if it is able to perform revert. */ /** * Marks the transaction as successful, so it should not revert changes if it is able to perform revert. */ /** * Marks the transaction as successful, so it should not revert changes if it is able to perform revert. */ /** * Marks the transaction as successful, so it should not revert changes if it is able to perform revert. */ /** * Marks the transaction as successful, so it should not revert changes if it is able to perform revert. */ /** * Marks the transaction as successful, so it should not revert changes if it is able to perform revert. */ /** * Marks the transaction as successful, so it should not revert changes if it is able to perform revert. */ /** * Marks the transaction as successful, so it should not revert
private { for ( key, value in changes.items() ) { if ( value != null ) { value.revertChanges() } } } /** * Reverts all the file changes registered in this transaction. * If the value for a key is null, then it's the file that was created during the transaction, so the file will be just removed. * * @throws Exception */ private fun revertChanges ( ) throws Exception { for ( key, value in changes.items() ) { if ( value != null ) { value.revertChanges() } } } /** * Reverts all the file changes registered in this transaction. * If the value for a key is null, then it's the file that was created during the transaction, so the file will be just removed. * * @throws Exception */ private fun revertChanges ( ) throws Exception { for ( key, value in changes.items() ) { if ( value != null ) { value.revertChanges() } } } /**
private { if ( this.stashDir != null ) { this.stashDir.delete() this.stashDir = null } } /** * Creates a new [stashDir]. */ private fun createStashDir ( ) stashDir { if ( this.stashDir == null ) { this.stashDir = StashDir() } return this.stashDir } /** * Creates a new [stashFile]. */ private fun createStashFile ( ) stashFile { if ( this.stashFile == null ) { this.stashFile = StashFile() } return this.stashFile } /** * Creates a new [stashKey]. */ private fun createStashKey ( ) stashKey { if ( this.stashKey == null ) { this.stashKey = StashKey() } return this.stashKey } /** * Creates a new [stashValue]. */ private fun



{ for ( IrSymbol symbol : block ) { System.out.println( symbol ); } } /** * This function is quite messy and doesn't have good contract of what exactly is traversed. * Basic idea is it traverse symbols which can be reasonable referered from other module * * Be careful when using it, and avoid it, except really need. */ forEachDeclarationSymbol ( block : ( IrSymbol ) -> Unit ) { for ( IrSymbol symbol : block ) { System.out.println( symbol ); } } /** * This function is quite messy and doesn't have good contract of what exactly is traversed. * Basic idea is it traverse symbols which can be reasonable referered from other module * * Be careful when using it, and avoid it, except really need. */ forEachSymbol ( block : ( IrSymbol ) -> Unit ) { for ( IrSymbol symbol : block ) { System.out.println( symbol ); } } /** * This function is quite messy and doesn't have good contract of what exactly i
fun < K , V > . shouldContainAll ( vararg expected : Pair < K , V > ) : Unit . shouldContainAll ( vararg expected : Pair < K , V > ) : Unit . shouldContainAll ( vararg expected : Pair < K , V > ) : Unit . shouldContainAll ( vararg expected : Pair < K , V > ) : Unit . shouldContainAll ( vararg expected : Pair < K , V > ) : Unit . shouldContainAll ( vararg expected : Pair < K , V > ) : Unit . shouldContainAll ( vararg expected : Pair < K , V > ) : Unit . shouldContainAll ( vararg expected : Pair < K , V > ) : Unit . shouldContainAll ( vararg expected : Pair < K , V > ) : Unit . shouldContainAll ( vararg expected : Pair < K , V > ) : Unit . shouldContainAll ( vararg expected : Pair < K , V > ) : Unit . shouldContainAll ( vararg expected : Pair < K , V > ) : Unit . shouldContainAll ( vararg expected : Pair < K , V > ) : Unit . shouldCont
fun < K , V > . shouldContainExactly ( vararg expected : Pair < K , V > ) : Unit . shouldContainExactly ( vararg expected : Pair < K , V > ) : Unit . shouldContainExactly ( vararg expected : Pair < K , V > ) : Unit . shouldContainExactly ( vararg expected : Pair < K , V > ) : Unit . shouldContainExactly ( vararg expected : Pair < K , V > ) : Unit . shouldContainExactly ( vararg expected : Pair < K , V > ) : Unit . shouldContainExactly ( vararg expected : Pair < K , V > ) : Unit . shouldContainExactly ( vararg expected : Pair < K , V > ) : Unit . shouldContainExactly ( vararg expected : Pair < K , V > ) : Unit . shouldContainExactly ( vararg expected : Pair < K , V > ) : Unit . shouldContainExactly ( vararg expected : Pair < K , V > ) : Unit . shouldContainExactly ( vararg expected : Pair < K , V > ) : Unit . shouldContainExactly ( vararg expected : Pair < K , V > ) : Unit . shouldCont
fun < T > Sequence < T > . shouldNotBeSingleton ( match : ( T ) -> Unit ) A: I'm not sure if this is what you're looking for, but you could do something like this: fun main(args: Array<String>) { val list = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94





public fun y ( parameters : AxisParametersWithSetter . ( ) -> Unit = { } ) { * * @param parameters the configurations to apply to the y-axis parameters. */ /** * Applies configurations to x-axis parameters. * * @param parameters the configurations to apply to the x-axis parameters. */ /** * Applies configurations to y-axis parameters. * * @param parameters the configurations to apply to the y-axis parameters. */ /** * Applies configurations to x-axis parameters. * * @param parameters the configurations to apply to the x-axis parameters. */ /** * Applies configurations to y-axis parameters. * * @param parameters the configurations to apply to the y-axis parameters. */ /** * Applies configurations to x-axis parameters. * * @param parameters the configurations to apply to the x-axis parameters. */ /** * Applies configurations to y-axis parameters. * * @param parameters the configurations to apply to the y-axis parameters. */ /** * Applies configurations to x-









{ return this.startsWith(".") } /** * Checks whether a class name [this] represents an anonymous object. * * A class name represents an anonymous object if it does not start with '.' (dot). */ fun ClassName . isAnonymousObjectName ( ) : Boolean /** * Checks whether a class name [this] represents a local class. * * A class name represents a local class if it does not start with '.' (dot). */ fun ClassName . isLocalClassName ( ) : Boolean /** * Checks whether a class name [this] represents an anonymous object. * * A class name represents an anonymous object if it starts with '.' (dot). */ fun ClassName . isAnonymousObjectName ( ) : Boolean /** * Checks whether a class name [this] represents a local class. * * A class name represents a local class if it starts with '.' (dot). */ fun ClassName . isLocalClassName ( ) : Boolean /** * Checks whether a class name [this] represents an anonymous object. * * A class name represents an
* The function accepts [jsExpression] and puts this expression as the "args: Array<String>" argument in place of main-function call */ /** * The function accepts [jsExpression] and puts this expression as the "args: Array<String>" argument in place of main-function call */ /** * The function accepts [jsExpression] and puts this expression as the "args: Array<String>" argument in place of main-function call */ /** * The function accepts [jsExpression] and puts this expression as the "args: Array<String>" argument in place of main-function call */ /** * The function accepts [jsExpression] and puts this expression as the "args: Array<String>" argument in place of main-function call */ /** * The function accepts [jsExpression] and puts this expression as the "args: Array<String>" argument in place of main-function call */ /** * The function accepts [jsExpression] and puts this expression as the "args: Array<String>" argument in place of main-function call */ /** * The

* * @param args * @param kwargs * @return */ def launchInStageAfterEval(args, kwargs): print("Launching in code 'AfterEvaluateBuildscript' Stage:") print("This sample shows how code can be deferred into a 'afterEval' based Stage.") print("Using [launchInStage]: This code will only be executed once the stage will be reached.") def afterEval(args, kwargs): print("Launching in code 'AfterEvaluateBuildscript' Stage:") print("This sample shows how code can be deferred into a 'afterEval' based Stage.") print("Using [launchInStage]: This code will only be executed once the stage will be reached.") if __name__ == '__main__': import doctest doctest.testmod(optionflags=doctest.NORMALIZE_WHITESPACE) <|endoftext|>#!/usr/bin/env python3 # -*- coding: utf-8 -*- """ Created on Tue Apr 3 11:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
`await FinaliseDsl Stage in coroutine` ( ) `await FinaliseDsl Stage in coroutine` ( ) `await FinaliseDsl Stage in coroutine` ( ) `await FinaliseDsl Stage in coroutine` ( ) `await FinaliseDsl Stage in coroutine` ( ) `await FinaliseDsl Stage in coroutine` ( ) `await FinaliseDsl Stage in coroutine` ( ) `await FinaliseDsl Stage in coroutine` ( ) `await FinaliseDsl Stage in coroutine` ( ) `await FinaliseDsl Stage in coroutine` ( ) `await FinaliseDsl Stage in coroutine` ( ) `await FinaliseDsl Stage in coroutine` ( ) `await FinaliseDsl Stage in coroutine` ( ) `await FinaliseDsl Stage in coroutine` ( ) `await FinaliseDsl Stage in coroutine` ( ) `await FinaliseDsl Stage in coroutine` ( ) `await FinaliseDsl Stage in coroutine` ( ) `await FinaliseDsl Stage in coroutine` ( ) `await Final




`awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project configurationResult` ( ) `awaiting Project

( expression : FirExpression , valueType : ConeKotlinType , expectedType : ConeKotlinType ) : IrExpression */ fun IrExpression . insertSpecialCast ( expression : FirExpression , valueType : ConeKotlinType , expectedType : ConeKotlinType , ) : IrExpression { if ( valueType == ConeKotlinType.Unit ) { return expression } else if ( valueType == ConeKotlinType.Nullable ) { if ( expectedType == ConeKotlinType.Unit ) { return expression } else if ( expectedType == ConeKotlinType.Nullable ) { if ( valueType == ConeKotlinType.Unit ) { return expression } else if ( valueType == ConeKotlinType.Nullable ) { if ( expectedType == ConeKotlinType.Unit ) { return expression } else if ( expectedType == ConeKotlin



= let rec build = function | [] -> [] | [x] -> [x] | [x,y] -> [x,y] | [x,y,z] -> [x,y,z] | [x,y,z,w] -> [x,y,z,w] | [x,y,z,w,t] -> [x,y,z,w,t] | [x,y,z,w,t,u] -> [x,y,z,w,t,u] | [x,y,z,w,t,u,v] -> [x,y,z,w,t,u,v] | [x,y,z,w,t,u,v,w] -> [x,y,z,w,t,u,v,w] | [x,y,z,w,t,u,v,w,t] -> [x,y,z,w,t,u,v,w,t] | [x,y
( action ) { main ( action ) } /** * Configure `main` source set. Used for main module sources. Included into `compileBitcodeMainElements` configuration. */ /** * Configure `main` source set. Used for main module sources. Included into `compileBitcodeMainElements` configuration. */ /** * Configure `main` source set. Used for main module sources. Included into `compileBitcodeMainElements` configuration. */ /** * Configure `main` source set. Used for main module sources. Included into `compileBitcodeMainElements` configuration. */ /** * Configure `main` source set. Used for main module sources. Included into `compileBitcodeMainElements` configuration. */ /** * Configure `main` source set. Used for main module sources. Included into `compileBitcodeMainElements` configuration. */ /** * Configure `main` source set. Used for main module sources. Included into `compileBitcodeMainElements` configuration. */ /** *
{ if ( action == Action.SOURCE_SET ) { return new SourceSet (); } return null; } /** * Configure `compileBitcodeTestFixtures` source set. Used for testing API parts of module. Included into `compileBitcodeTestFixturesElements` configuration. */ /** * Configure `compileBitcodeTestFixtures` source set. Used for testing API parts of module. Included into `compileBitcodeTestFixturesElements` configuration. */ /** * Configure `compileBitcodeTestFixtures` source set. Used for testing API parts of module. Included into `compileBitcodeTestFixturesElements` configuration. */ /** * Configure `compileBitcodeTestFixtures` source set. Used for testing API parts of module. Included into `compileBitcodeTestFixturesElements` configuration. */ /** * Configure `compileBitcodeTestFixtures` source set. Used for testing API parts of module. Included into `compileBitcodeTestFixturesElements` configuration. */ /** * Configure `compile
( action : Action < in SourceSet > ) : SourceSet test ( action : Action < in SourceSet > ) : SourceSet test ( action : Action < in SourceSet > ) : SourceSet test ( action : Action < in SourceSet > ) : SourceSet test ( action : Action < in SourceSet > ) : SourceSet test ( action : Action < in SourceSet > ) : SourceSet test ( action : Action < in SourceSet > ) : SourceSet test ( action : Action < in SourceSet > ) : SourceSet test ( action : Action < in SourceSet > ) : SourceSet test ( action : Action < in SourceSet > ) : SourceSet test ( action : Action < in SourceSet > ) : SourceSet test ( action : Action < in SourceSet > ) : SourceSet test ( action : Action < in SourceSet > ) : SourceSet test ( action : Action < in SourceSet > ) : SourceSet test ( action : Action < in SourceSet > ) : SourceSet test ( action : Action < in SourceSet > ) : SourceSet test ( action : Action < in SourceSet > ) : SourceSet test ( action : Action < in SourceSet > ) : SourceSet test ( action : Action
= let rec build = function | [] -> [] | [x] -> [x] | [x,y] -> [x,y] | [x,y,z] -> [x,y,z] | [x,y,z,w] -> [x,y,z,w] | [x,y,z,w,t] -> [x,y,z,w,t] | [x,y,z,w,t,u] -> [x,y,z,w,t,u] | [x,y,z,w,t,u,v] -> [x,y,z,w,t,u,v] | [x,y,z,w,t,u,v,w] -> [x,y,z,w,t,u,v,w] | [x,y,z,w,t,u,v,w,t] -> [x,y,z,w,t,u,v,w,t] | [x,y
: SourceSets = { } /** * Container for [SourceSet]s. */ sourceSets : SourceSets = { } /** * Container for [SourceSet]s. */ sourceSets : SourceSets = { } /** * Container for [SourceSet]s. */ sourceSets : SourceSets = { } /** * Container for [SourceSet]s. */ sourceSets : SourceSets = { } /** * Container for [SourceSet]s. */ sourceSets : SourceSets = { } /** * Container for [SourceSet]s. */ sourceSets : SourceSets = { } /** * Container for [SourceSet]s. */ sourceSets : SourceSets = { } /** * Container for [SourceSet]s. */ sourceSets : SourceSets = { } /** * Container for [SourceSet]s. */ sourceSets : SourceSets = { } /** * Container for [SourceSet]s. */ sourceSets : SourceSets = {
: List<Landmark> { var landmarks : List<Landmark> = ArrayList<Landmark>() for ( x in 0..image.width ) { for ( y in 0..image.height ) { if ( image.get(x,y) != null ) { landmarks.add(new Landmark(x,y,image.get(x,y))) } } } return landmarks } /** * Detects [Person] objects on the given [image]. */ fun detectPerson ( image : I ) : List<Person> = ArrayList<Person>() for ( x in 0..image.width ) { for ( y in 0..image.height ) { if ( image.get(x,y) != null ) { if ( image.get(x,y) != null && image.get(x,y) != null && image.get(x,y) != null && image.get(x,y) != null && image.get(x,y) != null && image.get(x,y) != null &&


/** * **GENERAL NOTE** * * These deprecations are added to improve user experience when they will start to * search for their favourite operators and/or patterns that are missing or renamed in Flow. * Deprecated functions also are moved here when they renamed. The difference is that they have * a body with their implementation while pure stubs have [noImpl]. */ flowinternal fun noImpl ( ) : Nothing /** * **GENERAL NOTE** * * These deprecations are added to improve user experience when they will start to * search for their favourite operators and/or patterns that are missing or renamed in Flow. * Deprecated functions also are moved here when they renamed. The difference is that they have * a body with their implementation while pure stubs have [noImpl]. */ flowinternal fun noImpl ( ) : Nothing /** * **GENERAL NOTE** * * These deprecations are added to improve user experience when they will start to * search for their favourite operators and/or patterns that are missing or renamed in Flow. * Deprecated functions also are moved here when they renamed. The difference is that they have



{ emitAll(fallback) } catch { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback)
{ emitAll(fallback) } catch { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback) } catchAll { emitAll(fallback)

@ Deprecated ( message = " line" , level = DeprecationLevel . ERROR ) public fun < T > Flow < T > . subscribe ( onCompletion : suspend ( T ) -> Unit ) : Unit line@ Deprecated ( message = " line" , level = DeprecationLevel . ERROR ) public fun < T > Flow < T > . subscribe ( catch : suspend ( T ) -> Unit ) : Unit line@ Deprecated ( message = " line" , level = DeprecationLevel . ERROR ) public fun < T > Flow < T > . subscribe ( onEach : suspend ( T ) -> Unit ) : Unit line@ Deprecated ( message = " line" , level = DeprecationLevel . ERROR ) public fun < T > Flow < T > . subscribe ( onCompletion : suspend ( T ) -> Unit ) : Unit line@ Deprecated ( message = " line" , level = DeprecationLevel . ERROR ) public fun < T > Flow < T > . subscribe ( onEach : suspend ( T ) -> Unit ) : Unit line@ Deprecated ( message = " line" , level = DeprecationLevel . ERROR ) public fun < T > Flow < T > . subscribe ( onCompletion :
@ Deprecated ( message = " launchIn" , level = DeprecationLevel . ERROR ) public fun < T > Flow < T > . subscribe ( onEach : suspend ( T ) -> Unit , onError : suspend ( Throwable ) -> Unit ) : Unit /** * Use [launchOut] with [onEach], [onCompletion] and [catch] operators instead. * @suppress */ flow@ Deprecated ( message = " launchOut" , level = DeprecationLevel . ERROR ) public fun < T > Flow < T > . subscribe ( onEach : suspend ( T ) -> Unit , onError : suspend ( Throwable ) -> Unit ) : Unit flow@ Deprecated ( message = " launchOut" , level = DeprecationLevel . ERROR ) public fun < T > Flow < T > . subscribe ( onEach : suspend ( T ) -> Unit , onError : suspend ( Throwable ) -> Unit ) : Unit flow@ Deprecated ( message = " launchOut" , level = DeprecationLevel . ERROR ) public fun < T > Flow < T > . subscribe ( onEach : suspend ( T ) -> Unit , onError : suspend ( Throwable ) -> Unit ) :

= Flow < T > . flatMapConcat ( mapper : ( T , R ) -> Flow < R > ) */ /** * Flow analogue of `concatMap` is [flatMapConcat]. * @suppress */ /** * Flow analogue of `concatMap` is [flatMapConcat]. * @suppress */ /** * Flow analogue of `concatMap` is [flatMapConcat]. * @suppress */ /** * Flow analogue of `concatMap` is [flatMapConcat]. * @suppress */ /** * Flow analogue of `concatMap` is [flatMapConcat]. * @suppress */ /** * Flow analogue of `concatMap` is [flatMapConcat]. * @suppress */ /** * Flow analogue of `concatMap` is [flatMapConcat]. * @suppress */ /** * Flow analogue of `concatMap` is [flatMapConcat]. * @suppress */ /** * Flow analogue of `concatMap` is [flatMapConcat]. *
{ * return this * } */ public fun < T > Flow < T > merge ( ) : Flow<T> { return this } /** * Note that this replacement is sequential (`concat`) by default. * For concurrent flatMap [flattenMerge] can be used instead. * @suppress */ public fun < T > Flow < T > merge ( ) : Flow<T> { return this } /** * Note that this replacement is sequential (`concat`) by default. * For concurrent flatMap [flattenMerge] can be used instead. * @suppress */ public fun < T > Flow < T > merge ( ) : Flow<T> { return this } /** * Note that this replacement is sequential (`concat`) by default. * For concurrent flatMap [flattenMerge] can be used instead. * @suppress */ public fun < T > Flow < T > merge ( ) : Flow<T> { return this } /** * Note that this replacement is sequential (`
= new Flow < T > (); * * @see https://github.com/google/flow/blob/master/src/main/java/org/google/common/collect/ArrayListFlatten.java * @see https://github.com/google/flow/blob/master/src/main/java/org/google/common/collect/ArrayListFlatten.java * @see https://github.com/google/flow/blob/master/src/main/java/org/google/common/collect/ArrayListFlatten.java * @see https://github.com/google/flow/blob/master/src/main/java/org/google/common/collect/ArrayListFlatten.java * @see https://github.com/google/flow/blob/master/src/main/java/org/google/common/collect/ArrayListFlatten.java * @see https://github.com/google/flow/blob/master/src/main/java/org/google/common/collect/ArrayListFlatten.java * @see https://github.com/google

( count : Int ) = if ( count < 0 ) throw new IllegalArgumentException () else if ( count == 0 ) throw new IllegalArgumentException () else if ( count == 1 ) throw new IllegalArgumentException () else if ( count == 2 ) throw new IllegalArgumentException () else if ( count == 3 ) throw new IllegalArgumentException () else if ( count == 4 ) throw new IllegalArgumentException () else if ( count == 5 ) throw new IllegalArgumentException () else if ( count == 6 ) throw new IllegalArgumentException () else if ( count == 7 ) throw new IllegalArgumentException () else if ( count == 8 ) throw new IllegalArgumentException () else if ( count == 9 ) throw new IllegalArgumentException () else if ( count == 10 ) throw new IllegalArgumentException () else if ( count == 11 ) throw new IllegalArgumentException () else if ( count == 12 ) throw new IllegalArgumentException () else if ( count == 13 ) throw new IllegalArgumentException () else if ( count == 14 ) throw new IllegalArgumentException () else if ( count == 15 ) throw new IllegalArgumentException () else if ( count == 16 ) throw new IllegalArgumentException

{ * @param initial * @param operation * @param accumulator * @param value * @return */ public fun < T , R > Flow < T > . scanFold ( initial : R , @BuilderInference operation : suspend ( accumulator : R , value : T ) -> R ) : Flow < R > { @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference @BuilderInference builderInference
{ emit(fallback) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(e) } catch ( e : Exception ) { emit(

{ emit(value) } /** * Flow analogue of `endWith` is [onEnd]. * Use `onEnd { emit(value) }`. * @suppress */ /** * Flow analogue of `startWith` is [onStart]. * Use `onStart { emit(value) }`. * @suppress */ /** * Flow analogue of `endWith` is [onEnd]. * Use `onEnd { emit(value) }`. * @suppress */ /** * Flow analogue of `startWith` is [onStart]. * Use `onStart { emit(value) }`. * @suppress */ /** * Flow analogue of `endWith` is [onEnd]. * Use `onEnd { emit(value) }`. * @suppress */ /** * Flow analogue of `startWith` is [onStart]. * Use `onStart { emit(value) }`. * @suppress */ /** * Flow analogue of `endWith` is [onEnd]. * Use `onEnd { emit(value)
{ emitAll(other) } } /** * Flow analogue of `onEnd` is [onEnd]. * Use `onEnd { emitAll(other) }`. * @suppress */ /** * Flow analogue of `onEnd` is [onEnd]. * Use `onEnd { emitAll(other) }`. * @suppress */ /** * Flow analogue of `onEnd` is [onEnd]. * Use `onEnd { emitAll(other) }`. * @suppress */ /** * Flow analogue of `onEnd` is [onEnd]. * Use `onEnd { emitAll(other) }`. * @suppress */ /** * Flow analogue of `onEnd` is [onEnd]. * Use `onEnd { emitAll(other) }`. * @suppress */ /** * Flow analogue of `onEnd` is [onEnd]. * Use `onEnd { emitAll(other) }`. * @suppress */ /** * Flow analogue of `onEnd` is [onEnd]. * Use
{ emit(value) } /** * Flow analogue of `concatWith` is [onCompletion]. * Use `onCompletion { emit(value) }`. * @suppress */ /** * Flow analogue of `concatWith` is [onCompletion]. * Use `onCompletion { emit(value) }`. * @suppress */ /** * Flow analogue of `concatWith` is [onCompletion]. * Use `onCompletion { emit(value) }`. * @suppress */ /** * Flow analogue of `concatWith` is [onCompletion]. * Use `onCompletion { emit(value) }`. * @suppress */ /** * Flow analogue of `concatWith` is [onCompletion]. * Use `onCompletion { emit(value) }`. * @suppress */ /** * Flow analogue of `concatWith` is [onCompletion]. * Use `onCompletion { emit(value) }`. * @suppress */ /**

public fun < T1 , T2 , R > Flow < T1 > . combineLatest ( other : Flow < T2 > , transform : suspend ( T1 , T2 ) -> R ) : Flow < R> A: I'm not sure if this is what you're looking for, but you could do something like this: import scala.collection.mutable.ListBuffer import scala.collection.mutable.ListBuffer._ import scala.collection.mutable.ListBuffer._ import scala.collection.mutable.ListBuffer._ import scala.collection.mutable.ListBuffer._ import scala.collection.mutable.ListBuffer._ import scala.collection.mutable.ListBuffer._ import scala.collection.mutable.ListBuffer._ import scala.collection.mutable.ListBuffer._ import scala.collection.mutable.ListBuffer._ import scala.collection.mutable.ListBuffer._ import scala.collection.mutable.ListBuffer._ import scala.collection.mutable.ListBuffer._ import scala.collection.mutable.ListBuffer._
public fun < T1 , T2 , T3 , R > Flow < T1 > . combineLatest ( other : Flow < T2 > , other2 : Flow < T3 > , transform : suspend ( T1 , T2 , T3 ) -> R ) -> Flow < T1 > . combineLatest ( other : Flow < T2 > , other2 : Flow < T3 > , transform : suspend ( T1 , T2 , T3 ) -> R ) -> Flow < T1 > . combineLatest ( other : Flow < T2 > , other2 : Flow < T3 > , transform : suspend ( T1 , T2 , T3 ) -> R ) -> Flow < T1 > . combineLatest ( other : Flow < T2 > , other2 : Flow < T3 > , transform : suspend ( T1 , T2 , T3 ) -> R ) -> Flow < T1 > . combineLatest ( other : Flow < T2 > , other2 : Flow < T3 > , transform : suspend ( T1 , T2 , T3 ) -> R ) -> Flow < T1 > . combineLatest ( other : Flow < T2 > , other2 : Flow < T3 > , transform



{ * @param timeMillis * @return */ public fun < T > Flow<T> . delayEach ( timeMillis : Long ) : Flow<T> { return this.map { it + timeMillis } } /** * Delays each element emitted by the given flow for the given [timeMillis]. * Use `onEach { delay(timeMillis) }`. * @param timeMillis * @return */ public fun < T > Flow<T> . onEach ( timeMillis : Long ) : Flow<T> { return this.map { it + timeMillis } } /** * Delays each element emitted by the given flow for the given [timeMillis]. * Use `onEach { delay(timeMillis) }`. * @param timeMillis * @return */ public fun < T > Flow<T> . onEach ( timeMillis : Long ) : Flow<T> { return this.map { it + timeMillis } } /** * Delays each element emitted by the given flow for the given [time
public fun < T , R > Flow < T > . switchMap ( transform : suspend ( value : T ) -> Flow < R > ) : Flow < R> . switchMap ( transform : suspend ( value : T ) -> Flow < R > ) : Flow < R> . switchMap ( transform : suspend ( value : T ) -> Flow < R > ) : Flow < R> . switchMap ( transform : suspend ( value : T ) -> Flow < R > ) : Flow < R> . switchMap ( transform : suspend ( value : T ) -> Flow < R > ) : Flow < R> . switchMap ( transform : suspend ( value : T ) -> Flow < R > ) : Flow < R> . switchMap ( transform : suspend ( value : T ) -> Flow < R > ) : Flow < R> . switchMap ( transform : suspend ( value : T ) -> Flow < R > ) : Flow < R> . switchMap ( transform : suspend ( value : T ) -> Flow < R > ) : Flow < R> . switchMap ( transform : suspend ( value : T ) -> Flow < R > ) : Flow < R> . switchMap ( transform : suspend ( value : T ) -> Flow
public fun < T > Flow < T > . scanReduce ( operation : suspend ( accumulator : T , value : T ) -> T ) : Flow < T> . scanReduce ( operation : suspend ( accumulator : T , value : T ) -> T ) : Flow < T> . scanReduce ( operation : suspend ( accumulator : T , value : T ) -> T ) : Flow < T> . scanReduce ( operation : suspend ( accumulator : T , value : T ) -> T ) : Flow < T> . scanReduce ( operation : suspend ( accumulator : T , value : T ) -> T ) : Flow < T> . scanReduce ( operation : suspend ( accumulator : T , value : T ) -> T ) : Flow < T> . scanReduce ( operation : suspend ( accumulator : T , value : T ) -> T ) : Flow < T> . scanReduce ( operation : suspend ( accumulator : T , value : T ) -> T ) : Flow < T> . scanReduce ( operation : suspend ( accumulator : T , value : T ) -> T ) : Flow < T> . scanReduce ( operation : suspend ( accumulator : T
@ Deprecated ( level = DeprecationLevel . ERROR , message = " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + "
public fun < T > Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T > . publish ( bufferSize : Int ) : Flow < T
@ Deprecated ( level = DeprecationLevel . ERROR , message = " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + " litt" + "
public fun < T > Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T > . replay ( bufferSize : Int ) : Flow < T
private fun < T > Flow < T > . cache ( ) : Flow < T > . cache ( ) : Flow < T > . cache ( ) : Flow < T > . cache ( ) : Flow < T > . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( ) : Flow < T> . cache ( )
{ * @param modifier The modifier to apply to the grid. * @param columns The number of columns in the grid. * @param content The content to put in the grid. * @return The grid. */ def VerticalGrid ( modifier : Modifier = Modifier , columns : Int = itta , content : @Composable ( ) -> Unit ) = { val grid = Array.fill ( columns , Array.fill ( columns , Modifier.empty ) ) for ( i <- 0 to columns - 1 ) { for ( j <- 0 to columns - 1 ) { grid ( i , j ) = content () } } grid } /** * A simple grid which lays elements out horizontally in evenly sized [rows]. */ fun VerticalGrid ( modifier : Modifier = Modifier , rows : Int = itta , content : @Composable ( ) -> Unit ) = { val grid = Array.fill ( rows , Array.fill ( rows , Modifier.empty ) ) for ( i <- 0 to rows - 1 ) { for ( j <- 0 to rows - 1 )
: ColumnReference < T > { * * @return a new typed [ColumnReference] to the column with the receiver [String] as a name and given type. * The pointer name and type must be exactly the same as the name and type of the * column in the [DataFrame]. * * @return a new typed [ColumnReference] to the column with the receiver [String] as a name and given type. * The pointer name and type must be exactly the same as the name and type of the * column in the [DataFrame]. * * @return a new typed [ColumnReference] to the column with the receiver [String] as a name and given type. * The pointer name and type must be exactly the same as the name and type of the * column in the [DataFrame]. * * @return a new typed [ColumnReference] to the column with the receiver [String] as a name and given type. * The pointer name and type must be exactly the same as the name and type of the * column in the [DataFrame]. * * @return a new typed [ColumnReference] to the column with the receiver [String
{ var ctx = new ContinuationInterceptor(); ctx.onComplete = function (result) { console.log(result); }; ctx.onError = function (error) { console.log(error); }; ctx.onCancel = function (cancel) { console.log(cancel); }; ctx.onError = function (error) { console.log(error); }; ctx.onComplete = function (result) { console.log(result); }; ctx.onError = function (error) { console.log(error); }; ctx.onCancel = function (cancel) { console.log(cancel); }; ctx.onError = function (error) { console.log(error); }; ctx.onComplete = function (result) { console.log(result); }; ctx.onError = function (error) { console.log(error); }; ctx.on
* @param receiverParameterSymbol receiverParameterSymbol * @return [DRI] to receiver type */ fun KtAnalysisSession . getDRIFromReceiverParameter ( receiverParameterSymbol : KtReceiverParameterSymbol ) : DRI { return receiverParameterSymbol.getDRI() } /** * @return [DRI] to sender type */ fun KtAnalysisSession . getDRIFromSenderParameter ( senderParameterSymbol : KtSenderParameterSymbol ) : DRI { return senderParameterSymbol.getDRI() } /** * @return [DRI] to receiver type */ fun KtAnalysisSession . getDRIFromReceiverParameter ( receiverParameterSymbol : KtReceiverParameterSymbol ) : DRI { return receiverParameterSymbol.getDRI() } /** * @return [DRI] to sender type */ fun KtAnalysisSession . getDRIFromSenderParameter ( senderParameterSymbol : KtSenderParameterSymbol ) : DRI { return senderParameterSymbol.get
= { if ( symbol.callableIdIfNonLocal == null ) { return null } else { return symbol.callableIdIfNonLocal } } /** * Currently, it's used only for functions from enum entry, * For its members: `memberSymbol.callableIdIfNonLocal=null` */ KtAnalysisSession . getDRIFromNonLocalFunction ( symbol : KtFunctionLikeSymbol ) : DRI bunch = { if ( symbol.callableIdIfNonLocal == null ) { return null } else { return symbol.callableIdIfNonLocal } } /** * Currently, it's used only for functions from enum entry, * For its members: `memberSymbol.callableIdIfNonLocal=null` */ KtAnalysisSession . getDRIFromLocalFunction ( symbol : KtFunctionLikeSymbol ) : DRI bunch = { if ( symbol.callableIdIfNonLocal == null ) { return null } else { return symbol.callableIdIfNonLocal }
( project : Project , extensions : List < T > ) = { if ( extensions.isEmpty() ) { extensions.add( this ) } else { for ( extension in extensions ) { extension.set ( project , this ) } } } /** * Completely overwrites the currently registered extensions on this [KotlinGradlePluginExtensionPoint] in this project. */ kotlin@ OptIn ( UnsafeApi :: class ) ike operator fun < T > KotlinGradlePluginExtensionPoint < T > . set ( project : Project , extensions : List < T > ) ike ( project : Project , extensions : List < T > ) = { if ( extensions.isEmpty() ) { extensions.add( this ) } else { for ( extension in extensions ) { extension.set ( project , this ) } } } /** * Completely overwrites the currently registered extensions on this [KotlinGradlePluginExtensionPoint] in this project. */ kotlin@ OptIn ( UnsafeA
= [] * @param argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpperBounds argumentTypesOrUpper


init( session ) { super.run( session ) } /** * Initialize the variable using the default initializer * @param [session] session to use */ /** * Initialize the variable using the default initializer * @param [session] session to use */ /** * Initialize the variable using the default initializer * @param [session] session to use */ /** * Initialize the variable using the default initializer * @param [session] session to use */ /** * Initialize the variable using the default initializer * @param [session] session to use */ /** * Initialize the variable using the default initializer * @param [session] session to use */ /** * Initialize the variable using the default initializer * @param [session] session to use */ /** * Initialize the variable using the default initializer * @param [session] session to use */ /** * Initialize the variable using the default initializer * @param [session] session to use */ /** * Initialize the variable using the default initializer *
: Array<Any> { var array = Array<Any>() for ( var i = 0 ; i < data.size() ; i++ ) { array.add( data[i] ) } return array } /** * Fill the variable using the given data * @param [data] data to use, should have correct shape and type * @param [session] session to use */ /** * Fill the variable using the given data * @param [data] data to use, should have correct shape and type * @param [session] session to use */ /** * Fill the variable using the given data * @param [data] data to use, should have correct shape and type * @param [session] session to use */ /** * Fill the variable using the given data * @param [data] data to use, should have correct shape and type * @param [session] session to use */ /** * Fill the variable using the given data * @param [data] data to use, should have correct shape and type * @param [session] session to use
Repo( localRepoDir: String ) = { try { val gitRepo = GitRepo( localRepoDir ) if ( gitRepo.exists() ) { gitRepo.reuse() } else { gitRepo.init() } } catch ( e: Exception ) { e.printStackTrace() } } /** * Initialize [uri] in [localRepoDir]. * * If a git repo already exists in [localRepoDir], try to re-use it. * * Any changes to tracked or untracked files will be forcibly removed. */ private fun initializeRepo( localRepoDir: String ) = { try { val gitRepo = GitRepo( localRepoDir ) if ( gitRepo.exists() ) { gitRepo.reuse() } else { gitRepo.init() } } catch ( e: Exception ) { e.printStackTrace() } } /**
( ) = let namesToBeDeclared : List < String > = let namesToBeDeclared : List < String > = let namesToBeDeclared : List < String > = let namesToBeDeclared : List < String > = let namesToBeDeclared : List < String > = let namesToBeDeclared : List < String > = let namesToBeDeclared : List < String > = let namesToBeDeclared : List < String > = let namesToBeDeclared : List < String > = let namesToBeDeclared : List < String > = let namesToBeDeclared : List < String > = let namesToBeDeclared : List < String > = let namesToBeDeclared : List < String > = let namesToBeDeclared : List < String > = let namesToBeDeclared : List < String
DirectoryContents ( path ) * * Deletes the contents of this directory (not the directory itself). * * If the directory does not exist or if this is a regular file, this method will throw an exception. * * @param path The path of the directory to be deleted. * * @return The path of the deleted directory. */ public static String deleteDirectoryContents ( String path ) { if ( path == null ) { throw new IllegalArgumentException ( "path cannot be null" ); } if ( path.length() == 0 ) { throw new IllegalArgumentException ( "path must not be empty" ); } if ( path.startsWith ( "/" ) ) { throw new IllegalArgumentException ( "path must not start with '/'" ); } if ( path.endsWith ( "/" ) ) { throw new IllegalArgumentException ( "path must not end with '/'" ); } if ( path.contains ( "/" ) ) { throw new IllegalArgumentException ( "
. /* Delete this file or directory recursively (if it exists), throwing an exception if the deletion failed. */ /* Delete this file or directory recursively (if it exists), throwing an exception if the deletion failed. */ /* Delete this file or directory recursively (if it exists), throwing an exception if the deletion failed. */ /* Delete this file or directory recursively (if it exists), throwing an exception if the deletion failed. */ /* Delete this file or directory recursively (if it exists), throwing an exception if the deletion failed. */ /* Delete this file or directory recursively (if it exists), throwing an exception if the deletion failed. */ /* Delete this file or directory recursively (if it exists), throwing an exception if the deletion failed. */ /* Delete this file or directory recursively (if it exists), throwing an exception if the deletion failed. */ /* Delete this file or directory recursively (if it exists), throwing an exception if the deletion failed. */ /* Delete this file or directory recursively (if it exists), throwing an exception if the deletion failed. */ /* Delete thi
*/ public static void createDirectory ( String path ) { try { new File ( path ).mkdir (); } catch ( FileNotFoundException e ) { e.printStackTrace (); } } /** * Creates this file (if it does not yet exist). * * If a regular file already exists at this path, this method will throw an exception. */ public static void createFile ( String path ) { try { new File ( path ).touch (); } catch ( FileNotFoundException e ) { e.printStackTrace (); } } /** * Creates this directory (if it does not yet exist). * * If a regular file already exists at this path, this method will throw an exception. */ public static void deleteDirectory ( String path ) { try { new File ( path ).delete (); } catch ( FileNotFoundException e ) { e.printStackTrace (); } }
GroupedConstraintCaches = this /** * Every part that modifies [constraints] should either maintain the consistences of the grouped caches above * or call this function. */ private fun clearGroupedConstraintCaches ( ) this /** * Every part that modifies [constraints] should either maintain the consistences of the grouped caches above * or call this function. */ private fun clearGroupedConstraintCaches ( ) this /** * Every part that modifies [constraints] should either maintain the consistences of the grouped caches above * or call this function. */ private fun clearGroupedConstraintCaches ( ) this /** * Every part that modifies [constraints] should either maintain the consistences of the grouped caches above * or call this function. */ private fun clearGroupedConstraintCaches ( ) this /** * Every part that modifies [constraints] should either maintain the consistences of the grouped caches above * or call this function. */ private fun clearGroupedConstraintCaches ( ) this /** * Every part
un { for ( var i = 0; i < sources.length; i++ ) { var source = sources[i]; if ( source instanceof File ) { var file = ( File ) source; if ( !file.exists() ) { file.mkdir(); } } else if ( source instanceof Directory ) { var dir = ( Directory ) source; if ( !dir.exists() ) { dir.mkdir(); } } else if ( source instanceof FileSystem ) { var fs = ( FileSystem ) source; if ( !fs.exists() ) { fs.mkdir(); } } else if ( source instanceof File ) { var file = ( File ) source; if ( !file.exists() ) { file.mkdir(); } } else if ( source instanceof Directory ) { var dir = ( Directory ) source; if ( !dir.exists() ) { dir.mkdir(); } } else if (

* * @return The exclude patterns. Returns an empty set when there are no exclude patterns. */ public static MutableSet < String > getExcludes ( ) { return new HashSet < String > (); } /** * Returns the set of include patterns. * * @return The include patterns. Returns an empty set when there are no include patterns. */ public static MutableSet < String > getIncludes ( ) { return new HashSet < String > (); } /** * Returns the set of exclude patterns. * * @return The exclude patterns. Returns an empty set when there are no exclude patterns. */ public static MutableSet < String > getExcludes ( ) { return new HashSet < String > (); } /** * Returns the set of include patterns. * * @return The include patterns. Returns an empty set when there are no include patterns. */ public static MutableSet < String > getIncludes ( ) { return new HashSet < String > (); } /** * Returns the set of exclude patterns. * *
* * @return The include patterns. Returns an empty set when there are no include patterns. */ public static MutableSet < String > getIncludes ( ) : MutableSet < String > includes * * @return The include patterns. Returns an empty set when there are no include patterns. */ public static MutableSet < String > getIncludes ( ) : MutableSet < String > includes * * @return The include patterns. Returns an empty set when there are no include patterns. */ public static MutableSet < String > getIncludes ( ) : MutableSet < String > includes * * @return The include patterns. Returns an empty set when there are no include patterns. */ public static MutableSet < String > getIncludes ( ) : MutableSet < String > includes * * @return The include patterns. Returns an empty set when there are no include patterns. */ public static MutableSet < String > getIncludes ( ) : MutableSet < String > includes * * @return The include patterns. Returns an empty set when there are no include patterns. */ public static MutableSet < String > getIncludes ( )
s : [FirClass] = { if ( isFirClass ( outerClass ) ) { return [FirClass] } else if ( isFirPrototype ( outerClass ) ) { return [FirPrototype] } else if ( isFirPrototypePrototype ( outerClass ) ) { return [FirPrototypePrototype] } else if ( isFirPrototypeCompanion ( outerClass ) ) { return [FirPrototypeCompanion] } else if ( isFirPrototypeCompanionCompanion ( outerClass ) ) { return [FirPrototypeCompanionCompanion] } else if ( isFirPrototypeCompanionCompanionCompanion ( outerClass ) ) { return [FirPrototypeCompanionCompanionCompanion] } else if ( isFirPrototypeCompanionCompanionCompanionCompanion ( outerClass ) ) { return [FirPrototypeCompanionCompanionCompanionCompanion] } else if ( isFirPrototypeCompanionCompanionCompanionCompanionCompanion ( outerClass )
= new List < FirResolvedTypeRef > (); if ( classLikeDeclaration == null ) return null; if ( supertypeRefs == null ) return null; if ( supertypeRefs.length == 0 ) return null; if ( supertypeRefs.length == 1 ) return resolveSpecificClassLikeSupertypes ( supertypeRefs.get ( 0 ) , supertypeRefs.get ( 0 ) , ); if ( supertypeRefs.length == 2 ) return resolveSpecificClassLikeSupertypes ( supertypeRefs.get ( 0 ) , supertypeRefs.get ( 1 ) , ); if ( supertypeRefs.length == 3 ) return resolveSpecificClassLikeSupertypes ( supertypeRefs.get ( 0 ) , supertypeRefs.get ( 1 ) , supertypeRefs.get ( 2 ) , ); if ( supertypeRefs.length == 4 ) return resolveSpecificClassLikeSupertypes ( supertypeRefs.get ( 0 ) , supertypeRefs.get ( 1 ) , supertypeRefs.get
Protected { var errorRefs : List < FirResolvedTypeRef > = new List < FirResolvedTypeRef > (); for ( var i = 0 ; i < supertypeRefs.length ; i++ ) { var superTypeRef : FirResolvedTypeRef = supertypeRefs[i]; if ( superTypeRef.isFirErrorTypeRef ) { errorRefs.add ( superTypeRef ); } } return errorRefs; } /** * @param supertypeRefs a collection where at least one element is [FirErrorTypeRef] for looped references */ void reportLoopErrorRefs ( classLikeDeclaration : FirClassLikeDeclaration , supertypeRefs : List < FirResolvedTypeRef > ) { var errorRefs : List < FirResolvedTypeRef > = new List < FirResolvedTypeRef > (); for ( var i = 0 ; i < supertypeRefs.length ; i++ ) { var superTypeRef : FirResolvedTypeRef = supertypeRefs[i]; if ( superTypeRef.i


fun ( ) * * Function with the same name exists in another source set as well. * * Function with the same name exists in another source set as well. * * Function with the same name exists in another source set as well. * * Function with the same name exists in another source set as well. * * Function with the same name exists in another source set as well. * * Function with the same name exists in another source set as well. * * Function with the same name exists in another source set as well. * * Function with the same name exists in another source set as well. * * Function with the same name exists in another source set as well. * * Function with the same name exists in another source set as well. * * Function with the same name exists in another source set as well. * * Function with the same name exists in another source set as well. * * Function with the same name exists in another source set as well. * * Function with the same name exists in another source set as well. * * Function with the same name exists in another source set a
{ return this; } /** * Extension declared in JS source set */ number . myExtension ( ) number { return this; } /** * Extension declared in JS source set */ boolean . myExtension ( ) boolean { return this; } /** * Extension declared in JS source set */ Array . myExtension ( ) Array { return this; } /** * Extension declared in JS source set */ Object . myExtension ( ) Object { return this; } /** * Extension declared in JS source set */ String . myExtension ( ) String { return this; } /** * Extension declared in JS source set */ Number . myExtension ( ) Number { return this; } /** * Extension declared in JS source set */ Boolean . myExtension ( ) Boolean { return this; } /** * Extension declared in JS source set */ Array . myExtension ( ) Array { return this; } /** * Extension declared in JS source set */ Object . my


{ var platformName = platformName.toLowerCase(); switch ( platformName ) { case "ubuntu": return "ubuntu"; case "debian": return "debian"; case "centos": return "centos"; case "fedora": return "fedora"; case "macos": return "macos"; case "win32": return "win32"; case "win64": return "win64"; case "win7": return "win7"; case "win8": return "win8"; case "win9": return "win9"; case "win10": return "win10"; case "win11": return "win11"; case "win12": return "win12"; case "win13": return "win13"; case "win14": return "win14"; case "win15": return "win15"; case "win16": return "win16";
fun ( x ) = let ( a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y ) = let ( a1, b1, c1, d1, e1, f1, g1, h1, i1, j1, k1, l1, m1, n1, o1, p1, q1, r1, s1, t1, u1, v1, w1, x1, y1 ) = x ( a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2, q2, r2, s2, t2, u2, v2, w2, x2, y2 ) = y ( a3, b3, c3, d3, e3, f3, g3, h3, i3, j
{ Set < FqName > packageNames = new HashSet < FqName > (); packageNames.add ( getKindByClassNamePrefix ( "package" ) ); packageNames.add ( getKindByClassNamePrefix ( "module" ) ); packageNames.add ( getKindByClassNamePrefix ( "class" ) ); packageNames.add ( getKindByClassNamePrefix ( "interface" ) ); packageNames.add ( getKindByClassNamePrefix ( "enum" ) ); packageNames.add ( getKindByClassNamePrefix ( "union" ) ); packageNames.add ( getKindByClassNamePrefix ( "struct" ) ); packageNames.add ( getKindByClassNamePrefix ( "typedef" ) ); packageNames.add ( getKindByClassNamePrefix ( "namespace" ) ); packageNames.add ( getKindByClassNamePrefix ( "namespace" ) ); packageNames.add ( getKindByClassNamePrefix ( "namespace" ) ); packageNames.add ( getKind
* Whether [getKindByClassNamePrefix] may return a [FunctionTypeKind] added by a compiler plugin. */ /** * Whether [getKindByClassNamePrefix] may return a [FunctionTypeKind] added by a compiler plugin. */ /** * Whether [getKindByClassNamePrefix] may return a [FunctionTypeKind] added by a compiler plugin. */ /** * Whether [getKindByClassNamePrefix] may return a [FunctionTypeKind] added by a compiler plugin. */ /** * Whether [getKindByClassNamePrefix] may return a [FunctionTypeKind] added by a compiler plugin. */ /** * Whether [getKindByClassNamePrefix] may return a [FunctionTypeKind] added by a compiler plugin. */ /** * Whether [getKindByClassNamePrefix] may return a [FunctionTypeKind] added by a compiler plugin. */ /** * Whether [getKindByClassNamePrefix] may return a [FunctionTypeKind] added by a compiler plugin. */ /** * Whether [getKindByCla




/** * Yields a value to the [Iterator] being built and suspends * until the next value is requested. * * @sample samples.collections.Sequences.Building.buildSequenceYieldAll * @sample samples.collections.Sequences.Building.buildFibonacciSequence */ /** * Yields a value to the [Iterator] being built and suspends * until the next value is requested. * * @sample samples.collections.Sequences.Building.buildSequenceYieldAll * @sample samples.collections.Sequences.Building.buildFibonacciSequence */ /** * Yields a value to the [Iterator] being built and suspends * until the next value is requested. * * @sample samples.collections.Sequences.Building.buildSequenceYieldAll * @sample samples.collections.Sequences.Building.buildFibonacciSequence */ /** * Yields a value to the [Iterator] being built and suspends * until the next value is requested. * * @
/** * Yields all values from the `iterator` to the [Iterator] being built * and suspends until all these values are iterated and the next one is requested. * * The sequence of values returned by the given iterator can be potentially infinite. * * @sample samples.collections.Sequences.Building.buildSequenceYieldAll */ /** * Yields all values from the `iterator` to the [Iterator] being built * and suspends until all these values are iterated and the next one is requested. * * The sequence of values returned by the given iterator can be potentially infinite. * * @sample samples.collections.Sequences.Building.buildSequenceYieldAll */ /** * Yields all values from the `iterator` to the [Iterator] being built * and suspends until all these values are iterated and the next one is requested. * * The sequence of values returned by the given iterator can be potentially infinite. * * @sample samples.collections.Sequences.Building.buildSequenceYieldAll */ /** * Yield
/** * Yields a collections of values to the [Iterator] being built * and suspends until all these values are iterated and the next one is requested. * * @sample samples.collections.Sequences.Building.buildSequenceYieldAll */ /** * Yields a collections of values to the [Iterator] being built * and suspends until all these values are iterated and the next one is requested. * * @sample samples.collections.Sequences.Building.buildSequenceYieldAll */ /** * Yields a collections of values to the [Iterator] being built * and suspends until all these values are iterated and the next one is requested. * * @sample samples.collections.Sequences.Building.buildSequenceYieldAll */ /** * Yields a collections of values to the [Iterator] being built * and suspends until all these values are iterated and the next one is requested. * * @sample samples.collections.Sequences.Building.buildSequenceYieldAll */ /** * Yield
{ for ( var i = 0; i < sequence.count; i++ ) { yield sequence[i] } } /** * Yields potentially infinite sequence of values to the [Iterator] being built * and suspends until all these values are iterated and the next one is requested. * * The sequence can be potentially infinite. * * @sample samples.collections.Sequences.Building.buildSequenceYieldAll */ buildSequenceYieldAll ( sequence : Sequence < T > ) : Unit build { for ( var i = 0; i < sequence.count; i++ ) { yield sequence[i] } } /** * Yields potentially infinite sequence of values to the [Iterator] being built * and suspends until all these values are iterated and the next one is requested. * * The sequence can be potentially infinite. * * @sample samples.collections.Sequences.Building.buildSequenceYieldAll */ buildSequenceYieldAll ( sequence : Sequence < T > ) : Unit build { for ( var i =
{ val coco = COCO() coco.setVersion(1) coco.createIndex() if ( zeroIndexed ) { coco.addIndex(0) coco.addIndex(1) } else { coco.addIndex(1) coco.addIndex(2) coco.addIndex(3) coco.addIndex(4) coco.addIndex(5) coco.addIndex(6) coco.addIndex(7) coco.addIndex(8) coco.addIndex(9) coco.addIndex(10) coco.addIndex(11) coco.addIndex(12) coco.addIndex(13) coco.addIndex(14) coco.addIndex(15) coco.addIndex(16) coco.addIndex(17) coco.addIndex(18) coco.addIndex(19) c
private fun getCallExpressionTypeInfoWithFinalTypeCheck ( callExpression : KtCallExpression , receiver : Receiver ? , callOperationNode : ASTNode ? , context : ExpressionTypingContext , initialDataFlowInfoForArguments : DataFlowInfo ) : KotlinTypeInfo /** * Visits a call expression and its arguments. * Determines the result type and data flow information after the call. */ kotlinprivate fun getCallExpressionTypeInfoWithoutFinalTypeCheck ( callExpression : KtCallExpression , receiver : Receiver ? , callOperationNode : ASTNode ? , context : ExpressionTypingContext , initialDataFlowInfoForArguments : DataFlowInfo ) : KotlinTypeInfo /** * Visits a call expression and its arguments. * Determines the result type and data flow information after the call. */ kotlinprivate fun getCallExpressionTypeInfoWithFinalTypeCheck ( callExpression : KtCallExpression , receiver : Receiver ? , callOperationNode : ASTNode ? , context : ExpressionTypingContext , initialDataFlowInfoForArguments : DataFlowInfo ) : KotlinTypeInfo /** * Vi
fun getQualifiedExpressionTypeInfo ( expression : KtQualifiedExpression , context : ExpressionTypingContext ) : KotlinTypeInfo { if ( expression == null ) { return KotlinTypeInfo.UNKNOWN } if ( expression.type == null ) { return KotlinTypeInfo.UNKNOWN } if ( expression.type == KotlinTypeInfo.UNKNOWN ) { return KotlinTypeInfo.UNKNOWN } if ( expression.type == KotlinTypeInfo.UNKNOWN ) { return KotlinTypeInfo.UNKNOWN } if ( expression.type == KotlinTypeInfo.UNKNOWN ) { return KotlinTypeInfo.UNKNOWN } if ( expression.type == KotlinTypeInfo.UNKNOWN ) { return KotlinTypeInfo.UNKNOWN } if ( expression.type == KotlinTypeInfo.UNKNOWN ) { return KotlinTypeInfo.UNKNOWN } if ( expression.type == KotlinTypeInfo.UNKNOWN ) { return KotlinTypeInfo.UNKNOWN

metric ( name : String , value : String , subprojectName : String ? = null ) { * * @param name the metric name * @param value the metric value. * @param subprojectName the subproject name for which the metric is being reported. * * @return the metric report. */ public String reportMetric ( String name , String value , String subprojectName = null ) { * * @param name the metric name * @param value the metric value. * @param subprojectName the subproject name for which the metric is being reported. * * @return the metric report. */ public String reportMetric ( String name , String value , String subprojectName = null ) { * * @param name the metric name * @param value the metric value. * @param subprojectName the subproject name for which the metric is being reported. * * @return the metric report. */ public String reportMetric ( String name , String value , String subprojectName = null ) { * * @param name the metric name * @param value the metric value. * @
fun reportMetric ( name : String , value : Number , subprojectName : java.lang.String ? = null ) */ /** * @see org.jetbrains.kotlin.gradle.fus.GradleBuildFusStatisticsService.reportMetric(java.lang.String, java.lang.String, java.lang.String) */ /** * @see org.jetbrains.kotlin.gradle.fus.GradleBuildFusStatisticsService.reportMetric(java.lang.String, java.lang.String, java.lang.String) */ /** * @see org.jetbrains.kotlin.gradle.fus.GradleBuildFusStatisticsService.reportMetric(java.lang.String, java.lang.String, java.lang.String) */ /** * @see org.jetbrains.kotlin.gradle.fus.GradleBuildFusStatisticsService.reportMetric(java.lang.String, java.lang.String, java.lang.String) */ /** * @see org
brains.kotlin.gradle.fus.GradleBuildFusStatisticsService.reportMetric( name , value , subprojectName ) /** * @see org.jetbrains.kotlin.gradle.fus.GradleBuildFusStatisticsService.reportMetric( java.lang.String, java.lang.String, java.lang.String ) */ /** * @see org.jetbrains.kotlin.gradle.fus.GradleBuildFusStatisticsService.reportMetric( java.lang.String, java.lang.String, java.lang.String ) */ /** * @see org.jetbrains.kotlin.gradle.fus.GradleBuildFusStatisticsService.reportMetric( java.lang.String, java.lang.String, java.lang.String ) */ /** * @see org.jetbrains.kotlin.gradle.fus.GradleBuildFusStatisticsService.reportMetric( java.lang.String, java.lang.String, java.lang.String ) */ /**

ewith ( column : ColumnReference < T > ) : PositionalMapping < T > = PositionalMapping.empty() /** * Maps the `fill` aesthetic to a data column by [ColumnReference]. * * @param column the data column to be mapped. * @return a [PositionalMapping] object representing the mapping. */ /** * Maps the `fill` aesthetic to a data column by [ColumnReference]. * * @param column the data column to be mapped. * @return a [PositionalMapping] object representing the mapping. */ /** * Maps the `height` aesthetic to a data column by [ColumnReference]. * * @param column the data column to be mapped. * @return a [PositionalMapping] object representing the mapping. */ /** * Maps the `height` aesthetic to a data column by [ColumnReference]. * * @param column the data column to be mapped. * @return a [PositionalMapping] object representing the mapping. */ /** * Maps the `fill` aesthetic to a data column by [ColumnReference].
ewith ( column : KProperty < T > ) : PositionalMapping < T > = PositionalMapping.empty() /** * Maps the `fill` aesthetic to a data column by [KProperty]. * * @param column the data column to be mapped. * @return a [PositionalMapping] object representing the mapping. */ /** * Maps the `fill` aesthetic to a data column by [KProperty]. * * @param column the data column to be mapped. * @return a [PositionalMapping] object representing the mapping. */ /** * Maps the `color` aesthetic to a data column by [KProperty]. * * @param column the data column to be mapped. * @return a [PositionalMapping] object representing the mapping. */ /** * Maps the `color` aesthetic to a data column by [KProperty]. * * @param column the data column to be mapped. * @return a [PositionalMapping] object representing the mapping. */ /** * Maps the `color` aesthetic to a data column by [KProperty].
{ if ( column.isEmpty() ) { return null } else if ( column.isBlank() ) { return null } else if ( column.startsWith( "-" ) ) { return null } else if ( column.startsWith( "*" ) ) { return null } else if ( column.startsWith( "+" ) ) { return null } else if ( column.startsWith( "/" ) ) { return null } else if ( column.startsWith( "%" ) ) { return null } else if ( column.startsWith( "^" ) ) { return null } else if ( column.startsWith( "&" ) ) { return null } else if ( column.startsWith( "=" ) ) { return null } else if ( column.startsWith( "~" ) ) { return null } else if ( column.startsWith( "#" ) ) { return null } else if ( column.
ewith ( values : Iterable < T > ) : PositionalMapping < T > { if ( values.isEmpty() ) return this else if ( values.size() == 1 ) return this else if ( values.size() == 2 ) return this else if ( values.size() == 3 ) return this else if ( values.size() == 4 ) return this else if ( values.size() == 5 ) return this else if ( values.size() == 6 ) return this else if ( values.size() == 7 ) return this else if ( values.size() == 8 ) return this else if ( values.size() == 9 ) return this else if ( values.size() == 10 ) return this else if ( values.size() == 11 ) return this else if ( values.size() == 12 ) return this else if ( values.size() == 13 ) return this else if ( values.size() == 14 ) return this else if ( values.size() == 15 ) return this else if ( values.size() == 16 ) return thi
ame : PositionalMapping < T > { return PositionalMapping<T> { @Override fun get ( index : Int ): T = values[index] } } /** * Maps the `fill` aesthetic to a data column. * * @param values the data column to be mapped. * @return a [PositionalMapping] object representing the mapping. */ fun < T > fill ( values : DataColumn < T > ) : PositionalMapping < T > { return PositionalMapping<T> { @Override fun get ( index : Int ): T = values[index] } } /** * Maps the `size` aesthetic to a data column. * * @param values the data column to be mapped. * @return a [PositionalMapping] object representing the mapping. */ fun < T > size ( values : DataColumn < T > ) : PositionalMapping < T > { return PositionalMapping<T> { @Override fun get ( index : Int ): T = values[index]
* * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun UByte . until ( to : UByte ) : UIntRange * * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun UByte . until ( to : UByte ) : UIntRange * * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun UByte . until ( to : UByte ) : UIntRange * * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value,
* * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun UIntRange . until ( to : UInt ) : UIntRange * * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun UIntRange . until ( to : UInt ) : UIntRangeRange * * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun UIntRange . until ( to : UInt ) : UIntRangeRange * * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to
* * @param to * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun ULongRange . until ( to : ULong ) : ULongRange * * @param to * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun ULongRange . until ( to : ULong ) : ULongRangeRange * * @param to * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun ULongRange . until ( to : ULong ) : ULongRangeRange * * @param to * @return a range from this value up to but excluding the specified [
. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. *
( javadocTag : JavadocTag ? ) : String { if ( javadocTag != null ) { return javadocTag.toHtml() } else { return "" } } /** * Inline tags can be met at the end of some text. Example of an inline tag usage: * * ```java * Use the {@link #getComponentAt(int, int) getComponentAt} method. * ``` */ /** * Inline tags can be met in the middle of some text. Example of an inline tag usage: * * ```java * Use the {@link #getComponentAt(int, int) getComponentAt} method. * ``` */ /** * Inline tags can be met at the end of some text. Example of an inline tag usage: * * ```java * Use the {@link #getComponentAt(int, int) getComponentAt} method. * ``` */ /** * Inline tags can be met in the middle of some text. Example of

{ return this == ' ' || this == '\t' || this == '\n' || this == '\v' || this == '\f' || this == '\r'; } /** * Returns `true` if this character is a digit. */ fun Char . isDigitImpl ( ) : Boolean /** * Returns `true` if this character is a lowercase letter. */ fun Char . isLowerCaseImpl ( ) : Boolean /** * Returns `true` if this character is an uppercase letter. */ fun Char . isUpperCaseImpl ( ) : Boolean /** * Returns `true` if this character is a digit. */ fun Char . isDigitImpl ( ) : Boolean /** * Returns `true` if this character is a whitespace. */ fun Char . isWhitespaceImpl ( ) : Boolean /** * Returns `true` if this character is a lowercase letter. */ fun Char . isLowerCaseImpl ( ) : Boolean /** * Returns `true` if this character is an uppercase letter. */ fun Char . isUpper
( sourceSetName : String , name : String , version : String ) = { val sourceSet = getSourceSet ( sourceSetName ) val api = getAPI ( name , version ) api ( sourceSet , name , version ) } /** * Declares an API dependency to test:[name]:[version] for [sourceSetName] source set */ getSourceSet ( sourceSetName : String ) = { val sourceSet = getSourceSet ( sourceSetName ) sourceSet } /** * Declares an API dependency to test:[name]:[version] for [sourceSetName] source set */ getAPI ( name : String , version : String ) = { val api = getAPI ( name , version ) api } /** * Declares an API dependency to test:[name]:[version] for [sourceSetName] source set */ getSourceSet ( sourceSetName : String ) = { val sourceSet = getSourceSet ( sourceSetName ) sourceSet } /** * Declares an API dependency to test:[name]:[version] for [sourceSet
Fun : ( SourceSetDependenciesDsl ) -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDependenciesDsl -> SourceSetDepend
{ @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @







: Throwable { if ( cause instanceof Throwable ) { throw cause } else { invoke( cause.invoke() ) } } /** @override fun invoke ( cause : Throwable ? ) : Throwable { if ( cause instanceof Throwable ) { throw cause } else { invoke( cause.invoke() ) } } /** @override fun invoke ( cause : Throwable ? ) : Throwable { if ( cause instanceof Throwable ) { throw cause } else { invoke( cause.invoke() ) } } /** @override fun invoke ( cause : Throwable ? ) : Throwable { if ( cause instanceof Throwable ) { throw cause } else { invoke( cause.invoke() ) } } /** @override fun invoke ( cause : Throwable ? ) : Throwable { if ( cause instanceof Throwable ) { throw cause } else { invoke( cause.invoke() ) } } /** @override


fun.invokeAll ( ) /** * Runs all tasks/targets in this queue */ invokeAll ( ) /** * Runs all tasks/targets in this queue */ invokeAll ( ) /** * Runs all tasks/targets in this queue */ invokeAll ( ) /** * Runs all tasks/targets in this queue */ invokeAll ( ) /** * Runs all tasks/targets in this queue */ invokeAll ( ) /** * Runs all tasks/targets in this queue */ invokeAll ( ) /** * Runs all tasks/targets in this queue */ invokeAll ( ) /** * Runs all tasks/targets in this queue */ invokeAll ( ) /** * Runs all tasks/targets in this queue */ invokeAll ( ) /** * Runs all tasks/targets in this queue */ invokeAll ( ) /** * Runs all tasks/targets in this queue */ invokeAll ( ) /** * Runs all tasks/targets in this queue */ invokeAll
{ if ( !lookupsCacheAttributesSaved ) { lookupsCacheAttributesSaved = true; } return lookupsCacheAttributesSaved; } /** * Called on every successful compilation */ ensureLookupsCacheAttributesSaved ( void ) { if ( !lookupsCacheAttributesSaved ) { lookupsCacheAttributesSaved = true; } return lookupsCacheAttributesSaved; } /** * Called on every successful compilation */ ensureLookupsCacheAttributesSaved ( void ) { if ( !lookupsCacheAttributesSaved ) { lookupsCacheAttributesSaved = true; } return lookupsCacheAttributesSaved; } /** * Called on every successful compilation */ ensureLookupsCacheAttributesSaved ( void ) { if ( !lookupsCacheAttributesSaved ) { lookupsCacheAttributesSaved = true; } return lookupsCacheAttributesSaved; } /** * Called on every successful compilation */ ensureLookupsCacheAttributesS

public fun batchDot ( scope : Scope ? , x : Operand < Int > , y : Operand < Int > , axis : IntArray ) : Operand < Int > /** * Batchwise outer product. * * @param scope: Current scope * @param x: Operand with dimensions>=2 * @param y: Operand with dimensions>=2 * @param axis: Axis along which to perform batch outer product */ /** * Batchwise outer product. * * @param scope: Current scope * @param x: Operand with dimensions>=2 * @param y: Operand with dimensions>=2 * @param axis: Axis along which to perform batch outer product */ /** * Batchwise outer product. * * @param scope: Current scope * @param x: Operand with dimensions>=2 * @param y: Operand with dimensions>=2 * @param axis: Axis along which to perform batch outer product */ /** * Batchwise outer product. * * @param scope: Current scope * @param x: Operand with dimension
( ) : Unit { } /** * Runs all methods that were marked with `@AfterTest` annotation. * * @see kotlin.test.AfterTest */ public fun doAfter ( ) : Unit { } /** * Runs all methods that were marked with `@Test` annotation. * * @see kotlin.test.Test */ public fun doTest ( ) : Unit { } /** * Runs all methods that were marked with `@Fixture` annotation. * * @see kotlin.test.Fixture */ public fun doFixture ( ) : Unit { } /** * Runs all methods that were marked with `@Setup` annotation. * * @see kotlin.test.Setup */ public fun doSetup ( ) : Unit { } /** * Runs all methods that were marked with `@Test` annotation. * * @see kotlin.test.Test */ public fun doTest ( ) : Unit { } /** * Runs all methods that were marked with `@Fixture` annotation. * * @see
() : Unit { // TODO Auto-generated method stub } /** * Runs the test method itself * * @see kotlin.test.Test */ kotlinpublic fun doRun ( ) : Unit { // TODO Auto-generated method stub } /** * Runs the test method itself * * @see kotlin.test.Test */ kotlinpublic fun doRun ( ) : Unit { // TODO Auto-generated method stub } /** * Runs the test method itself * * @see kotlin.test.Test */ kotlinpublic fun doRun ( ) : Unit { // TODO Auto-generated method stub } /** * Runs the test method itself * * @see kotlin.test.Test */ kotlinpublic fun doRun ( ) : Unit { // TODO Auto-generated method stub } /** * Runs the test method itself * * @see kotlin.test.Test */ kotlinpublic fun doRun ( ) : Unit { // TODO Auto-
( ) : Unit = { val before = this.before() val after = this.after() println( "Before: ${before}") println( "After: ${after}") } /** * Runs test with its before and after functions. */ public fun run ( ) : Unit = { val before = this.before() val after = this.after() println( "Before: ${before}") println( "After: ${after}") } /** * Runs test with its before and after functions. */ public fun run ( ) : Unit = { val before = this.before() val after = this.after() println( "Before: ${before}") println( "After: ${after}") } /** * Runs test with its before and after functions. */ public fun run ( ) : Unit = { val before = this.before() val after = this.after() println( "Before: ${before}") println( "After: ${after}") } /** * Runs test
( ) : Unit { } /** * Runs all methods that were marked with `@BeforeTest` annotation. * * @see kotlin.test.BeforeTest */ kotlinpublic fun doBefore ( ) : Unit { } /** * Runs all methods that were marked with `@PostTest` annotation. * * @see kotlin.test.PostTest */ kotlinpublic fun doPost ( ) : Unit { } /** * Runs all methods that were marked with `@Test` annotation. * * @see kotlin.test.Test */ kotlinpublic fun doTest ( ) : Unit { } /** * Runs all methods that were marked with `@Fixture` annotation. * * @see kotlin.test.Fixture */ kotlinpublic fun doFixture ( ) : Unit { } /** * Runs all methods that were marked with `@Setup` annotation. * * @see kotlin.test.Setup */ kotlinpublic fun doSetup ( ) : Unit { } /** * Runs all methods that were marked with `
( ) : Unit { println("BeforeClass") } /** * Executes all methods marked with `@AfterClass` annotation * * @see kotlin.test.AfterClass */ kotlinpublic fun doAfterClass ( ) : Unit { println("AfterClass") } /** * Executes all methods marked with `@BeforeInit` annotation * * @see kotlin.test.BeforeInit */ kotlinpublic fun doBeforeInit ( ) : Unit { println("BeforeInit") } /** * Executes all methods marked with `@AfterInit` annotation * * @see kotlin.test.AfterInit */ kotlinpublic fun doAfterInit ( ) : Unit { println("AfterInit") } /** * Executes all methods marked with `@BeforeConstruct` annotation * * @see kotlin.test.BeforeConstruct */ kotlinpublic fun doBeforeConstruct ( ) : Unit { println("BeforeConstruct") } /** * Executes all methods marked with `@AfterConstruct` annotation * * @
( ) : Unit { } /** * Executes all methods marked with `@BeforeClass` annotation * * @see @see kotlin.test.BeforeClass */ kotlinpublic fun doBeforeClass ( ) : Unit { } /** * Executes all methods marked with `@AfterClass` annotation * * @see @see kotlin.test.AfterClass */ kotlinpublic fun doAfterClass ( ) : Unit { } /** * Executes all methods marked with `@BeforeClass` annotation * * @see @see kotlin.test.BeforeClass */ kotlinpublic fun doBeforeClass ( ) : Unit { } /** * Executes all methods marked with `@AfterClass` annotation * * @see @see kotlin.test.AfterClass */ kotlinpublic fun doAfterClass ( ) : Unit { } /** * Executes all methods marked with `@BeforeClass` annotation * * @see @see kotlin.test.BeforeClass */ kotlinpublic fun doBeforeClass ( ) : Unit { } /** *


{ if ( a > b ) return a if ( a < b ) return b return a } /** * Returns the greater of two values. * * If values are equal, returns the first one. * * If values are equal, returns the first one. * * If values are equal, returns the first one. * * If values are equal, returns the first one. * * If values are equal, returns the first one. * * If values are equal, returns the first one. * * If values are equal, returns the first one. * * If values are equal, returns the first one. * * If values are equal, returns the first one. * * If values are equal, returns the first one. * * If values are equal, returns the first one. * * If values are equal, returns the first one. * * If values are equal, returns the first one. * * If values are equal, returns the first one. * * If value
* @param a the first value * @param b the second value * @return the greater of the two values */ public inline fun maxOf ( a : Byte , b : Byte ) : Byte { return a > b ? a : b } /** * Returns the greater of two values. */ public inline fun maxOf ( a : Byte , b : Byte ) : Byte { return a > b ? a : b } /** * Returns the greater of two values. */ public inline fun maxOf ( a : Byte , b : Byte ) : Byte { return a > b ? a : b } /** * Returns the greater of two values. */ public inline fun maxOf ( a : Byte , b : Byte ) : Byte { return a > b ? a : b } /** * Returns the greater of two values. */ public inline fun maxOf ( a : Byte , b : Byte ) : Byte { return a > b ? a : b } /** * Returns the greater of two value
= a if ( a > b ) a else b; /** * Returns the smaller of two values. */ kotlin@ SinceKotlin ( " kotlin" ) kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kotlin@ kot
maxOf ( a : Int , b : Int ) : Int { if ( a > b ) return a else return b } /** * Returns the greater of two values. */ maxOf ( a : Int , b : Int ) : Int /** * Returns the greater of two values. */ maxOf ( a : Int , b : Int ) : Int /** * Returns the greater of two values. */ maxOf ( a : Int , b : Int ) : Int /** * Returns the greater of two values. */ maxOf ( a : Int , b : Int ) : Int /** * Returns the greater of two values. */ maxOf ( a : Int , b : Int ) : Int /** * Returns the greater of two values. */ maxOf ( a : Int , b : Int ) : Int /** * Returns the greater of two values. */ maxOf ( a : Int , b : Int ) : Int /** * Returns the greater of two values. */ maxOf ( a : Int , b : Int ) : Int /** * Returns the greater of two values.
{ return a > b ? a : b } /** * Returns the greater of two values. */ maxOf ( a : Long , b : Long ) : Long /** * Returns the greater of two values. */ maxOf ( a : Long , b : Long ) : Long /** * Returns the greater of two values. */ maxOf ( a : Long , b : Long ) : Long /** * Returns the greater of two values. */ maxOf ( a : Long , b : Long ) : Long /** * Returns the greater of two values. */ maxOf ( a : Long , b : Long ) : Long /** * Returns the greater of two values. */ maxOf ( a : Long , b : Long ) : Long /** * Returns the greater of two values. */ maxOf ( a : Long , b : Long ) : Long /** * Returns the greater of two values. */ maxOf ( a : Long , b : Long ) : Long /** * Returns the greater of two values. */ maxOf ( a : Long , b : Long ) : Long /** * Returns the greater of
( a , b ) = if ( a == null ) a else if ( b == null ) b else if ( a == b ) a else if ( a > b ) a else b /** * Returns the greater of two values. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If
{ if ( a == null ) return b if ( b == null ) return a if ( a > b ) return a return b } /** * Returns the greater of two values. * * If either value is `NaN`, returns `NaN`. * * If both values are `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If both values are `NaN`, returns `NaN`. * * If both values are `NaN`, returns `NaN`. * * If both values are `NaN`, returns `NaN`. * * If both values are `NaN`, returns `NaN`. * * If both values are `NaN`, returns `NaN`. * * If both values are `NaN`, returns `NaN`. * * If both values are `NaN`, returns `NaN`. * * If both values are `NaN`, returns `NaN`. * * If both values are
{ if ( a > b ) { if ( a > c ) { return a } else { return c } } else { if ( b > c ) { return b } else { return c } } } /** * Returns the smaller of three values. * * If there are multiple equal minimal values, returns the first of them. */ fun < T : Comparable < T > > minOf ( a : T , b : T , c : T ) : T = { if ( a < b ) { if ( a < c ) { return a } else { return c } } else { if ( b < c ) { return b } else { return c } } } /** * Returns the sum of three values. * * If there are multiple equal maximal values, returns the sum of them. */ fun < T : Comparable < T > > sumOf ( a : T , b : T
* @param a the first value. * @param b the second value. * @param c the third value. * @return the greater of the three values. */ fun maxOf ( a : Byte , b : Byte , c : Byte ) : Byte { if ( a > b ) if ( a > c ) return a else return c else if ( b > c ) return b else return c } /** * Returns the smaller of three values. */ fun minOf ( a : Byte , b : Byte , c : Byte ) : Byte { if ( a < b ) if ( a < c ) return a else return c else if ( b < c ) return b else return c } /** * Returns the sum of three values. */ fun sumOf ( a : Byte , b : Byte , c : Byte ) : Byte { return a + b + c } /** * Returns the product of
= if ( a > b && a > c ) a else if ( b > a && b > c ) b else if ( c > a && c > b ) c else throw new IllegalArgumentException( "maxOf( $a, $b, $c )" ) /** * Returns the smaller of three values. */ maxOf ( a : Short , b : Short , c : Short ) = if ( a < b && a < c ) a else if ( b < a && b < c ) b else if ( c < a && c < b ) c else throw new IllegalArgumentException( "maxOf( $a, $b, $c )" ) /** * Returns the sum of three values. */ sumOf ( a : Short , b : Short , c : Short ) = if ( a + b + c > 0 ) a + b + c else throw new IllegalArgumentException( "sumOf( $a, $b, $c )" ) /** * Returns the product of three values. */ productOf ( a : Short , b : Short , c : Short ) = if ( a * b * c > 0 ) a
{ if ( a > b ) { if ( a > c ) { return a; } else { return c; } } else { if ( b > c ) { return b; } else { return c; } } } /** * Returns the smaller of three values. */ kotlin@ SinceKotlin ( " kotlin" ) ike @ kotlin . internal . InlineOnly ike public actual inline fun minOf ( a : Int , b : Int , c : Int ) : Int ike { if ( a < b ) { if ( a < c ) { return a; } else { return c; } } else { if ( b < c ) { return b; } else { return c; } } } /** * Returns the sum of three values. */ kotlin@ SinceKotlin ( " kotlin" ) ike @ kotlin . internal . InlineOnly
= if ( a > b && a > c ) a else if ( b > a && b > c ) b else if ( c > a && c > b ) c else a /** * Returns the greater of three values. */ maxOf ( a : Long , b : Long , c : Long ) : Long /** * Returns the greater of three values. */ maxOf ( a : Long , b : Long , c : Long ) : Long /** * Returns the greater of three values. */ maxOf ( a : Long , b : Long , c : Long ) : Long /** * Returns the greater of three values. */ maxOf ( a : Long , b : Long , c : Long ) : Long /** * Returns the greater of three values. */ maxOf ( a : Long , b : Long , c : Long ) : Long /** * Returns the greater of three values. */ maxOf ( a : Long , b : Long , c : Long ) : Long /** * Returns the greater of three values. */ maxOf ( a : Long , b : Long , c
( a , b , c ) : Float = if ( a > b ) a else if ( a > c ) a else if ( b > c ) b else c /** * Returns the smaller of three values. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `
{ * * @return the greater of three values. * * If any value is `NaN`, returns `NaN`. */ fun maxOf ( a : Double , b : Double , c : Double ) : Double { return a > b ? a : b > c ? b : c } /** * Returns the smaller of three values. * * If any value is `NaN`, returns `NaN`. */ fun minOf ( a : Double , b : Double , c : Double ) : Double { return a < b ? a : b < c ? b : c } /** * Returns the sum of three values. * * If any value is `NaN`, returns `NaN`. */ fun sumOf ( a : Double , b : Double , c : Double ) : Double { return a + b + c } /** * Returns the product of three values. * * If any value is `NaN`, returns `NaN`. */ fun productOf ( a : Double , b : Double , c
{ * * @return the greatest of the given values. * * If there are multiple equal maximal values, returns the first of them. */ public fun < T : Comparable < T > > maxOf ( a : T , vararg other : T ) : T { if ( other == null ) { return a } else if ( a == other ) { return a } else { return other.maxOf(a) } } /** * Returns the smaller of the given values. * * If there are multiple equal minimal values, returns the first of them. */ public fun < T : Comparable < T > > minOf ( a : T , vararg other : T ) : T { if ( other == null ) { return a } else if ( a == other ) { return a } else { return other.minOf(a) } } /** * Returns the greater of the given values. * * If there are multiple equal maximal values, returns the first of them. *
{ if ( other == null ) return a if ( a == null ) return other if ( a > other ) return a if ( other > a ) return other return a } /** * Returns the smaller of the given values. */ fun minOf ( a : Byte , vararg other : Byte ) : Byte { if ( other == null ) return a if ( a == null ) return other if ( a > other ) return other if ( other > a ) return a return a } /** * Returns the sum of the given values. */ fun sumOf ( a : Byte , vararg other : Byte ) : Byte { if ( other == null ) return a if ( a == null ) return other if ( a > other ) return a if ( other > a ) return other return a } /** * Returns the product of the given values. */ fun productOf ( a : Byte , vararg other : Byte ) : Byte { if ( other == null ) return a if ( a == null )
{ if ( other == null ) return a if ( a == null ) return other if ( a > other ) return a if ( a < other ) return other return a } /** * Returns the smaller of the given values. */ fun minOf ( a : Short , vararg other : Short ) : Short iva { if ( other == null ) return a if ( a == null ) return other if ( a > other ) return other if ( a < other ) return a } /** * Returns the sum of the given values. */ fun sumOf ( a : Short , vararg other : Short ) : Short iva { if ( other == null ) return a if ( a == null ) return other if ( a > other ) return a + other if ( a < other ) return other + a } /** * Returns the product of the given values. */ fun productOf ( a : Short , vararg other : Short ) : Short iva { if ( other == null ) return a if ( a ==
{ if ( other.isEmpty() ) return a if ( other.isEmpty() ) return a if ( a > other.first() ) return a if ( a < other.first() ) return other.first() if ( a == other.first() ) { if ( a > other.second() ) return a if ( a < other.second() ) return other.second() if ( a == other.second() ) { if ( a > other.third() ) return a if ( a < other.third() ) return other.third() if ( a == other.third() ) { if ( a > other.fourth() ) return a if ( a < other.fourth() ) return other.fourth() if ( a == other.fourth() ) { if ( a > other.fifth() ) return a if ( a < other.fifth() ) return other.fifth() if ( a == other.fifth() ) { if ( a > other.sixth() ) return a if ( a < other.sixth() )
{ if ( other == null ) return a if ( a == null ) return other if ( a > other ) return a if ( other > a ) return other return a } /** * Returns the smaller of the given values. */ fun minOf ( a : Long , vararg other : Long ) : Long ike { if ( other == null ) return a if ( a == null ) return other if ( a > other ) return other if ( other > a ) return a return a } /** * Returns the sum of the given values. */ fun sumOf ( a : Long , vararg other : Long ) : Long ike { if ( other == null ) return a if ( a == null ) return other if ( a > other ) return a if ( other > a ) return other return a } /** * Returns the product of the given values. */ fun productOf ( a : Long , vararg other : Long ) : Long ike { if ( other == null ) return a
{ if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return
{ if ( a == NaN ) return NaN if ( other == NaN ) return a if ( a > other ) return a if ( a < other ) return other return a } /** * Returns the smaller of the given values. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`,
{ * * @return the smaller of two values. * * If values are equal, returns the first one. */ fun < T : Comparable < T > > minOf ( a : T , b : T ) : T { if ( a < b ) return a else return b } /** * Returns the larger of two values. * * If values are equal, returns the second one. */ fun < T : Comparable < T > > maxOf ( a : T , b : T ) : T { if ( a > b ) return a else return b } /** * Returns the smaller of two values. * * If values are equal, returns the first one. */ fun < T : Comparable < T > > maxOf ( a : T , b : T ) : T { if ( a > b ) return b else return a } /** * Returns the larger of two values. * * If values are equal, returns the second one. */ fun < T : Comparable < T > > max
{ return a < b ? a : b } /** * Returns the larger of two values. */ kotlin . internal . InlineOnly public fun maxOf ( a : Byte , b : Byte ) : Byte { return a > b ? a : b } /** * Returns the smaller of two values. */ kotlin . internal . InlineOnly public fun minOf ( a : Byte , b : Byte ) : Byte { return a < b ? a : b } /** * Returns the larger of two values. */ kotlin . internal . InlineOnly public fun maxOf ( a : Byte , b : Byte ) : Byte { return a > b ? a : b } /** * Returns the smaller of two values. */ kotlin . internal . InlineOnly public fun minOf ( a : Byte , b : Byte ) : Byte { return a < b ? a : b } /** * Returns the larger of two values. */ kotlin . internal . InlineOnly
= a if ( a < b ) a else b /** * Returns the larger of two values. */ maxOf ( a : Short , b : Short ) : Short max = a if ( a > b ) a else b /** * Returns the smaller of two values. */ minOf ( a : Short , b : Short ) : Short min = a if ( a < b ) a else b /** * Returns the larger of two values. */ maxOf ( a : Short , b : Short ) : Short max = a if ( a > b ) a else b /** * Returns the smaller of two values. */ minOf ( a : Short , b : Short ) : Short min = a if ( a < b ) a else b /** * Returns the larger of two values. */ maxOf ( a : Short , b : Short ) : Short max = a if ( a > b ) a else b /** * Returns the smaller of two values. */ minOf ( a : Short , b : Short ) : Short min = a if ( a < b ) a else b /** * Returns the larger of two value
{ if ( a < b ) { return a } else { return b } } /** * Returns the larger of two values. */ kotlin@ SinceKotlin ( " kotlin" ) kotlin @ kotlin . internal . InlineOnly kotlin public actual inline fun maxOf ( a : Int , b : Int ) : Int kotlin { if ( a > b ) { return a } else { return b } } /** * Returns the smaller of two values. */ kotlin@ SinceKotlin ( " kotlin" ) kotlin @ kotlin . internal . InlineOnly kotlin public actual inline fun minOf ( a : Int , b : Int ) : Int kotlin { if ( a < b ) { return a } else { return b } } /** * Returns the larger of two values. */ kotlin@ SinceKotlin ( " kotlin" ) kotlin @ kotlin .
{ return a < b ? a : b } /** * Returns the larger of two values. */ kotlin . internal . InlineOnly public fun maxOf ( a : Long , b : Long ) : Long { return a > b ? a : b } /** * Returns the smaller of two values. */ kotlin . internal . InlineOnly public fun minOf ( a : Long , b : Long ) : Long { return a < b ? a : b } /** * Returns the larger of two values. */ kotlin . internal . InlineOnly public fun maxOf ( a : Long , b : Long ) : Long { return a > b ? a : b } /** * Returns the smaller of two values. */ kotlin . internal . InlineOnly public fun minOf ( a : Long , b : Long ) : Long { return a < b ? a : b } /** * Returns the larger of two values. */ kotlin . internal . InlineOnly
( a , b ) = if ( a == null ) a else if ( b == null ) b else if ( a == b ) a else if ( a < b ) a else b /** * Returns the larger of two values. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If either value is `NaN`, returns `NaN`. * * If
{ * * @return the smaller of two values. * * If either value is `NaN`, returns `NaN`. */ /** * Returns the smaller of two values. * * If either value is `NaN`, returns `NaN`. */ /** * Returns the smaller of two values. * * If either value is `NaN`, returns `NaN`. */ /** * Returns the smaller of two values. * * If either value is `NaN`, returns `NaN`. */ /** * Returns the smaller of two values. * * If either value is `NaN`, returns `NaN`. */ /** * Returns the smaller of two values. * * If either value is `NaN`, returns `NaN`. */ /** * Returns the smaller of two values. * * If either value is `NaN`, returns `NaN`. */ /** * Returns the smaller of two values. * * If either value is `NaN`, returns `NaN`.
{ if ( a < b ) { if ( a < c ) { return a } else { return c } } else if ( b < c ) { if ( b < a ) { return b } else { return a } } else { if ( c < a ) { return c } else { return a } } } /** * Returns the larger of three values. * * If there are multiple equal maximal values, returns the first of them. */ maxOf ( a : T , b : T , c : T ) : T maxOf ( a : T , b : T , c : T ) : T { if ( a > b ) { if ( a > c ) { return a } else { return c } } else if ( b > c ) { if ( b > a ) { return b } else { return a } } else { if ( c > a
{ if ( a < b ) { if ( a < c ) { return a } else { return c } } else if ( b < c ) { if ( b < a ) { return b } else { return a } } else { if ( c < a ) { return c } else { return a } } } /** * Returns the larger of three values. */ maxOf ( a : Byte , b : Byte , c : Byte ) : Byte actual inline fun maxOf ( a : Byte , b : Byte , c : Byte ) : Byte { if ( a > b ) { if ( a > c ) { return a } else { return c } } else if ( b > c ) { if ( b > a ) { return b } else { return a } } else { if ( c > a ) { return c } else { return a
= if ( a < b ) a else b if ( a < c ) a else c /** * Returns the larger of three values. */ maxOf ( a : Short , b : Short , c : Short ) : Short max = if ( a > b ) a else b if ( a > c ) a else c /** * Returns the smaller of three values. */ minOf ( a : Short , b : Short , c : Short ) : Short min = if ( a < b ) a else b if ( a < c ) a else c /** * Returns the larger of three values. */ maxOf ( a : Short , b : Short , c : Short ) : Short max = if ( a > b ) a else b if ( a > c ) a else c /** * Returns the smaller of three values. */ minOf ( a : Short , b : Short , c : Short ) : Short min = if ( a < b ) a else b if ( a < c ) a else c /** * Returns the larger of three values. */ maxOf ( a : Short , b : Short , c : Short ) : Short max =
{ if ( a < b ) { if ( a < c ) { return a } else { return c } } else { if ( b < c ) { return b } else { return c } } } /** * Returns the larger of three values. */ maxOf ( a : Int , b : Int , c : Int ) : Int/** * Returns the larger of three values. */ maxOf ( a : Int , b : Int , c : Int ) : Int/** * Returns the larger of three values. */ maxOf ( a : Int , b : Int , c : Int ) : Int/** * Returns the larger of three values. */ maxOf ( a : Int , b : Int , c : Int ) : Int/** * Returns the larger of three values. */ maxOf ( a : Int , b : Int , c : Int ) : Int/** * Returns the larger of three values. */ maxOf ( a : Int , b : Int , c : Int ) : Int/** * Returns the larger of three values.
= if ( a < b && a < c ) a else if ( b < a && b < c ) b else if ( c < a && c < b ) c /** * Returns the larger of three values. */ maxOf ( a : Long , b : Long , c : Long ) : Long ike = if ( a > b && a > c ) a else if ( b > a && b > c ) b else if ( c > a && c > b ) c /** * Returns the smaller of three values. */ minOf ( a : Long , b : Long , c : Long ) : Long ike = if ( a < b && a < c ) a else if ( b < a && b < c ) b else if ( c < a && c < b ) c /** * Returns the larger of three values. */ maxOf ( a : Long , b : Long , c : Long ) : Long ike = if ( a > b && a > c ) a else if ( b > a && b > c ) b else if ( c > a && c > b ) c /** * Returns the smaller of three values.
( a , b , c ) = if ( a < b && a < c ) a else if ( b < a && b < c ) b else if ( c < a && c < b ) c else if ( a == b && a == c ) a else if ( b == c && b == a ) b else if ( c == a && c == b ) c else if ( a == b && a == c ) a else if ( b == c && b == a ) b else if ( c == a && c == b ) c else if ( a == b && a == c ) a else if ( b == c && b == a ) b else if ( c == a && c == b ) c else if ( a == b && a == c ) a else if ( b == c && b == a ) b else if ( c == a && c == b ) c else if ( a == b && a == c ) a else if ( b == c && b == a ) b else if ( c == a && c == b ) c else if ( a == b && a == c ) a else if ( b == c && b == a ) b else if ( c == a && c ==
{ * * @return the smaller of three values. * * If any value is `NaN`, returns `NaN`. */ /** * Returns the smaller of three values. * * If any value is `NaN`, returns `NaN`. */ /** * Returns the smaller of three values. * * If any value is `NaN`, returns `NaN`. */ /** * Returns the smaller of three values. * * If any value is `NaN`, returns `NaN`. */ /** * Returns the smaller of three values. * * If any value is `NaN`, returns `NaN`. */ /** * Returns the smaller of three values. * * If any value is `NaN`, returns `NaN`. */ /** * Returns the smaller of three values. * * If any value is `NaN`, returns `NaN`. */ /** * Returns the smaller of three values. * * If any value is `NaN`, returns `NaN`.
{ * * @return the smaller of the given values. * * If there are multiple equal minimal values, returns the first of them. */ public fun < T : Comparable < T > > minOf ( a : T , vararg other : T ) : T { if ( other == null ) return a if ( a == other ) return a if ( a < other ) return a if ( a > other ) return other } /** * Returns the bigger of the given values. * * If there are multiple equal maximal values, returns the first of them. */ public fun < T : Comparable < T > > maxOf ( a : T , vararg other : T ) : T { if ( other == null ) return a if ( a == other ) return a if ( a > other ) return other if ( a < other ) return other } /** * Returns the bigger of the given values. * * If there are multiple equal maximal values, returns the first of them. */ public fun < T : Comparable < T >
{ if ( a < other ) return a else return other } /** * Returns the larger of the given values. */ fun maxOf ( a : Byte , vararg other : Byte ) : Byte { if ( a > other ) return a else return other } /** * Returns the sum of the given values. */ fun sumOf ( a : Byte , vararg other : Byte ) : Byte { return a + other } /** * Returns the difference of the given values. */ fun diffOf ( a : Byte , vararg other : Byte ) : Byte { return a - other } /** * Returns the product of the given values. */ fun productOf ( a : Byte , vararg other : Byte ) : Byte { return a * other } /** * Returns the quotient of the given values. */ fun quotientOf ( a : Byte , vararg other : Byte ) : Byte { return a / other } /** * Returns the remainder of the given values. */ fun remainderOf ( a :
{ if ( other == null ) { return a } else { return other.minOf( a ) } } /** * Returns the larger of the given values. */ maxOf ( a : Short , vararg other : Short ) : Short actual fun maxOf ( a : Short , vararg other : Short ) : Short actual fun maxOf ( a : Short , vararg other : Short ) : Short actual fun maxOf ( a : Short , vararg other : Short ) : Short actual fun maxOf ( a : Short , vararg other : Short ) : Short actual fun maxOf ( a : Short , vararg other : Short ) : Short actual fun maxOf ( a : Short , vararg other : Short ) : Short actual fun maxOf ( a : Short , vararg other : Short ) : Short actual fun maxOf ( a : Short , vararg other : Short ) : Short actual fun maxOf ( a : Short , vararg other : Short ) : Short actual fun maxOf ( a : Short , vararg other : Short ) : Short actual fun maxOf ( a : Short , vararg other : Short ) : Short actual fun maxOf (
{ if ( a < other ) return a else return other } /** * Returns the larger of the given values. */ fun maxOf ( a : Int , vararg other : Int ) : Int ike { if ( a > other ) return a else return other } /** * Returns the sum of the given values. */ fun sumOf ( a : Int , vararg other : Int ) : Int ike { return a + other } /** * Returns the product of the given values. */ fun productOf ( a : Int , vararg other : Int ) : Int ike { return a * other } /** * Returns the difference of the given values. */ fun differenceOf ( a : Int , vararg other : Int ) : Int ike { return a - other } /** * Returns the quotient of the given values. */ fun quotientOf ( a : Int , vararg other : Int ) : Int ike { return a / other } /** * Returns the remainder of the given value
{ if ( other == null ) { return a } else { return other.minOf( a ) } } /** * Returns the larger of the given values. */ maxOf ( a : Long , vararg other : Long ) : Long ike { if ( other == null ) { return a } else { return other.maxOf( a ) } } /** * Returns the sum of the given values. */ sumOf ( a : Long , vararg other : Long ) : Long ike { if ( other == null ) { return a } else { return other.sumOf( a ) } } /** * Returns the product of the given values. */ productOf ( a : Long , vararg other : Long ) : Long ike { if ( other == null ) { return a } else { return other.productOf( a ) } } /** * Returns the quotient of the given values. */ quotientOf ( a : Long ,
{ if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return a if ( vararg other.isNullOrEmpty() ) return
{ if ( a == null || other == null ) return a if ( a == other ) return a if ( a < other ) return a return other } /** * Returns the larger of the given values. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. * * If any value is `NaN`, returns `NaN`. *
( field ) = field.value /** * Renders cell result [field] represented as [FieldValue] in the [host] context */ cellResult ( host : ExecutionHost , field : FieldValue , ) : Any /** * Renders cell result [field] represented as [FieldValue] in the [host] context */ cellResult ( host : ExecutionHost , field : FieldValue , ) : Any /** * Renders cell result [field] represented as [FieldValue] in the [host] context */ cellResult ( host : ExecutionHost , field : FieldValue , ) : Any /** * Renders cell result [field] represented as [FieldValue] in the [host] context */ cellResult ( host : ExecutionHost , field : FieldValue , ) : Any /** * Renders cell result [field] represented as [FieldValue] in the [host] context */ cellResult ( host : ExecutionHost , field : FieldValue , ) : Any /** * Renders cell result [field] represented as [FieldValue] in the [host] context */ cellResult ( host : ExecutionHost , field : FieldValue ,
fun register ( renderer : RendererFieldHandler ) : null * * @param renderer * * @return code to be executed on execution host * for [PrecompiledRendererTypeHandler]'s. */ public static Code register ( renderer : RendererFieldHandler ) : Code { if ( renderer == null ) { return null; } else { return new Code(renderer); } } /** * Adds new [renderer] for this notebook. * Returns code to be executed on execution host * for [PostCompiledRendererTypeHandler]'s. */ public static Code register ( renderer : RendererFieldHandler ) : Code { if ( renderer == null ) { return null; } else { return new Code(renderer); } } /** * Adds new [renderer] for this notebook. * Returns code to be executed on execution host * for [PostCompiledRendererTypeHandler]'s. */ public static Code register

{ if ( isRead ) { return this } else { return null } } /** * Search for memory write/read function in [kotlinx.cinterop.nativeMemUtils] of a given [valueType]. */ kotlinprivate fun InteropCallContext . findMemoryWriteFunction ( isRead : Boolean , valueType : IrType ) : IrFunction kotlin { if ( isRead ) { return this } else { return null } } /** * Search for memory write/read function in [kotlinx.cinterop.nativeMemUtils] of a given [valueType]. */ kotlinprivate fun InteropCallContext . findMemoryReadFunction ( isRead : Boolean , valueType : IrType ) : IrFunction kotlin { if ( isRead ) { return this } else { return null } } /** * Search for memory write/read function in [kotlinx.cinterop.nativeMemUtils] of a given [valueType]. *
= sourceClass.castToBoolean ( value ) /** * Perform (value == 0) */ private fun InteropCallContext . castToBoolean ( sourceClass : IrClassSymbol , value : IrExpression ) : IrExpression zero = sourceClass.castToBoolean ( value ) /** * Perform (value < 0) */ private fun InteropCallContext . castToBoolean ( sourceClass : IrClassSymbol , value : IrExpression ) : IrExpression negative = sourceClass.castToBoolean ( value ) /** * Perform (value > 0) */ private fun InteropCallContext . castToBoolean ( sourceClass : IrClassSymbol , value : IrExpression ) : IrExpression positive = sourceClass.castToBoolean ( value ) /** * Perform (value == 0) */ private fun InteropCallContext . castToBoolean ( sourceClass : IrClassSymbol , value : IrExpression ) : IrExpression zero = sourceClass.castToBoolean ( value ) /** * Perform (value < 0) */ private fun InteropCallContext .
{ if ( value ) { return targetClass.castFromBoolean ( targetClass , true ) } else { return targetClass.castFromBoolean ( targetClass , false ) } } /** * Perform if (value) 1 else 0 */ /** * Perform if (value) 1 else 0 */ /** * Perform if (value) 1 else 0 */ /** * Perform if (value) 1 else 0 */ /** * Perform if (value) 1 else 0 */ /** * Perform if (value) 1 else 0 */ /** * Perform if (value) 1 else 0 */ /** * Perform if (value) 1 else 0 */ /** * Perform if (value) 1 else 0 */ /** * Perform if (value) 1 else 0 */ /** * Perform if (value) 1 else 0 */ /** * Perform if (value) 1 else 0 */

ModuleMetadata ( name ) { var metadata : SerializedMetadata = new SerializedMetadata (); metadata.name = name; metadata.version = "1.0.0"; metadata.description = ""; metadata.author = ""; metadata.license = ""; metadata.copyright = ""; return metadata; } /** * Loads metadata for the specified module. * * @param name The name of the module. * * @return The metadata for the specified module. */ function loadModuleMetadata ( name : String ) : SerializedMetadata { var metadata : SerializedMetadata = new SerializedMetadata (); metadata.name = name; metadata.version = "1.0.0"; metadata.description = ""; metadata.author = ""; metadata.license = ""; metadata.copyright = ""; return metadata; } /** * Loads metadata for the specified module. * * @param name The name of the module. * * @return The metadata for
import java.io.File; import java.io.FileNotFoundException; import java.io.FileWriter; import java.io.IOException; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator; import java.util.List; import java.util.Set; import java.util.stream.Collectors; import java.util.stream.Collectors.toList; import java.util.stream.Collectors.toSet; import java.util.stream.Collectors.toMap; import java.util.stream.Collectors.toList; import java.util.stream.Collectors.toSet; import java.util.stream.Collectors.toMap; import java.util.stream.Collectors.toList; import java.util.stream.Collectors.toSet; import java.util.stream.Collectors.toMap; import java.util.stream.Collectors.toList; import java.util.stream.Collectors.toSet;
lib/platform utils are used in app/platform with deduced return type. */ import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Date; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.Map.EntrySet; import java.util.Set; import java.util.stream.Collectors; import java.util.stream.Collectors.toList; import java.util.stream.Collectors.toMap; import java.util.stream.Collectors.toSet; import java.util.stream.Collectors.toList; import java.util.stream.Collectors.toMap; import java.util.stream.Collectors.toSet; import java.util.stream.Collectors.toList; import java.util.stream.Collectors.toMap; import java.util.stream.Collectors.toSet; import java.util.stream.Collectors.toList; import java.util
import java.io.File; import java.io.FileNotFoundException; import java.io.FileWriter; import java.io.IOException; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Date; import java.util.DateTime; import java.util.List; import java.util.Set; import java.util.stream.Collectors; import java.util.stream.Collectors.toList; import java.util.stream.Collectors.toSet; import java.util.stream.Collectors.toMap; import java.util.stream.Collectors.toList; import java.util.stream.Collectors.toSet; import java.util.stream.Collectors.toMap; import java.util.stream.Collectors.toList; import java.util.stream.Collectors.toSet; import java.util.stream.Collectors.toMap; import java.util.stream.Collectors.toList; import java.util.
A: You can use the following code: import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.Set; import java.util.stream.Collectors; import java.util.stream.Collectors.toMap; import java.util.stream.Collectors.toList; import java.util.stream.Collectors.toSet; import java.util.stream.Collectors.toMap; import java.util.stream.Collectors.toList; import java.util.stream.Collectors.toSet; import java.util.stream.Collectors.toMap; import java.util.stream.Collectors.toList; import java.util.stream.Collectors.toSet; import java.util.stream.Collectors.toMap; import java.util.stream.Collectors.toList; import java.util.stream
ableAsErrorMethod { @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked
#include <stdio.h> #include <stdlib.h> #include <string.h> #include <unistd.h> #include <sys/types.h> #include <sys/stat.h> #include <sys/wait.h> #include <fcntl.h> #include <fcntl.h> #include <fcntl.h> #include <fcntl.h> #include <fcntl.h> #include <fcntl.h> #include <fcntl.h> #include <fcntl.h> #include <fcntl.h> #include <fcntl.h> #include <fcntl.h> #include <fcntl.h> #include <fcntl.h> #include <fcntl.h> #include <fcntl.h> #include <fcntl.h> #include <fcntl.h> #include <fcntl.h> #include <fcntl.h
{ if ( context == null ) { context = new CoroutineContext (); } if ( ! context.hasContinuationInterceptor ) { context.hasContinuationInterceptor = false; } if ( ! context.hasDebuggingFacility ) { context.hasDebuggingFacility = false; } if ( ! context.hasCopyableThreadLocal ) { context.hasCopyableThreadLocal = false; } if ( ! context.hasThreadLocal ) { context.hasThreadLocal = false; } if ( ! context.hasDispatcher ) { context.hasDispatcher = false; } if ( ! context.hasDefaultDispatcher ) { context.hasDefaultDispatcher = false; } if ( ! context.hasDefaultContinuationInterceptor ) { context.hasDefaultContinuationInterceptor = false; } if ( ! context.hasDefaultDebuggingFacility ) {
* @param addedContext addedContext * @return addedContext */ /** * Creates a context for coroutine builder functions that do launch a new coroutine, e.g. [withContext]. * @suppress */ /** * Creates a context for coroutine builder functions that do launch a new coroutine, e.g. [withContext]. * @param addedContext addedContext * @return addedContext */ /** * Creates a context for coroutine builder functions that do launch a new coroutine, e.g. [withContext]. * @param addedContext addedContext * @return addedContext */ /** * Creates a context for coroutine builder functions that do launch a new coroutine, e.g. [withContext]. * @param addedContext addedContext * @return addedContext */ /** * Creates a context for coroutine builder functions that do launch a new coroutine, e.g. [withContext]. * @param addedContext addedContext * @return addedContext */ /** * Creates a
{ println("The answer to life, the universe, and everything is: ") println(theAnswer) } A: You can do it like this: fun main() { println("The answer to life, the universe, and everything is: ") println(theAnswer()) } fun theAnswer () : String { println("The answer to life, the universe, and everything is: ") println("The answer to life, the universe, and everything is: ") println("The answer to life, the universe, and everything is: ") println("The answer to life, the universe, and everything is: ") println("The answer to life, the universe, and everything is: ") println("The answer to life, the universe, and everything is: ") println("The answer to life, the universe, and everything is: ") println("The answer to life, the universe, and everything is: ") println("The answer to life, the universe, and everything is: ") println("The answer to life, the universe,
applicationContext : ApplicationContext { return applicationContext; } /** * Allow the application context to be injected but require that it be annotated with * [@Annotation][ForApplication] to explicitly differentiate it from an activity context. */ applicationContext : ApplicationContext { return applicationContext; } /** * Allow the application context to be injected but require that it be annotated with * [@Annotation][ForApplication] to explicitly differentiate it from an activity context. */ applicationContext : ApplicationContext { return applicationContext; } /** * Allow the application context to be injected but require that it be annotated with * [@Annotation][ForApplication] to explicitly differentiate it from an activity context. */ applicationContext : ApplicationContext { return applicationContext; } /** * Allow the application context to be injected but require that it be annotated with * [@Annotation][ForApplication] to explicitly differentiate it from an activity context. */ applicationContext : ApplicationContext { return applicationContext; } /** * Allow the application context to be injected but require that it be
fun { /* * This example demonstrates the inference concept on MoveNetSinglePoseLighting model: * - Model is obtained from [ONNXModelHub]. * - Model predicts on a few images located in resources. * - Special preprocessing is applied to each image before prediction. */ /* * This example demonstrates the inference concept on MoveNetSinglePoseLighting model: * - Model is obtained from [ONNXModelHub]. * - Model predicts on a few images located in resources. * - Special preprocessing is applied to each image before prediction. */ /* * This example demonstrates the inference concept on MoveNetSinglePoseLighting model: * - Model is obtained from [ONNXModelHub]. * - Model predicts on a few images located in resources. * - Special preprocessing is applied to each image before prediction. */ /* * This example demonstrates the inference concept on MoveNetSinglePoseLighting model: * - Model is obtained from [ONNXModelHub]. * - Model predicts on a few image
( ) { var a = [1,2,3,4,5,6,7,8,9] var b = [1,2,3,4,5,6,7,8,9] var c = [1,2,3,4,5,6,7,8,9] var d = [1,2,3,4,5,6,7,8,9] var e = [1,2,3,4,5,6,7,8,9] var f = [1,2,3,4,5,6,7,8,9] var g = [1,2,3,4,5,6,7,8,9] var h = [1,2,3,4,5,6,7,8,9] var i = [1,2,3,4,5,6,7,8,9] var j = [1,2,3,4,5,6,7,8,9] var k = [1,2,3
: String { if ( this == null ) { return "null" } else if ( this.isEmpty() ) { return "empty" } else if ( this.size() == 1 ) { return "one" } else if ( this.size() == 2 ) { return "two" } else if ( this.size() == 3 ) { return "three" } else if ( this.size() == 4 ) { return "four" } else if ( this.size() == 5 ) { return "five" } else if ( this.size() == 6 ) { return "six" } else if ( this.size() == 7 ) { return "seven" } else if ( this.size() == 8 ) { return "eight" } else if ( this.size() == 9 ) { return "nine" } else if ( this.size() == 10 ) { return "ten" } else if ( this.size() == 11 ) { return "ele











{ if ( input == null ) { return false; } if ( input.length() == 0 ) { return false; } if ( input.charAt(0) == '[' ) { return false; } if ( input.charAt(0) == '{' ) { return false; } if ( input.charAt(0) == '(' ) { return false; } if ( input.charAt(0) == ')' ) { return false; } if ( input.charAt(0) == '[' ) { return false; } if ( input.charAt(0) == '{' ) { return false; } if ( input.charAt(0) == '(' ) { return false; } if ( input.charAt(0) == ')' ) { return false; } if ( input.charAt(0) == '[' ) { return false; }


/** Indicates whether the regular expression can find at least one match in the specified [input]. */ { var regex = new Regex(input); var match = regex.Match(input); return match != null; } /** Indicates whether the regular expression can find at least one match in the specified [input]. */ fun containsMatchIn ( input : CharSequence ) : Boolean { var regex = new Regex(input); var match = regex.Match(input); return match != null; } /** Indicates whether the regular expression can find at least one match in the specified [input]. */ fun containsMatchIn ( input : CharSequence ) : Boolean { var regex = new Regex(input); var match = regex.Match(input); return match != null; } /** Indicates whether the regular expression can find at least one match in the specified [input]. */ fun containsMatchIn ( input : CharSequence ) : Boolean { var regex = new Regex(input); var match = regex







ation = Regex.fromLiteral(literal) /** * Returns a regular expression that matches the specified [literal] string literally. * No characters of that string will have special meaning when searching for an occurrence of the regular expression. */ fromLiteral ( literal : String ) = Regex.fromLiteral(literal) /** * Returns a regular expression that matches the specified [literal] string literally. * No characters of that string will have special meaning when searching for an occurrence of the regular expression. */ fromLiteral ( literal : String ) = Regex.fromLiteral(literal) /** * Returns a regular expression that matches the specified [literal] string literally. * No characters of that string will have special meaning when searching for an occurrence of the regular expression. */ fromLiteral ( literal : String ) = Regex.fromLiteral(literal) /** * Returns a regular expression that matches the specified [literal] string literally. * No characters of that string will have special meaning when searching for an occurrence of the regular expression. */ fromLiteral ( literal : String
{ if ( literal.isEmpty() ) { return "" } else if ( literal.isBlank() ) { return "" } else if ( literal.isBlankLine() ) { return "" } else if ( literal.isBlankColumn() ) { return "" } else if ( literal.isBlankRow() ) { return "" } else if ( literal.isBlankColumn() ) { return "" } else if ( literal.isBlankRow() ) { return "" } else if ( literal.isBlankColumn() ) { return "" } else if ( literal.isBlankRow() ) { return "" } else if ( literal.isBlankColumn() ) { return "" } else if ( literal.isBlankRow() ) { return "" } else if ( literal.isBlankColumn() ) { return "" } else if ( literal.isBlankRow() ) { return "" } else if ( literal.isBlankColumn()
{ if ( literal.isEmpty() ) { return "" } else if ( literal.isBlank() ) { return "" } else if ( literal.isBlankLine() ) { return "" } else if ( literal.isBlankLine() ) { return "" } else if ( literal.isBlankLine() ) { return "" } else if ( literal.isBlankLine() ) { return "" } else if ( literal.isBlankLine() ) { return "" } else if ( literal.isBlankLine() ) { return "" } else if ( literal.isBlankLine() ) { return "" } else if ( literal.isBlankLine() ) { return "" } else if ( literal.isBlankLine() ) { return "" } else if ( literal.isBlankLine() ) { return "" } else if ( literal.isBlankLine() ) { return "" } else if ( literal.isBlankLine()
{ if ( this == '\uD800' || this == '\uDC00' || this == '\uDC01' || this == '\uDC02' || this == '\uDC03' || this == '\uDC04' || this == '\uDC05' || this == '\uDC06' || this == '\uDC07' || this == '\uDC08' || this == '\uDC09' || this == '\uDC0A' || this == '\uDC0B' || this == '\uDC0C' || this == '\uDC0D' || this == '\uDC0E' || this == '\uDC0F' || this == '\uDC10' || this == '\uDC11' || this == '\uDC12' || this == '\uDC13' || this == '\uDC14' || this == '\uDC15' || this == '\uDC16' || this == '\uDC17' || this == '\uDC18' || this == '\uDC19' || this ==
{ if ( this == '\uD800' || this == '\uDC00' || this == '\uDC01' || this == '\uDC02' || this == '\uDC03' || this == '\uDC04' || this == '\uDC05' || this == '\uDC06' || this == '\uDC07' || this == '\uDC08' || this == '\uDC09' || this == '\uDC0A' || this == '\uDC0B' || this == '\uDC0C' || this == '\uDC0D' || this == '\uDC0E' || this == '\uDC0F' || this == '\uDC10' || this == '\uDC11' || this == '\uDC12' || this == '\uDC13' || this == '\uDC14' || this == '\uDC15' || this == '\uDC16' || this == '\uDC17' || this == '\uDC18' || this == '\uDC19' || this ==
{ if ( chars.isEmpty() ) { return "" } if ( chars.length == 1 ) { return chars[0] } if ( chars.length == 2 ) { return chars[0] + chars[1] } if ( chars.length == 3 ) { return chars[0] + chars[1] + chars[2] } if ( chars.length == 4 ) { return chars[0] + chars[1] + chars[2] + chars[3] } if ( chars.length == 5 ) { return chars[0] + chars[1] + chars[2] + chars[3] + chars[4] } if ( chars.length == 6 ) { return chars[0] + chars[1] + chars[2] + chars[3] + chars[4] + chars[5] } if ( chars.length == 7 ) { return chars[0] + chars[1] + chars[2] + chars[3] + chars[

{ var result = "" for ( var i = 0; i < this.size; i++ ) { result += this[i] } return result } /** * Concatenates characters in this [CharArray] into a String. */ kotlin@ SinceKotlin ( " kotlin " ) ike public expect fun CharArray . concatToString ( ) : String ike { var result = "" for ( var i = 0; i < this.size; i++ ) { result += this[i] } return result } /** * Concatenates characters in this [CharArray] into a String. */ kotlin@ SinceKotlin ( " kotlin " ) ike public expect fun CharArray . concatToString ( ) : String ike { var result = "" for ( var i = 0; i < this.size; i++ ) { result += this[i] } return result } /** * Concatenates characters in this [CharArray] into

*/ fun String.toCharArray () : CharArray { return this.toCharArray ( ) } /** * Returns a [CharArray] containing characters of this string. */ this.toCharArray ( ) : CharArray /** * Returns a [CharArray] containing characters of this string. */ this.toCharArray ( ) : CharArray /** * Returns a [CharArray] containing characters of this string. */ this.toCharArray ( ) : CharArray /** * Returns a [CharArray] containing characters of this string. */ this.toCharArray ( ) : CharArray /** * Returns a [CharArray] containing characters of this string. */ this.toCharArray ( ) : CharArray /** * Returns a [CharArray] containing characters of this string. */ this.toCharArray ( ) : CharArray /** * Returns a [CharArray] containing characters of this string. */ this.toCharArray ( ) : CharArray /** * Returns a [CharArray] containing characters of this string. */ this.toCharArray ( )


{ var result = "" for ( var i = 0; i < this.length; i++ ) { var byte = this[i] if ( byte < 0x80 ) { result += String.fromCharCode( byte ) } else if ( byte < 0x800 ) { result += String.fromCharCode( 0xD800 + ( byte - 0x800 ) ) } else if ( byte < 0x10000 ) { result += String.fromCharCode( 0xDC00 + ( byte - 0x10000 ) ) } else if ( byte < 0x1000000 ) { result += String.fromCharCode( 0xD800 + ( byte - 0x1000000 ) ) } else if ( byte < 0x10000000 ) { result += String.fromCharCode( 0xDC00 + ( byte - 0x10000000 ) ) } else if ( byte < 0x100000000 ) { result += String.fromCharCode( 0xD800 + ( byte - 0x100000000 ) ) } else if ( byte < 0x1000000

{ if ( this == null ) throw new IllegalArgumentException ("null") if ( this.isEmpty() ) throw new IllegalArgumentException ("empty") if ( this.isBlank() ) throw new IllegalArgumentException ("blank") if ( this.isUpperCase() ) throw new IllegalArgumentException ("upper case") if ( this.isLowerCase() ) throw new IllegalArgumentException ("lower case") if ( this.isDigit() ) throw new IllegalArgumentException ("digit") if ( this.isWhitespace() ) throw new IllegalArgumentException ("whitespace") if ( this.isPunctuation() ) throw new IllegalArgumentException ("punctuation") if ( this.isSymbol() ) throw new IllegalArgumentException ("symbol") if ( this.isUnderscore() ) throw new IllegalArgumentException ("underscore") if ( this.isColon() ) throw new IllegalArgumentException ("colon") if ( this.isPeriod() ) throw new IllegalArgumentException ("period") if ( this.

{ if ( n < 0 ) { throw new IllegalArgumentException ("repeat: n < 0") } if ( n == 0 ) { return "" } if ( n == 1 ) { return this } if ( n == 2 ) { return this + this } if ( n == 3 ) { return this + this + this } if ( n == 4 ) { return this + this + this + this } if ( n == 5 ) { return this + this + this + this + this } if ( n == 6 ) { return this + this + this + this + this + this } if ( n == 7 ) { return this + this + this + this + this + this + this + this } if ( n == 8 ) { return this + this + this + this + this + this + this + this + this + this } if ( n == 9 ) { return this + this + this + this + this +
{ if ( ignoreCase ) { oldChar = oldChar.toUpperCase() newChar = newChar.toUpperCase() } else { oldChar = oldChar.toLowerCase() newChar = newChar.toLowerCase() } var sb = new StringBuilder() for ( var i = 0 ; i < this.length ; i++ ) { if ( this[i] == oldChar ) { sb.append( newChar ) } else { sb.append( this[i] ) } } return sb.toString() } /** * Returns a new string with all occurrences of [oldChar] replaced with [newChar]. * * @sample samples.text.Strings.replaceAll */ public expect fun String . replaceAll ( oldChar : Char , newChar : Char , ignoreCase : Boolean = false ) : String aa { if ( ignoreCase ) { oldChar = oldChar.toUpperCase() newChar = newChar.toUpperCase
{ * * @return a new string obtained by replacing all occurrences of the [oldValue] substring in this string * with the specified [newValue] string. * * @return a new string obtained by replacing all occurrences of the [oldValue] substring in this string * with the specified [newValue] string. * * @return a new string obtained by replacing all occurrences of the [oldValue] substring in this string * with the specified [newValue] string. * * @return a new string obtained by replacing all occurrences of the [oldValue] substring in this string * with the specified [newValue] string. * * @return a new string obtained by replacing all occurrences of the [oldValue] substring in this string * with the specified [newValue] string. * * @return a new string obtained by replacing all occurrences of the [oldValue] substring in this string * with the specified [newValue] string. * * @return a new string obtained by replacing all occurrences of the [oldValue] substring in this string * with the specified [newValue] string. *
{ if ( ignoreCase ) { oldChar = oldChar.toLowerCase() newChar = newChar.toLowerCase() } else { oldChar = oldChar.toUpperCase() newChar = newChar.toUpperCase() } return this.replaceFirst ( oldChar , newChar ) } /** * Returns a new string with all occurrences of [oldChar] replaced with [newChar]. */ replaceAll fun String . replaceAll ( oldChar : Char , newChar : Char , ignoreCase : Boolean = false ) : String ia { if ( ignoreCase ) { oldChar = oldChar.toLowerCase() newChar = newChar.toLowerCase() } else { oldChar = oldChar.toUpperCase() newChar = newChar.toUpperCase() } return this.replaceAll ( oldChar , newChar ) } /** * Returns a new string with all occurrences of [oldChar] replaced with [newChar]. */ replaceAll fun String . replaceAll ( oldChar :
{ if ( ignoreCase ) { oldValue = oldValue.toLowerCase() newValue = newValue.toLowerCase() } else { oldValue = oldValue.toUpperCase() newValue = newValue.toUpperCase() } var index = this.indexOf ( oldValue ) if ( index == -1 ) { return this } else { return this.substring ( 0 , index ) + newValue + this.substring ( index + oldValue.length , this.length ) } } /** * Returns a new string obtained by replacing the last occurrence of the [oldValue] substring in this string * with the specified [newValue] string. */ replaceLast fun String . replaceLast ( oldValue : String , newValue : String , ignoreCase : Boolean = false ) : String ik { if ( ignoreCase ) { oldValue = oldValue.toLowerCase() newValue = newValue.toLowerCase() } else { oldValue = oldValue.toUpperCase()

{ if ( ignoreCase ) { return this.compareToIgnoreCase ( other ) } else { return this.compareTo ( other ) } } /** * Compares two strings lexicographically, ignoring case differences. * * If [ignoreCase] is true, the result of `Char.uppercaseChar().lowercaseChar()` on each character is compared. */ fun String.compareToIgnoreCase ( other : String , ignoreCase : Boolean = false ) : Int { if ( ignoreCase ) { return this.compareToIgnoreCaseIgnoreCase ( other ) } else { return this.compareToIgnoreCase ( other ) } } /** * Compares two strings lexicographically, ignoring case differences. * * If [ignoreCase] is true, the result of `Char.uppercaseChar().lowercaseChar()` on each character is compared. */ fun String.compareToIgnoreCaseIgnoreCase ( other : String , ignoreCase : Boolean = false ) : Int { if (


/** * Returns `true` if this string is not `null` and its content is equal to the word "false", ignoring case, and `false` otherwise. * * There are also strict versions of the function available on non-nullable String, [toBooleanStrict] and [toBooleanStrictOrNull]. */ /** * Returns `true` if this string is not `null` and its content is equal to the word "true", ignoring case, and `false` otherwise. * * There are also strict versions of the function available on non-nullable String, [toBooleanStrict] and [toBooleanStrictOrNull]. */ /** * Returns `true` if this string is not `null` and its content is equal to the word "false", ignoring case, and `false` otherwise. * * There are also strict versions of the function available on non-nullable String, [toBooleanStrict] and [toBooleanStrictOrNull]. */ /** * Returns `true` if this string is not `null` and its content is equal to the word "true",
{ try { return Byte.parseByte(this) } catch (NumberFormatException e) { throw new NumberFormatException(e) } } /** * Parses the string as an unsigned [Byte] number and returns the result. * @throws NumberFormatException if the string is not a valid representation of a number. */ igpublic expect fun String . toByte ( ) : Byte ig { try { return Byte.parseByte(this) } catch (NumberFormatException e) { throw new NumberFormatException(e) } } /** * Parses the string as a signed [Int] number and returns the result. * @throws NumberFormatException if the string is not a valid representation of a number. */ igpublic expect fun String . toInt ( ) : Int ig { try { return Int.parseInt(this) } catch (NumberFormatException e) { throw new NumberFormatException(e) } } /** * Parses the string as an unsigned [Int] number and returns the result.
{ if ( radix < 2 || radix > 16 ) { throw new IllegalArgumentException("radix must be between 2 and 16") } if ( radix < 10 ) { throw new IllegalArgumentException("radix must be between 10 and 36") } if ( radix > 36 ) { throw new IllegalArgumentException("radix must be between 10 and 36") } if ( radix < 2 || radix > 16 ) { throw new IllegalArgumentException("radix must be between 2 and 16") } if ( radix < 10 ) { throw new IllegalArgumentException("radix must be between 10 and 36") } if ( radix > 36 ) { throw new IllegalArgumentException("radix must be between 10 and 36") } if ( radix < 2 || radix > 16 ) { throw new IllegalArgumentException("radix must be between 2 and 16") } if ( radix < 10 ) { throw new IllegalArgumentException("radix must be
{ try { return Long.parseLong(this) } catch (NumberFormatException e) { throw new NumberFormatException(e.getMessage()) } } /** * Parses the string as a [Long] number and returns the result. * @throws NumberFormatException if the string is not a valid representation of a number. */ bobpublic expect fun String . toLong ( ) : Long abc { try { return Long.parseLong(this) } catch (NumberFormatException e) { throw new NumberFormatException(e.getMessage()) } } /** * Parses the string as a [Double] number and returns the result. * @throws NumberFormatException if the string is not a valid representation of a number. */ bobpublic expect fun String . toDouble ( ) : Double abc { try { return Double.parseDouble(this) } catch (NumberFormatException e) { throw new NumberFormatException(e.getMessage()) } } /** * Parses the string as a [
{ if ( radix < 0 || radix > 9 ) { throw new IllegalArgumentException("radix must be between 0 and 9") } if ( radix < 2 ) { throw new IllegalArgumentException("radix must be greater than or equal to 2") } if ( radix < 10 ) { throw new IllegalArgumentException("radix must be greater than or equal to 10") } if ( radix == 10 ) { throw new IllegalArgumentException("radix must be greater than or equal to 10") } if ( radix == 11 ) { throw new IllegalArgumentException("radix must be greater than or equal to 11") } if ( radix == 12 ) { throw new IllegalArgumentException("radix must be greater than or equal to 12") } if ( radix == 13 ) { throw new IllegalArgumentException("radix must be greater than or equal to 13") } if ( radix == 14 ) { throw new IllegalArgumentException("radix
{ try { return Int(this) } catch (NumberFormatException e) { throw new NumberFormatException(e) } } /** * Parses the string as an [Int] number and returns the result. * @throws NumberFormatException if the string is not a valid representation of a number. */ /** * Parses the string as an [Int] number and returns the result. * @throws NumberFormatException if the string is not a valid representation of a number. */ /** * Parses the string as an [Int] number and returns the result. * @throws NumberFormatException if the string is not a valid representation of a number. */ /** * Parses the string as an [Int] number and returns the result. * @throws NumberFormatException if the string is not a valid representation of a number. */ /** * Parses the string as an [Int] number and returns the result. * @throws NumberFormatException if the string is not a valid representation of a number. */ /** * Parses the string as an [Int
{ if ( radix < 0 || radix > 9 ) { throw new IllegalArgumentException("radix must be between 0 and 9") } if ( radix < 2 ) { throw new IllegalArgumentException("radix must be greater than or equal to 2") } if ( radix < 10 ) { throw new IllegalArgumentException("radix must be greater than or equal to 10") } if ( radix < 16 ) { throw new IllegalArgumentException("radix must be greater than or equal to 16") } if ( radix < 32 ) { throw new IllegalArgumentException("radix must be greater than or equal to 32") } if ( radix < 64 ) { throw new IllegalArgumentException("radix must be greater than or equal to 64") } if ( radix < 128 ) { throw new IllegalArgumentException("radix must be greater than or equal to 128") } if ( radix < 256 ) { throw new IllegalArgumentException("radix
{ try { return Long.parseLong(this) } catch (NumberFormatException e) { throw new NumberFormatException(e) } } /** * Parses the string as a [Double] number and returns the result. * @throws NumberFormatException if the string is not a valid representation of a number. */ bobpublic expect fun String . toDouble ( ) : Double bob { try { return Double.parseDouble(this) } catch (NumberFormatException e) { throw new NumberFormatException(e) } } /** * Parses the string as a [Long] number and returns the result. * @throws NumberFormatException if the string is not a valid representation of a number. */ bobpublic expect fun String . toLong ( ) : Long bob { try { return Long.parseLong(this) } catch (NumberFormatException e) { throw new NumberFormatException(e) } } /** * Parses the string as a [Double] number and returns the result. * @
{ if ( radix < 0 || radix > 9 ) { throw new IllegalArgumentException("radix must be between 0 and 9") } if ( radix == 10 ) { throw new IllegalArgumentException("radix must be between 0 and 9") } if ( radix == 11 ) { throw new IllegalArgumentException("radix must be between 0 and 9") } if ( radix == 12 ) { throw new IllegalArgumentException("radix must be between 0 and 9") } if ( radix == 13 ) { throw new IllegalArgumentException("radix must be between 0 and 9") } if ( radix == 14 ) { throw new IllegalArgumentException("radix must be between 0 and 9") } if ( radix == 15 ) { throw new IllegalArgumentException("radix must be between 0 and 9") } if ( radix == 16 ) { throw new IllegalArgumentException("radix must be between 0 and 9") }
{ try { return Double.parseDouble(this) } catch (NumberFormatException e) { throw new NumberFormatException(e.getMessage()) } } /** * Parses the string as a [Double] number and returns the result. * @throws NumberFormatException if the string is not a valid representation of a number. * @throws NumberFormatException if the string is not a valid representation of a number. * @throws NumberFormatException if the string is not a valid representation of a number. * @throws NumberFormatException if the string is not a valid representation of a number. * @throws NumberFormatException if the string is not a valid representation of a number. * @throws NumberFormatException if the string is not a valid representation of a number. * @throws NumberFormatException if the string is not a valid representation of a number. * @throws NumberFormatException if the string is not a valid representation of a number. * @throws NumberFormatException if the string is not a valid representation of a number. * @throws NumberFormatException if the string i
{ try { return Float.parseFloat(this) } catch (NumberFormatException e) { throw new NumberFormatException(e) } } /** * Parses the string as a [Double] number and returns the result. * @throws NumberFormatException if the string is not a valid representation of a number. */ bobpublic expect fun String . toDouble ( ) : Double bob { try { return Double.parseDouble(this) } catch (NumberFormatException e) { throw new NumberFormatException(e) } } /** * Parses the string as a [Int] number and returns the result. * @throws NumberFormatException if the string is not a valid representation of a number. */ bobpublic expect fun String . toInt ( ) : Int bob { try { return Int.parseInt(this) } catch (NumberFormatException e) { throw new NumberFormatException(e) } } /** * Parses the string as a [Long] number and returns the result. * @
{ try { return Double.parseDouble(this) } catch ( NumberFormatException e ) { return null } } /** * Parses the string as a [Double] number and returns the result * or `null` if the string is not a valid representation of a number. */ /** * Parses the string as a [Double] number and returns the result * or `null` if the string is not a valid representation of a number. */ /** * Parses the string as a [Double] number and returns the result * or `null` if the string is not a valid representation of a number. */ /** * Parses the string as a [Double] number and returns the result * or `null` if the string is not a valid representation of a number. */ /** * Parses the string as a [Double] number and returns the result * or `null` if the string is not a valid representation of a number. */ /** * Parses the string as a [Double] number and returns the result * or `null` if the string is not a
: null = try { val result = Float.parseFloat ( this ) return result } catch ( e : Exception ) { return null } /** * Parses the string as a [Double] number and returns the result * or `null` if the string is not a valid representation of a number. */ doublepublic expect fun String . toDoubleOrNull ( ) : Double ? d : null = try { val result = Double.parseDouble ( this ) return result } catch ( e : Exception ) { return null } /** * Parses the string as a [Int] number and returns the result * or `null` if the string is not a valid representation of a number. */ intpublic expect fun String . toIntOrNull ( ) : Int ? i : null = try { val result = Int.parseInt ( this ) return result } catch ( e : Exception ) { return null } /** * Parses the string as a [Long] number and returns the result * or `null` if
{ if ( radix < 0 || radix > 9 ) { throw IllegalArgumentException( "radix must be between 0 and 9" ) } if ( radix == 0 ) { return "0" } if ( radix == 1 ) { return "1" } if ( radix == 2 ) { return "2" } if ( radix == 3 ) { return "3" } if ( radix == 4 ) { return "4" } if ( radix == 5 ) { return "5" } if ( radix == 6 ) { return "6" } if ( radix == 7 ) { return "7" } if ( radix == 8 ) { return "8" } if ( radix == 9 ) { return "9" } if ( radix == 10 ) { return "A" } if ( radix == 11 )
{ if ( radix < 0 || radix > 9 ) throw IllegalArgumentException ( "radix must be between 0 and 9" ) if ( radix == 0 ) return "0" if ( radix == 1 ) return "1" if ( radix == 2 ) return "2" if ( radix == 3 ) return "3" if ( radix == 4 ) return "4" if ( radix == 5 ) return "5" if ( radix == 6 ) return "6" if ( radix == 7 ) return "7" if ( radix == 8 ) return "8" if ( radix == 9 ) return "9" if ( radix == 10 ) return "A" if ( radix == 11 ) return "B" if ( radix == 12 ) return "C" if ( radix == 13 ) return "D" if ( radix == 14 ) return "E" if ( radix == 15 ) return "F" if ( radix == 16 ) return "G" if
{ if ( radix < 0 || radix > 9 ) { throw IllegalArgumentException( "radix must be between 0 and 9" ) } if ( radix == 0 ) { return "0" } if ( radix == 1 ) { return "1" } if ( radix == 2 ) { return "2" } if ( radix == 3 ) { return "3" } if ( radix == 4 ) { return "4" } if ( radix == 5 ) { return "5" } if ( radix == 6 ) { return "6" } if ( radix == 7 ) { return "7" } if ( radix == 8 ) { return "8" } if ( radix == 9 ) { return "9" } if ( radix == 10 ) { return "A" } if ( radix == 11 )
{ if ( radix < 0 || radix > 9 ) { throw new IllegalArgumentException( "radix must be between 0 and 9" ) } if ( radix == 0 ) { return "0" } if ( radix == 1 ) { return "1" } if ( radix == 2 ) { return "2" } if ( radix == 3 ) { return "3" } if ( radix == 4 ) { return "4" } if ( radix == 5 ) { return "5" } if ( radix == 6 ) { return "6" } if ( radix == 7 ) { return "7" } if ( radix == 8 ) { return "8" } if ( radix == 9 ) { return "9" } if ( radix == 10 ) { return "A" } if ( radix == 11

public fun enable ( ) = this /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** * * */ /** *
: JacocoConfig { return this } /** * Use [JaCoCo](https://www.jacoco.org/jacoco/) as coverage tool with version [JACOCO_TOOL_DEFAULT_VERSION] for measure coverage and generate reports. */ jacoco public fun useJacoco ( ) : JacocoConfig { return this } /** * Use [JaCoCo](https://www.jacoco.org/jacoco/) as coverage tool with version [JACOCO_TOOL_DEFAULT_VERSION] for measure coverage and generate reports. */ jacoco public fun useJacoco ( ) : JacocoConfig { return this } /** * Use [JaCoCo](https://www.jacoco.org/jacoco/) as coverage tool with version [JACOCO_TOOL_DEFAULT_VERSION] for measure coverage and generate reports. */ jacoco public fun useJacoco ( ) : JacocoConfig { return this } /** * Use [JaCoCo](https://www.jacoco.org/jacoco/) as coverage tool with version [
Coverage: JacocoCoverage { return JacocoCoverage( version ) } /** * Use [JaCoCo](https://www.jacoco.org/jacoco/) as coverage tool with version [version] for measure coverage and generate reports. */ jacocopublic fun useJacoco ( version : String ) jacocoCoverage: JacocoCoverage { return JacocoCoverage( version ) } /** * Use [JaCoCo](https://www.jacoco.org/jacoco/) as coverage tool with version [version] for measure coverage and generate reports. */ jacocopublic fun useJacoco ( version : String ) jacocoCoverage: JacocoCoverage { return JacocoCoverage( version ) } /** * Use [JaCoCo](https://www.jacoco.org/jacoco/) as coverage tool with version [version] for measure coverage and generate reports. */ jacocopublic fun useJacoco ( version : String ) jacocoCoverage: JacocoCoverage { return JacocoCoverage( version ) } /** * Use [Ja






.org/foo/bar/Test.Inner /** * @return the fully qualified name of some class in the format: `org/foo/bar/Test.Inner` */ getQualifiedClassName ( index : Int ) : String /** * @return the fully qualified name of some class in the format: `org/foo/bar/Test.Inner` */ getQualifiedClassName ( index : Int ) : String /** * @return the fully qualified name of some class in the format: `org/foo/bar/Test.Inner` */ getQualifiedClassName ( index : Int ) : String /** * @return the fully qualified name of some class in the format: `org/foo/bar/Test.Inner` */ getQualifiedClassName ( index : Int ) : String /** * @return the fully qualified name of some class in the format: `org/foo/bar/Test.Inner` */ getQualifiedClassName ( index : Int ) : String /** * @return the fully qualified name of some class in the format: `org/foo/bar
ired = false * * @return `true` if the control graph contains at least one of the [firCandidates]. */ private fun ControlFlowGraph . contains ( firCandidates : Set < FirElement > ) : Boolean * * @return `true` if the control graph contains at least one of the [firCandidates]. */ private fun ControlFlowGraph . contains ( firCandidates : Set < FirElement > ) : Boolean * * @return `true` if the control graph contains at least one of the [firCandidates]. */ private fun ControlFlowGraph . contains ( firCandidates : Set < FirElement > ) : Boolean * * @return `true` if the control graph contains at least one of the [firCandidates]. */ private fun ControlFlowGraph . contains ( firCandidates : Set < FirElement > ) : Boolean * * @return `true` if the control graph contains at least one of the [firCandidates]. */ private fun ControlFlowGraph . contains ( firCandidates : Set < FirElement > ) : Boolean * * @return `true` if the control graph
< * > = nil * * Find the last node in a graph (or its subgraphs) that point to the given [fir] element. * * @param fir : FirElement * * Find the last node in a graph (or its subgraphs) that point to the given [fir] element. * * @param fir : FirElement * * Find the last node in a graph (or its subgraphs) that point to the given [fir] element. * * @param fir : FirElement * * Find the last node in a graph (or its subgraphs) that point to the given [fir] element. * * @param fir : FirElement * * Find the last node in a graph (or its subgraphs) that point to the given [fir] element. * * @param fir : FirElement * * Find the last node in a graph (or its subgraphs) that point to the given [fir] element. * * @param fir : FirElement * * Find
Internal fun processEvent ( marker : Any, time : Any ) { if ( marker == [marker] ) { return true; } return false; } /** Notifies the dispatcher that it should process a single event marked with [marker] happening at time [time]. */ /** Notifies the dispatcher that it should process a single event marked with [marker] happening at time [time]. */ /** Notifies the dispatcher that it should process a single event marked with [marker] happening at time [time]. */ /** Notifies the dispatcher that it should process a single event marked with [marker] happening at time [time]. */ /** Notifies the dispatcher that it should process a single event marked with [marker] happening at time [time]. */ /** Notifies the dispatcher that it should process a single event marked with [marker] happening at time [time]. */ /** Notifies the dispatcher that it should process a single event marked with [marker] happening at time [time]. */ /** Notifies the dispatcher that it should process a single event marked with [marker] happening at time [time
override fun scheduleResumeAfterDelay ( timeMillis : Long , continuation : CancellableContinuation < Unit > ) { if ( continuation == null ) { throw IllegalArgumentException () } if ( timeMillis < 0 ) { throw IllegalArgumentException () } if ( timeMillis == 0 ) { throw IllegalArgumentException () } if ( timeMillis == 1 ) { throw IllegalArgumentException () } if ( timeMillis == 2 ) { throw IllegalArgumentException () } if ( timeMillis == 3 ) { throw IllegalArgumentException () } if ( timeMillis == 4 ) { throw IllegalArgumentException () } if ( timeMillis == 5 ) { throw IllegalArgumentException () } if ( timeMillis == 6 ) { throw IllegalArgumentException () } if ( timeMillis == 7 ) { throw IllegalArgumentException () } if ( timeMillis == 8 )
override fun invokeOnTimeout ( timeMillis : Long , block : Runnable , context : CoroutineContext ) : DisposableHandle { if ( timeMillis > 0 ) { disposableHandle.dispose() disposableHandle = null } return this } /** @suppress */ fun invokeOnTimeout ( timeMillis : Long , block : Runnable , context : CoroutineContext ) : DisposableHandle override fun invokeOnTimeout ( timeMillis : Long , block : Runnable , context : CoroutineContext ) : DisposableHandle { if ( timeMillis > 0 ) { disposableHandle.dispose() disposableHandle = null } return this } /** @suppress */ fun invokeOnTimeout ( timeMillis : Long , block : Runnable , context : CoroutineContext ) : DisposableHandle override fun invokeOnTimeout ( timeMillis : Long , block : Runnable , context : CoroutineContext ) : DisposableHandle { if ( timeMillis > 0 ) { disposableHandle.di
{ if ( timeout == null ) { throw new IllegalArgumentException ( "timeout" ) ; } if ( timeout < 0 ) { throw new IllegalArgumentException ( "timeout" ) ; } if ( timeout > Duration.MAX_VALUE ) { throw new IllegalArgumentException ( "timeout" ) ; } if ( timeout.compareTo ( Duration.MAX_VALUE ) < 0 ) { throw new IllegalArgumentException ( "timeout" ) ; } if ( timeout.compareTo ( Duration.MIN_VALUE ) > 0 ) { throw new IllegalArgumentException ( "timeout" ) ; } if ( timeout.compareTo ( Duration.MAX_VALUE ) == 0 ) { throw new IllegalArgumentException ( "timeout" ) ; } if ( timeout.compareTo ( Duration.MIN_VALUE ) == -1 ) { throw new IllegalArgumentException ( "timeout" ) ; } if ( timeout.compareTo ( Duration.MAX_VALUE ) == 1 ) { throw new
( ) : Iterator < T > { return this } /** * Creates an [Iterator] for an [java.util.ArrayList], allowing to use it in `for` loops. * @sample samples.collections.Iterators.iteratorForArrayList */ /** * Creates an [Iterator] for an [java.util.List], allowing to use it in `for` loops. * @sample samples.collections.Iterators.iteratorForList */ /** * Creates an [Iterator] for an [java.util.Set], allowing to use it in `for` loops. * @sample samples.collections.Iterators.iteratorForSet */ /** * Creates an [Iterator] for an [java.util.Map], allowing to use it in `for` loops. * @sample samples.collections.Iterators.iteratorForMap */ /** * Creates an [Iterator] for an [java.util.TreeSet], allowing to use it in `for` loops. * @sample samples.collections.Iterators.iteratorForTreeSet */




SourceLinesMapping ( ) = let (sourceLinesMapping : KtSourceFileLinesMapping) : KtSourceFileLinesMapping = let (sourceLines : KtSourceFileLines) : KtSourceFileLines = let (sourceLinesMapping : KtSourceFileLinesMapping) : KtSourceFileLines = let (sourceLinesMapping : KtSourceFileLinesMapping) : KtSourceFileLines = let (sourceLines : KtSourceFileLines) : KtSourceFileLines = let (sourceLinesMapping : KtSourceFileLinesMapping) : KtSourceFileLines = let (sourceLines : KtSourceFileLines) : KtSourceFileLines = let (sourceLinesMapping : KtSourceFileLinesMapping) : KtSourceFileLines = let (sourceLines : KtSourceFileLines) : KtSourceFileLines = let




: T { return dependency } /** * Adds an `api` dependency to this entity. * * @see [HasKotlinDependencies.apiConfigurationName] * * @param dependency The dependency to add. * @param configure Additional configuration for the [dependency]. * @return The added [dependency]. */ kotlinfun < T : Dependency > api ( dependency : T , configure : Action < T > ) { return dependency } /** * Adds an `api` dependency to this entity. * * @see [HasKotlinDependencies.apiConfigurationName] * * @param dependency The dependency to add. * @param configure Additional configuration for the [dependency]. * @return The added [dependency]. */ kotlinfun < T : Dependency > api ( dependency : T , configure : Action < T > ) { return dependency } /** * Adds an `api` dependency to this entity. * * @see [HasKotlinDependencies.apiConfigurationName] * * @param dependency The dependency to add



dependency { return new T ( dependency , configure ) } /** * Adds an `implementation` dependency to this entity. * * @see [HasKotlinDependencies.implementationConfigurationName] * * @param dependency The dependency to add. * @param configure Additional configuration for the [dependency]. * @return The added [dependency]. */ kotlinfun < T : Dependency > implementation ( dependency : T , configure : T . ( ) -> Unit ) : T kotlindependency { return new T ( dependency , configure ) } /** * Adds an `implementation` dependency to this entity. * * @see [HasKotlinDependencies.implementationConfigurationName] * * @param dependency The dependency to add. * @param configure Additional configuration for the [dependency]. * @return The added [dependency]. */ kotlinfun < T : Dependency > implementation ( dependency : T , configure : T . ( ) -> Unit ) : T kotlindependency { return new T ( dependency , configure ) } /** *
/** * Adds an `implementation` dependency to this entity. * * @see [HasKotlinDependencies.implementationConfigurationName] * * @param dependency The dependency to add. * @param configure Additional configuration for the [dependency]. * @return The added [dependency]. */ /** * Adds an `implementation` dependency to this entity. * * @see [HasKotlinDependencies.implementationConfigurationName] * * @param dependency The dependency to add. * @param configure Additional configuration for the [dependency]. * @return The added [dependency]. */ /** * Adds an `implementation` dependency to this entity. * * @see [HasKotlinDependencies.implementationConfigurationName] * * @param dependency The dependency to add. * @param configure Additional configuration for the [dependency]. * @return The added [dependency]. */ /** * Adds an `implementation` dependency to this entity. * * @see [HasKotlinDependencies.implementationConfigurationName]




/** * Adds a `compileOnly` dependency to this entity. * * @see [HasKotlinDependencies.compileOnlyConfigurationName] * * @param dependency The dependency to add. * @param configure Additional configuration for the [dependency]. * @return The added [dependency]. */ /** * Adds a `compileOnly` dependency to this entity. * * @see [HasKotlinDependencies.compileOnlyConfigurationName] * * @param dependency The dependency to add. * @param configure Additional configuration for the [dependency]. * @return The added [dependency]. */ /** * Adds a `compileOnly` dependency to this entity. * * @see [HasKotlinDependencies.compileOnlyConfigurationName] * * @param dependency The dependency to add. * @param configure Additional configuration for the [dependency]. * @return The added [dependency]. */ /** * Adds a `compileOnly` dependency to this entity. * * @see [HasKotlinDependencie



( ) -> Unit { return dependency } /** * Adds a `runtimeOnly` dependency to this entity. * * @see [HasKotlinDependencies.runtimeOnlyConfigurationName] * * @param dependency The dependency to add. * @param configure Additional configuration for the [dependency]. * @return The added [dependency]. */ kotlinfun < T : Dependency > runtimeOnly ( dependency : T , configure : T . ( ) -> Unit ) : T ( ) -> Unit { return dependency } /** * Adds a `runtimeOnly` dependency to this entity. * * @see [HasKotlinDependencies.runtimeOnlyConfigurationName] * * @param dependency The dependency to add. * @param configure Additional configuration for the [dependency]. * @return The added [dependency]. */ kotlinfun < T : Dependency > runtimeOnly ( dependency : T , configure : T . ( ) -> Unit ) : T ( ) -> Unit { return dependency } /** * Adds a `runtimeOnly` dependency to this entity. * * @
: T { return dependency } /** * Adds a `runtimeOnly` dependency to this entity. * * @see [HasKotlinDependencies.runtimeOnlyConfigurationName] * * @param dependency The dependency to add. * @param configure Additional configuration for the [dependency]. * @return The added [dependency]. */ kotlinfun < T : Dependency > runtimeOnly ( dependency : T , configure : Action < T > ) { return dependency } /** * Adds a `runtimeOnly` dependency to this entity. * * @see [HasKotlinDependencies.runtimeOnlyConfigurationName] * * @param dependency The dependency to add. * @param configure Additional configuration for the [dependency]. * @return The added [dependency]. */ kotlinfun < T : Dependency > runtimeOnly ( dependency : T , configure : Action < T > ) { return dependency } /** * Adds a `runtimeOnly` dependency to this entity. * * @see [HasKotlinDependencies.runtimeOnlyConfigurationName] *




* @suppress */ public static void main ( String[] args ) { System.out.println ( "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n
* @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppre
* @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppre
* @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppress * @suppre
* * @param name * @param version * @param generateExternals * * @return */ /** * @param name * @param version * @param generateExternals * * @return */ /** * @param name * @param version * @param generateExternals * * @return */ /** * @param name * @param version * @param generateExternals * * @return */ /** * @param name * @param version * @param generateExternals * * @return */ /** * @param name * @param version * @param generateExternals * * @return */ /** * @param name * @param version * @param generateExternals * * @return */ /** * @param name * @param version * @param generateExternals * * @return */ /** * @param name * @param version * @param generateExternals * *

* * @param name * @param directory * @param generateExternals * * @return */ export default function ( name : String , directory : File , generateExternals : Boolean ) : Dependency { if ( !generateExternals ) { generateExternals = true; } if ( !directory ) { directory = "."; } if ( !name ) { name = ""; } if ( !generateExternals ) { generateExternals = true; } if ( !directory ) { directory = "."; } if ( !name ) { name = ""; } if ( !generateExternals ) { generateExternals = true; } if ( !directory ) { directory = "."; } if ( !name ) { name = ""; } if ( !generateExternals ) { generateExternals = true;

* * @param {string} directory * @param {boolean} generateExternals * @param {string} name * @param {string} path * @param {string} name * @param {string} path * @param {string} name * @param {string} path * @param {string} name * @param {string} path * @param {string} name * @param {string} path * @param {string} name * @param {string} path * @param {string} name * @param {string} path * @param {string} name * @param {string} path * @param {string} name * @param {string} path * @param {string} name * @param {string} path * @param {string} name * @param {string} path * @param {string} name * @param {string} path * @param {string} name * @param {string} path * @param {string} name * @param {string} path * @param {string} name




* @param name * @param version * @param generateExternals * @return */ public static <T> Dependency<T> fun(T name, T version, boolean generateExternals) { return new Dependency<T>(name, version, generateExternals); } /** * @param name * @param version * @param generateExternals * @return */ public static <T> Dependency<T> fun(String name, String version, boolean generateExternals) { return new Dependency<T>(name, version, generateExternals); } /** * @param name * @param version * @param generateExternals * @return */ public static <T> Dependency<T> fun(T name, T version, boolean generateExternals) { return new Dependency<T>(name, version, generateExternals); } /** * @param name * @param version * @param generateExternals * @return */ public static <T> Dependency<T> fun(

* @param name * @param directory * @param generateExternals * @return */ public static void fun ( String name , File directory , boolean generateExternals ) { if ( generateExternals ) { System.out.println ( name + ": " + directory ); } } /** * @param name * @param directory * @param generateExternals * @return */ public static void optionalNpm ( String name , File directory , boolean generateExternals ) { if ( generateExternals ) { System.out.println ( name + ": " + directory ); } } /** * @param name * @param directory * @param generateExternals * @return */ public static void externals ( String name , File directory , boolean generateExternals ) { if ( generateExternals ) { System.out.println ( name + ": " + directory ); } } /** * @param name * @param directory *

* * @param directory * * @param generateExternals * * @return */ public static void main(String[] args) { // TODO Auto-generated method stub






{ if ( token == null ) { throw new IllegalArgumentException( "Cannot completeResume on null token" ); } if ( token.isEmpty() ) { throw new IllegalArgumentException( "Cannot completeResume on empty token" ); } if ( token.isBlank() ) { throw new IllegalArgumentException( "Cannot completeResume on blank token" ); } if ( token.isNull() ) { throw new IllegalArgumentException( "Cannot completeResume on null token" ); } if ( token.isBlank() ) { throw new IllegalArgumentException( "Cannot completeResume on blank token" ); } if ( token.isBlank() ) { throw new IllegalArgumentException( "Cannot completeResume on blank token" ); } if ( token.isBlank() ) { throw new IllegalArgumentException( "Cannot completeResume on blank token" ); } if ( token.isBlank() ) { throw

: Boolean /** * Cancels this continuation with an optional cancellation `cause`. The result is `true` if this continuation was * cancelled as a result of this invocation, and `false` otherwise. */ /** * Cancels this continuation with an optional cancellation `cause`. The result is `true` if this continuation was * cancelled as a result of this invocation, and `false` otherwise. */ /** * Cancels this continuation with an optional cancellation `cause`. The result is `true` if this continuation was * cancelled as a result of this invocation, and `false` otherwise. */ /** * Cancels this continuation with an optional cancellation `cause`. The result is `true` if this continuation was * cancelled as a result of this invocation, and `false` otherwise. */ /** * Cancels this continuation with an optional cancellation `cause`. The result is `true` if this continuation was * cancelled as a result of this invocation, and `false` otherwise. */ /** * Cancels this continuation with an optional cancellation `cause`. The result is `true` if this continuation was * cancelled as a result of this invocation, and `false




: CancellableContinuation < T > ( continuation : CancellableContinuation < T > ) = { if ( continuation == null ) continuation = new CancellableContinuation < T > (); if ( handler == null ) handler = new CancellableHandler < T > (); handler.invokeOnCancellation( continuation ); return continuation; } /** * A version of `invokeOnCancellation` that accepts a class as a handler instead of a lambda, but identical otherwise. * This allows providing a custom [toString] instance that will look better during debugging. */ fun < T > CancellableContinuation < T > . invokeOnCancellation ( handler : CancellableHandler ) continuation : CancellableContinuation < T > ( continuation : CancellableContinuation < T > ) = { if ( continuation == null ) continuation = new CancellableContinuation < T > (); if ( handler == null ) handler = new CancellableHandler < T > (); handler.invokeOnCancellation( continuation ); return continuation; } /** * A version of `invokeOn

anceCancellableCoroutineReusable ( crossinline block : ( CancellableContinuationImpl < T > ) -> Unit ) : T { var continuation: CancellableContinuationImpl<T> = new CancellableContinuationImpl<T>() continuation.block = block return continuation } /** * Suspends the coroutine similar to [suspendCancellableCoroutine], but an instance of * [CancellableContinuationImpl] is reused. */ cancelContinuationReusable suspend inline fun < T > cancelCancellableCoroutineReusable ( crossinline block : ( CancellableContinuationImpl < T > ) -> Unit ) : T cancelCancellableCoroutineReusable ( crossinline block : ( CancellableContinuationImpl < T > ) -> Unit ) : T { var continuation: CancellableContinuationImpl<T> = new CancellableContinuationImpl<T>() continuation.block = block return continuation } /** * Suspends the coroutine similar to [suspendCancellableCoroutine], but an instance of * [Cance

private fun Any ?. transformKotlinToJvm ( expectedType : Class < * > ) : Any ?. transformKotlinToJvm ( expectedType : Class < * > ) : Any ?. transformKotlinToJvm ( expectedType : Class < * > ) : Any ?. transformKotlinToJvm ( expectedType : Class < * > ) : Any ?. transformKotlinToJvm ( expectedType : Class < * > ) : Any ?. transformKotlinToJvm ( expectedType : Class < * > ) : Any ?. transformKotlinToJvm ( expectedType : Class < * > ) : Any ?. transformKotlinToJvm ( expectedType : Class < * > ) : Any ?. transformKotlinToJvm ( expectedType : Class < * > ) : Any ?. transformKotlinToJvm ( expectedType : Class < * > ) : Any ?. transformKotlinToJvm ( expectedType : Class < * > ) : Any ?. transformKotlinToJvm ( expectedType : Class < * > ) : Any ?. transformKotlinToJvm ( expectedType :
( ) : ByteString { if ( this == null ) throw new IllegalArgumentException () if ( this.size() == 0 ) throw new IllegalArgumentException () if ( this.size() == 1 ) throw new IllegalArgumentException () if ( this.size() == 2 ) throw new IllegalArgumentException () if ( this.size() == 3 ) throw new IllegalArgumentException () if ( this.size() == 4 ) throw new IllegalArgumentException () if ( this.size() == 5 ) throw new IllegalArgumentException () if ( this.size() == 6 ) throw new IllegalArgumentException () if ( this.size() == 7 ) throw new IllegalArgumentException () if ( this.size() == 8 ) throw new IllegalArgumentException () if ( this.size() == 9 ) throw new IllegalArgumentException () if ( this.size() == 10 ) throw new IllegalArgumentException () if ( this.size() == 11 ) throw new IllegalArgumentException () if ( this.size() == 12 ) throw new IllegalArgumentException ()

fun = { val imageData = image.getData() val imageWidth = image.getWidth() val imageHeight = image.getHeight() val imageFormat = image.getFormat() val imageSize = image.getSize() val imageBytes = imageData.toByteArray() val imageJson = { "width" : imageWidth, "height" : imageHeight, "format" : imageFormat, "size" : imageSize, "data" : imageBytes } return imageJson } /** * Convert a BufferedImage to a PNG file encoded as a Base64 Json string. */ basefun encodeBufferedImage ( image : BufferedImage ) : JsonPrimitive basefun = { val imageData = image.getData() val imageWidth = image.getWidth() val imageHeight = image.getHeight() val imageFormat = image.getFormat() val imageSize = image.getSize() val imageBytes = imageData.toByteArray() val imageJson =












{ if ( this.isClosed() ) throw EOFException () if ( this.isClosed() ) throw IllegalStateException () if ( this.isClosed() ) throw IllegalStateException () if ( this.isClosed() ) throw IllegalStateException () if ( this.isClosed() ) throw IllegalStateException () if ( this.isClosed() ) throw IllegalStateException () if ( this.isClosed() ) throw IllegalStateException () if ( this.isClosed() ) throw IllegalStateException () if ( this.isClosed() ) throw IllegalStateException () if ( this.isClosed() ) throw IllegalStateException () if ( this.isClosed() ) throw IllegalStateException () if ( this.isClosed() ) throw IllegalStateException () if ( this.isClosed() ) throw IllegalStateException () if ( this.isClosed() ) throw IllegalStateException () if ( this.isClosed() ) throw IllegalStateException () if ( this.isClosed() ) throw IllegalStateException











Internal = input * * @param input The input operand. * * @param operation The operation to perform on the input operand. * * @return The result of the operation on the input operand. */ internal fun Ops . withExpandedDimensions ( input : Operand < Float > , operation : ( Operand < Float > ) -> Operand < Float > ) : Operand < Float > * * @param input The input operand. * * @param operation The operation to perform on the input operand. * * @return The result of the operation on the input operand. */ internal fun Ops . withExpandedDimensions ( input : Operand < Float > , operation : ( Operand < Float > ) -> Operand < Float > ) : Operand < Float > * * @param input The input operand. * * @param operation The operation to perform on the input operand. * * @return The result of the operation on the input operand. */ internal fun Ops . withExpandedDimensions ( input : Operand < Float > , operation : ( Operand < Float
* @return raw C pointer value, usable for interoperability with C scenarious. */ COpaquePointer asCPointer ( ) : COpaquePointer { return (COpaquePointer)this; } /** * Returns raw C pointer value, usable for interoperability with C scenarious. * @return raw C pointer value, usable for interoperability with C scenarious. */ COpaquePointer asCPointer ( ) : COpaquePointer { return (COpaquePointer)this; } /** * Returns raw C pointer value, usable for interoperability with C scenarious. * @return raw C pointer value, usable for interoperability with C scenarious. */ COpaquePointer asCPointer ( ) : COpaquePointer { return (COpaquePointer)this; } /** * Returns raw C pointer value, usable for interoperability with C scenarious. * @return raw C pointer value, usable for interoperability with C scenarious. */ COpaquePointer asCPointer

: null /** * Returns stack trace element that correspond to this stack frame. * The result is `null` if the stack trace element is not available for this frame. * In this case, the debugger represents this stack frame using the * result of [toString] function. */ /** * Returns stack trace element that correspond to this stack frame. * The result is `null` if the stack trace element is not available for this frame. * In this case, the debugger represents this stack frame using the * result of [toString] function. */ /** * Returns stack trace element that correspond to this stack frame. * The result is `null` if the stack trace element is not available for this frame. * In this case, the debugger represents this stack frame using the * result of [toString] function. */ /** * Returns stack trace element that correspond to this stack frame. * The result is `null` if the stack trace element is not available for this frame. * In this case, the debugger represents this stack frame using the * result of [toString] function. */ /** * Returns stack trace element that
: Operand < Float >; /** * The actual implementation of downsampling operation which each subclassed layer needs to * implement. This method will then be called from [build] method to downsample the input tensor. */ /** * The actual implementation of downsampling operation which each subclassed layer needs to * implement. This method will then be called from [build] method to downsample the input tensor. */ /** * The actual implementation of upsampling operation which each subclassed layer needs to * implement. This method will then be called from [build] method to upsample the input tensor. */ /** * The actual implementation of downsampling operation which each subclassed layer needs to * implement. This method will then be called from [build] method to downsample the input tensor. */ /** * The actual implementation of upsampling operation which each subclassed layer needs to * implement. This method will then be called from [build] method to upsample the input tensor. */ /** * The actual implementation of downsampling operation which each subclassed layer needs to * implement. This method will then be




fun refineDeclarationModality ( modifierListOwner : KtModifierListOwner , declaration : DeclarationDescriptor ? , containingDeclaration : DeclarationDescriptor ? , currentModality : Modality , isImplicitModality : Boolean ) : Modality ? * Returns the new modality for the [containingDeclaration], or null if the [currentModality] is good enough. */ ktfun refineContainingDeclarationModality ( modifierListOwner : KtModifierListOwner , declaration : DeclarationDescriptor ? , containingDeclaration : DeclarationDescriptor ? , currentModality : Modality , isImplicitModality : Boolean ) : Modality ? * Returns the new modality for the [declaration], or null if the [currentModality] is good enough. */ ktfun refineDeclarationModality ( modifierListOwner : KtModifierListOwner , declaration : DeclarationDescriptor ? , containingDeclaration : DeclarationDescriptor ? , currentModality : Modality , isImplicitModality : Boolean ) : Modality ? * Returns the new modality for the [containingDeclaration], or null if the [currentModality] is good enough
: List < Documentable > { val actualTypealias : List<ActualTypealias> = ArrayList<ActualTypealias>() val actualTypealiasActual : List<ActualTypealias> = ArrayList<ActualTypealias>() val actualTypealiasActualActual : List<ActualTypealias> = ArrayList<ActualTypealias>() val actualTypealiasActualActualActualActual : List<ActualTypealias> = ArrayList<ActualTypealias>() val actualTypealiasActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualActualAct
public fun pageForClasslikes ( documentables : List < Documentable > ) : ClasslikePageNode vain public fun pageForClasslikes ( documentables : List < Documentable > ) : ClasslikePageNode vain public fun pageForClasslikes ( documentables : List < Documentable > ) : ClasslikePageNode vain public fun pageForClasslikes ( documentables : List < Documentable > ) : ClasslikePageNode vain public fun pageForClasslikes ( documentables : List < Documentable > ) : ClasslikePageNode vain public fun pageForClasslikes ( documentables : List < Documentable > ) : ClasslikePageNode vain public fun pageForClasslikes ( documentables : List < Documentable > ) : ClasslikePageNode vain public fun pageForClasslikes ( documentables : List < Documentable > ) : ClasslikePageNode vain public fun pageForClasslikes ( documentables : List < Documentable > ) : ClasslikePageNode vain public fun pageForClasslikes ( documentables : List < Documentable > ) : ClasslikePageNode vain public fun pageForClasslikes ( documentables : List < Documentable > ) : ClasslikePageNode vain public fun page
Protected = new ContentGroup (); * @param documentables a list of [DClasslike] and [DEnumEntry] and [DTypeAlias] with the same dri in different sourceSets */ void contentForClasslikesAndEntries ( documentables : List < Documentable > ) : void * @param documentables a list of [DClasslike] and [DEnumEntry] and [DTypeAlias] with the same dri in different sourceSets */ void contentForClasslikesAndEntries ( documentables : List < Documentable > ) : void * @param documentables a list of [DClasslike] and [DEnumEntry] and [DTypeAlias] with the same dri in different sourceSets */ void contentForClasslikesAndEntries ( documentables : List < Documentable > ) : void * @param documentables a list of [DClasslike] and [DEnumEntry] and [DTypeAlias] with the same dri in different sourceSets */ void contentForClasslikesAndEntries ( documentables : List < Documentable > ) : void * @param documentables a list of [DClasslike

{ /** * Tests that [supervisorScope] cancels all its children when the current coroutine is cancelled. */ /** * Tests that [supervisorScope] cancels all its children when the current coroutine is cancelled. */ /** * Tests that [supervisorScope] cancels all its children when the current coroutine is cancelled. */ /** * Tests that [supervisorScope] cancels all its children when the current coroutine is cancelled. */ /** * Tests that [supervisorScope] cancels all its children when the current coroutine is cancelled. */ /** * Tests that [supervisorScope] cancels all its children when the current coroutine is cancelled. */ /** * Tests that [supervisorScope] cancels all its children when the current coroutine is cancelled. */ /** * Tests that [supervisorScope] cancels all its children when the current coroutine is cancelled. */ /** * Tests that [supervisorScope] cancels all its children when the current cor
( ) : PsiMethod { return this } /** * PSI doesn't return a default constructor if class doesn't contain an explicit one. * This method create synthetic constructor * Visibility modifier is preserved from the class. */ private fun PsiMethod . createDefaultConstructor ( ) : PsiMethod { return this } /** * PSI doesn't return a default constructor if class doesn't contain an explicit one. * This method create synthetic constructor * Visibility modifier is preserved from the class. */ private fun PsiMethod . createDefaultConstructor ( ) : PsiMethod { return this } /** * PSI doesn't return a default constructor if class doesn't contain an explicit one. * This method create synthetic constructor * Visibility modifier is preserved from the class. */ private fun PsiMethod . createDefaultConstructor ( ) : PsiMethod { return this } /** * PSI doesn't return a default constructor if class doesn't contain an explicit one. * This method create synthetic constructor * Visibility modifier is preserved from the class. */ private fun PsiMethod .
( PsiAnnotation ) = findJvmFieldAnnotation ( ) /** * Workaround for getting JvmField Kotlin annotation in PSIs */ kotlinprivate fun Collection < PsiAnnotation > . findJvmFieldAnnotation ( ) : Annotations . Annotation ? kotlin ( PsiAnnotation ) = findJvmFieldAnnotation ( ) /** * Workaround for getting JvmField Kotlin annotation in PSIs */ kotlinprivate fun Collection < PsiAnnotation > . findJvmFieldAnnotation ( ) : Annotations . Annotation ? kotlin ( PsiAnnotation ) = findJvmFieldAnnotation ( ) /** * Workaround for getting JvmField Kotlin annotation in PSIs */ kotlinprivate fun Collection < PsiAnnotation > . findJvmFieldAnnotation ( ) : Annotations . Annotation ? kotlin ( PsiAnnotation ) = findJvmFieldAnnotation ( ) /** * Workaround for getting JvmField Kotlin annotation in PSIs */ kotlinprivate fun Collection < PsiAnnotation > . findJvmFieldAnnotation ( ) : Annotations . Annotation
( ) : AnnotationParameterValue { return this } /** * This is a workaround for static imports from JDK like RetentionPolicy * For some reason they are not represented in the same way than using normal import */ static fun JvmAnnotationAttributeValue . toValue ( ) : AnnotationParameterValue { return this } /** * This is a workaround for static imports from JDK like RetentionPolicy * For some reason they are not represented in the same way than using normal import */ static fun JvmAnnotationAttributeValue . toValue ( ) : AnnotationParameterValue { return this } /** * This is a workaround for static imports from JDK like RetentionPolicy * For some reason they are not represented in the same way than using normal import */ static fun JvmAnnotationAttributeValue . toValue ( ) : AnnotationParameterValue { return this } /** * This is a workaround for static imports from JDK like RetentionPolicy * For some reason they are not represented in the same way than using normal import */ static fun JvmAnnotationAttributeValue . toValue ( ) : An
x () { return this } /** * Converts an instance of [CoroutineDispatcher] to an implementation of [Scheduler] * and provides native support of [delay] and [withTimeout]. */ whexpublic fun CoroutineDispatcher . asScheduler ( ) : Scheduler everywherex () { return this } /** * Converts an instance of [Scheduler] to an implementation of [CoroutineDispatcher] * and provides native support of [delay] and [withTimeout]. */ whexpublic fun Scheduler . asCoroutineDispatcher ( ) : CoroutineDispatcher everywherex () { return this } /** * Converts an instance of [CoroutineDispatcher] to an implementation of [Scheduler] * and provides native support of [delay] and [withTimeout]. */ whexpublic fun CoroutineDispatcher . asScheduler ( ) : Scheduler everywherex () { return this } /** * Converts an instance of [Scheduler] to an implementation of [CoroutineDispatcher] * and
( ) { return this } /** * Converts an instance of [Scheduler] to an implementation of [CoroutineDispatcher]. */ fleepublic fun Scheduler . asCoroutineDispatcher ( ) : CoroutineDispatcher ( ) { return this } /** * Converts an instance of [CoroutineDispatcher] to an implementation of [Scheduler]. */ fleepublic fun CoroutineDispatcher . asScheduler ( ) : Scheduler ( ) { return this } /** * Converts an instance of [Scheduler] to an implementation of [CoroutineDispatcher]. */ fleepublic fun Scheduler . asCoroutineDispatcher ( ) : CoroutineDispatcher ( ) { return this } /** * Converts an instance of [CoroutineDispatcher] to an implementation of [Scheduler]. */ fleepublic fun CoroutineDispatcher . asScheduler ( ) : Scheduler ( ) { return this } /** * Converts an instance of [Scheduler] to an implementation of [CoroutineDi
: Runnable { if ( adaptForScheduling == null ) { adaptForScheduling = block } else { adaptForScheduling = adaptForScheduling( block ) } if ( delayMillis < 0 ) { delayMillis = 0 } else { delayMillis = Math.abs( delayMillis ) } if ( adaptForScheduling == null ) { adaptForScheduling = block } else { adaptForScheduling = adaptForScheduling( block ) } if ( adaptForScheduling == null ) { adaptForScheduling = block } else { adaptForScheduling = adaptForScheduling( block ) } if ( adaptForScheduling == null ) { adaptForScheduling = block } else { adaptForScheduling = adaptForScheduling( block ) } if ( adaptForScheduling == null ) { adaptForScheduling = block } else {
xoverride fun dispatch ( context : CoroutineContext , block : Runnable ) yoverride fun dispatch ( context : CoroutineContext , block : Runnable ) zoverride fun dispatch ( context : CoroutineContext , block : Runnable ) aoverride fun dispatch ( context : CoroutineContext , block : Runnable ) boverride fun dispatch ( context : CoroutineContext , block : Runnable ) coverride fun dispatch ( context : CoroutineContext , block : Runnable ) doverride fun dispatch ( context : CoroutineContext , block : Runnable ) eoverride fun dispatch ( context : CoroutineContext , block : Runnable ) foverride fun dispatch ( context : CoroutineContext , block : Runnable ) goverride fun dispatch ( context : CoroutineContext , block : Runnable ) hoverride fun dispatch ( context : CoroutineContext , block : Runnable ) ioverride fun dispatch ( context : CoroutineContext , block : Runnable ) joverride fun dispatch ( context : CoroutineContext , block : Runnable ) koverride fun dispatch ( context : CoroutineContext , block : Runnable ) loverride fun
override fun scheduleResumeAfterDelay ( timeMillis : Long , continuation : CancellableContinuation < Unit > ) { if ( continuation == null ) { throw IllegalArgumentException () } if ( timeMillis < 0 ) { throw IllegalArgumentException () } if ( timeMillis == 0 ) { throw IllegalArgumentException () } if ( timeMillis == 1 ) { throw IllegalArgumentException () } if ( timeMillis == 2 ) { throw IllegalArgumentException () } if ( timeMillis == 3 ) { throw IllegalArgumentException () } if ( timeMillis == 4 ) { throw IllegalArgumentException () } if ( timeMillis == 5 ) { throw IllegalArgumentException () } if ( timeMillis == 6 ) { throw IllegalArgumentException () } if ( timeMillis == 7 ) { throw IllegalArgumentException () } if ( timeMillis == 8 )
override fun invokeOnTimeout ( timeMillis : Long , block : Runnable , context : CoroutineContext ) : DisposableHandle { if ( timeMillis > 0 ) { disposableHandle.dispose() disposableHandle = null } return this } /** @suppress */ fun invokeOnTimeout ( timeMillis : Long , block : Runnable , context : CoroutineContext ) : DisposableHandle override fun invokeOnTimeout ( timeMillis : Long , block : Runnable , context : CoroutineContext ) : DisposableHandle { if ( timeMillis > 0 ) { disposableHandle.dispose() disposableHandle = null } return this } /** @suppress */ fun invokeOnTimeout ( timeMillis : Long , block : Runnable , context : CoroutineContext ) : DisposableHandle override fun invokeOnTimeout ( timeMillis : Long , block : Runnable , context : CoroutineContext ) : DisposableHandle { if ( timeMillis > 0 ) { disposableHandle.di
{ if (this == other) return true if (this == null || other == null) return false if (this.getClass() != other.getClass()) return false if (this.getClass().getName() != other.getClass().getName()) return false if (this.getClass().getSimpleName() != other.getClass().getSimpleName()) return false if (this.getClass().getSimpleName().equals(other.getClass().getSimpleName())) { if (this.getClass().getSimpleName().equals(other.getClass().getSimpleName())) { if (this.getClass().getSimpleName().equals(other.getClass().getSimpleName())) { if (this.getClass().getSimpleName().equals(other.getClass().getSimpleName())) { if (this.getClass().getSimpleName().equals(other.getClass().getSimpleName())) { if (this.getClass().getSimpleName().equals(other.getClass().getSimpleName())) { if (
override fun hashCode ( ) : Int override fun equals ( ) : Boolean override fun equalsIgnoreCase ( ) : Boolean override fun toString ( ) : String override fun toUpperCase ( ) : String override fun toLowerCase ( ) : String override fun isEmpty ( ) : Boolean override fun isNotEmpty ( ) : Boolean override fun length ( ) : Int override fun contains ( ) : Boolean override fun containsIgnoreCase ( ) : Boolean override fun indexOf ( ) : Int override fun indexOfIgnoreCase ( ) : Int override fun lastIndexOf ( ) : Int override fun lastIndexOfIgnoreCase ( ) : Int override fun lastIndexOfAll ( ) : Int override fun lastIndexOfAllIgnoreCase ( ) : Int override fun firstIndexOf ( ) : Int override fun firstIndexOfIgnoreCase ( ) : Int override fun firstIndexOfAll ( ) : Int override fun firstIndexOfAll

< D > { if ( !data ) { return null; } else { return transformer.transform ( data ); } } /** * Runs the provided [transformer] on the IR subtree with the root at this node. * * @param transformer The transformer to use. * @param data An arbitrary context to pass to each invocation of [transformer]'s methods. * @return The transformed node. */ irfun < D > transform ( transformer : IrElementTransformer < D > , data : D ) : IrElement < D > { if ( !data ) { return null; } else { return transformer.transform ( data ); } } /** * Runs the provided [transformer] on the IR subtree with the root at this node. * * @param transformer The transformer to use. * @param data An arbitrary context to pass to each invocation of [transformer]'s methods. * @return The transformed node. */ irfun < D > transform ( transformer : Ir


= isoString.replace("+XX:XX", "+XX").replace("+XX", "+XX:XX").replace("+XX:XX:XX", "+XX:XX:XX").replace("+XX:XX:XX:XX", "+XX:XX:XX:XX").replace("+XX:XX:XX:XX", "+XX:XX:XX:XX").replace("+XX:XX:XX:XX", "+XX:XX:XX:XX").replace("+XX:XX:XX:XX", "+XX:XX:XX:XX").replace("+XX:XX:XX:XX", "+XX:XX:XX:XX").replace("+XX:XX:XX:XX", "+XX:XX:XX:XX").replace("+XX:XX:XX:XX", "+XX:XX:XX:XX").replace("+XX:XX:XX:XX", "+XX:XX:XX:XX").replace("+XX:XX:XX:XX", "+XX:XX:XX:XX").replace("+XX:XX:XX:XX", "+XX:XX:XX:XX").replace("+XX:XX:XX:XX", "+XX:XX:






* * @param numberOfChannels The number of input channels. * @return The number of output channels. */ private fun getOutputDepth ( numberOfChannels : Long ) : Long { return numberOfChannels } /** Define the number of output channels given the number of input channels. * Defaults to the number of filter in convolutional layer. */ private fun getOutputDepth ( numberOfChannels : Long ) : Long { return numberOfChannels } /** Define the number of output channels given the number of input channels. * Defaults to the number of filter in convolutional layer. */ private fun getOutputDepth ( numberOfChannels : Long ) : Long { return numberOfChannels } /** Define the number of output channels given the number of input channels. * Defaults to the number of filter in convolutional layer. */ private fun getOutputDepth ( numberOfChannels : Long ) : Long { return numberOfChannels } /** Define the number of output channels given the number of input channel

* * @param filters for input of this layer * * @return the [bias] shape by default from its [filters] and * the given [numberOfChannels] from input Tensor. * * @return the [bias] shape by default from its [filters] and * the given [numberOfChannels] from input Tensor. * * @return the [bias] shape by default from its [filters] and * the given [numberOfChannels] from input Tensor. * * @return the [bias] shape by default from its [filters] and * the given [numberOfChannels] from input Tensor. * * @return the [bias] shape by default from its [filters] and * the given [numberOfChannels] from input Tensor. * * @return the [bias] shape by default from its [filters] and * the given [numberOfChannels] from input Tensor. * * @return the [bias] shape by default from its [filters] and * the given [numberOf
{ return name; } /** Given a layer name specify its bias name */ protected abstract fun biasVarName ( name : String ) : String bias { return name; } /** Given a layer name specify its activation name */ protected abstract fun activationVarName ( name : String ) : String activation { return name; } /** Given a layer name specify its weight name */ protected abstract fun weightVarName ( name : String ) : String weight { return name; } /** Given a layer name specify its bias name */ protected abstract fun biasVarName ( name : String ) : String bias { return name; } /** Given a layer name specify its activation name */ protected abstract fun activationVarName ( name : String ) : String activation { return name; } /** Given a layer name specify its weight name */ protected abstract fun weightVarName ( name : String ) : String weight { return name; } /** Given a layer name specify its bias name */ protected abstract fun biasVarName ( name : String
{ if ( name == null ) { return null; } else if ( name.length() == 0 ) { return null; } else if ( name.length() == 1 ) { return null; } else if ( name.length() == 2 ) { return null; } else if ( name.length() == 3 ) { return null; } else if ( name.length() == 4 ) { return null; } else if ( name.length() == 5 ) { return null; } else if ( name.length() == 6 ) { return null; } else if ( name.length() == 7 ) { return null; } else if ( name.length() == 8 ) { return null; } else if ( name.length() == 9 ) { return null; } else if ( name.length() == 10 ) { return null; } else if ( name.length() == 11 ) { return null; } else if ( name.length() == 12 )
bias ( tf : Ops , input : Operand < Float > ) : Operand < Float > /** The actual layer operation implementation without adding the bias which is added by the abstract class. */ /** The actual layer operation implementation without adding the bias which is added by the abstract class. */ /** The actual layer operation implementation without adding the bias which is added by the abstract class. */ /** The actual layer operation implementation without adding the bias which is added by the abstract class. */ /** The actual layer operation implementation without adding the bias which is added by the abstract class. */ /** The actual layer operation implementation without adding the bias which is added by the abstract class. */ /** The actual layer operation implementation without adding the bias which is added by the abstract class. */ /** The actual layer operation implementation without adding the bias which is added by the abstract class. */ /** The actual layer operation implementation without adding the bias which is added by the abstract class. */ /** The actual layer operation implementation without adding the bias which is added by the abstract class. */ /** The actual layer operation implementation without adding the bias which i

ue { return this } /** * Load class `example.Bar` via new class loader. Compiled class-file located in the resources. */ /** * Load class `example.Bar` via new class loader. Compiled class-file located in the resources. */ /** * Load class `example.Bar` via new class loader. Compiled class-file located in the resources. */ /** * Load class `example.Bar` via new class loader. Compiled class-file located in the resources. */ /** * Load class `example.Bar` via new class loader. Compiled class-file located in the resources. */ /** * Load class `example.Bar` via new class loader. Compiled class-file located in the resources. */ /** * Load class `example.Bar` via new class loader. Compiled class-file located in the resources. */ /** * Load class `example.Bar` via new class loader. Compiled class-file located in the resources. */ /** * Load class `example.Bar` via new class loader. Compiled class-file located in
public fun < T > predict ( inputData : FloatData , extractResult : ( R ) -> T ) : T { return extractResult( inputData ) } /** * Run inference on the provided [inputData] and pass inference result to the [extractResult] function. */ private fun < T > predict ( inputData : FloatData , extractResult : ( R ) -> T ) : T { return extractResult( inputData ) } /** * Run inference on the provided [inputData] and pass inference result to the [extractResult] function. */ private fun < T > predict ( inputData : FloatData , extractResult : ( R ) -> T ) : T { return extractResult( inputData ) } /** * Run inference on the provided [inputData] and pass inference result to the [extractResult] function. */ private fun < T > predict ( inputData : FloatData , extractResult : ( R ) -> T ) : T { return extractResult( inputData ) } /** * Run inference on the provided [inputData] and pass inference result to the [extractResult]
public fun < T > predict ( inputs : Map < String , FloatData > , outputs : List < String > , extractResult : ( R ) -> T ) : T = infer ( inputs , outputs , extractResult ) /** * Run inference on the provided [inputs], calculate the specified [outputs] * and pass inference result to the [extractResult] function. */ fun infer ( inputs : Map < String , FloatData > , extractResult : ( R ) -> T ) : T = infer ( inputs , outputs , extractResult ) /** * Run inference on the provided [inputs], calculate the specified [outputs] * and pass inference result to the [extractResult] function. */ fun infer ( inputs : Map < String , FloatData > , extractResult : ( R ) -> T ) : T = infer ( inputs , outputs , extractResult ) /** * Run inference on the provided [inputs], calculate the specified [outputs] * and pass inference result to the [extractResult] function. */ fun infer ( inputs : Map < String , FloatData > , extractResult : ( R ) -> T ) : T = infer
/** * Creates a copy of this model. * * @return A copied inference model. */ /** * Creates a copy of this model. * * @return A copied inference model. */ /** * Creates a copy of this model. * * @return A copied inference model. */ /** * Creates a copy of this model. * * @return A copied inference model. */ /** * Creates a copy of this model. * * @return A copied inference model. */ /** * Creates a copy of this model. * * @return A copied inference model. */ /** * Creates a copy of this model. * * @return A copied inference model. */ /** * Creates a copy of this model. * * @return A copied inference model. */ /** * Creates a copy of this model. * * @return A copied inference model. */ /** * Creates a copy of this model. * * @return A copied inference model.
{ if ( dim < 0 ) throw new IllegalArgumentException () if ( dim == 0 ) throw new IllegalArgumentException () if ( dim == 1 ) throw new IllegalArgumentException () if ( dim == 2 ) throw new IllegalArgumentException () if ( dim == 3 ) throw new IllegalArgumentException () if ( dim == 4 ) throw new IllegalArgumentException () if ( dim == 5 ) throw new IllegalArgumentException () if ( dim == 6 ) throw new IllegalArgumentException () if ( dim == 7 ) throw new IllegalArgumentException () if ( dim == 8 ) throw new IllegalArgumentException () if ( dim == 9 ) throw new IllegalArgumentException () if ( dim == 10 ) throw new IllegalArgumentException () if ( dim == 11 ) throw new IllegalArgumentException () if ( dim == 12 ) throw new IllegalArgumentException () if ( dim == 13 ) throw new IllegalArgumentException () if ( dim == 14 ) throw new IllegalArgumentException () if ( dim == 15 ) throw new IllegalArgumentException ()
{ if ( dim < 0 ) { throw new IllegalArgumentException( "Dimension must be non-negative" ) } if ( dim < 0 ) { throw new IllegalArgumentException( "Dimension must be non-negative" ) } if ( dim < 0 ) { throw new IllegalArgumentException( "Dimension must be non-negative" ) } if ( dim < 0 ) { throw new IllegalArgumentException( "Dimension must be non-negative" ) } if ( dim < 0 ) { throw new IllegalArgumentException( "Dimension must be non-negative" ) } if ( dim < 0 ) { throw new IllegalArgumentException( "Dimension must be non-negative" ) } if ( dim < 0 ) { throw new IllegalArgumentException( "Dimension must be non-negative" ) } if ( dim < 0 ) { throw new IllegalArgumentException( "Dimension must be non-negative" ) } if ( dim
( KtNDArray < T > . a ) : Boolean * * @param KtNDArray < T > . a * * @return [Boolean] value. */ fun < T : Any > KtNDArray < T > . all ( ) : Boolean /** * Test whether all array elements along a given axis evaluate to *false*. * * @return [Boolean] value. */ fun < T : Any > KtNDArray < T > . all ( ) : Boolean /** * Test whether all array elements along a given axis evaluate to *true*. * * @param KtNDArray < T > . a * * @return [Boolean] value. */ fun < T : Any > KtNDArray < T > . all ( ) : Boolean /** * Test whether all array elements along a given axis evaluate to *false*. * * @param KtNDArray < T > . a * * @return [Boolean] value. */ fun < T : Any > KtNDArray < T > . all ( ) : Boolean /** *
fun < T : Any > KtNDArray < T > ( vararg axis : Int ) : KtNDArray < Boolean > * * @param axis: [Int] or [IntArray]- axis along which a logical AND reduction is performed. * If [axis] is negative, in which case if counts from the last to the first axis. * * @return new [KtNDArray] of type [Boolean]. * * @param axis: [Int] or [IntArray]- axis along which a logical AND reduction is performed. * If [axis] is negative, in which case if counts from the last to the first axis. * * @return new [KtNDArray] of type [Boolean]. * * @param axis: [Int] or [IntArray]- axis along which a logical AND reduction is performed. * If [axis] is negative, in which case if counts from the last to the first axis. * * @return new [KtNDArray] of type [Boolean]. * * @param axis: [Int] or [IntArray]- axis along which a logical AND reduction is performed.
ue { if ( this.isEmpty() ) { return true } else { return false } } /** * Returns *true* if any element satisfies the predicate. * Using buffer. */ ktndarrayinline fun < T : Any > KtNDArray < T > . any ( predicate : ( T ) -> Boolean ) : Boolean if ( this.isEmpty() ) { return false } else { return true } } /** * Returns *true* if all elements satisfy the predicate. * Using buffer. */ ktndarrayinline fun < T : Any > KtNDArray < T > . all ( predicate : ( T ) -> Boolean ) : Boolean if ( this.isEmpty() ) { return true } else { return false } } /** * Returns *true* if any element satisfies the predicate. * Using buffer. */ ktndarrayinline fun < T : Any > KtNDArray < T > . any ( predicate : ( T ) -> Boolean ) : Boolean if ( thi
( KtNDArray < T > . a ) : Boolean * * @param KtNDArray < T > . a * * @return [Boolean] value. */ public static < T > boolean any ( KtNDArray < T > . a ) { for ( int i = 0; i < a.length; i++ ) { if ( a ( i ) ) { return true; } } return false; } /** * Test whether any array element along a given axis evaluates to *false*. * * @return [Boolean] value. */ public static < T > boolean all ( KtNDArray < T > . a ) { for ( int i = 0; i < a.length; i++ ) { if ( a ( i ) ) { return false; } } return true; } /** * Test whether all array elements along a given axis evaluate to *true*. * * @return [Boolean] value. */ public static
fun < T : Any > KtNDArray < T > . any ( vararg axis : IntArray < T > ) : KtNDArray < Boolean > * * @param axis: default none, [Int] or [IntArray] - Axis along which a logical AND reduction is performed. * If [axis] is negative, in which case it counts from the last to the first axis. * @return new [KtNDArray] of type [Boolean]. */ glorfun < T : Any > KtNDArray < T > . any ( vararg axis : Int ) : KtNDArray < Boolean > * * @param axis: default none, [Int] or [IntArray] - Axis along which a logical AND reduction is performed. * If [axis] is negative, in which case it counts from the last to the first axis. * @return new [KtNDArray] of type [Boolean]. */ glorfun < T : Any > KtNDArray < T > . all ( vararg axis : Int ) : KtNDArray < Boolean > * * @param axis: default none, [Int] or [IntArray
{ return this.any( predicate ) } /** * Returns 'true' if all elements satisfy the predicate. */ ktndarrayinline fun < T : Any > KtNDArray < T > . all ( predicate : ( T ) -> Boolean ) : Boolean bool { return this.all( predicate ) } /** * Returns 'true' if any element satisfy the predicate. */ ktndarrayinline fun < T : Any > KtNDArray < T > . any ( predicate : ( T ) -> Boolean ) : Boolean bool { return this.any( predicate ) } /** * Returns 'true' if all elements satisfy the predicate. */ ktndarrayinline fun < T : Any > KtNDArray < T > . all ( predicate : ( T ) -> Boolean ) : Boolean bool { return this.all( predicate ) } /** * Returns 'true' if any element satisfy the predicate. */ ktndarrayinline fun < T : Any > KtNDArray < T > . any ( predicate : ( T ) -> Boolean ) : Boolean bool { return this.any(
= 0 * * @return [Long] value. */ /** * Returns the indices of the maximum values along an axis. * * @return [Long] value. */ /** * Returns the indices of the maximum values along an axis. * * @return [Long] value. */ /** * Returns the indices of the maximum values along an axis. * * @return [Long] value. */ /** * Returns the indices of the maximum values along an axis. * * @return [Long] value. */ /** * Returns the indices of the maximum values along an axis. * * @return [Long] value. */ /** * Returns the indices of the maximum values along an axis. * * @return [Long] value. */ /** * Returns the indices of the maximum values along an axis. * * @return [Long] value. */ /** * Returns the indices of the maximum values along an axis. * * @return [Long] value. */ /** * Returns the indices of
fun < T : Number > KtNDArray < T > . argMin ( axis : Int ) : KtNDArray < Long > * * @param axis index is into the specified axis. By default, the index is into the flattened array. * @return new [KtNDArray] of type [Long]. Array indices into the array. * It has the same shape as shape with the dimension along [axis] removed. * * @param axis index is into the specified axis. By default, the index is into the flattened array. * @return new [KtNDArray] of type [Long]. Array indices into the array. * It has the same shape as shape with the dimension along [axis] removed. * * @param axis index is into the specified axis. By default, the index is into the flattened array. * @return new [KtNDArray] of type [Long]. Array indices into the array. * It has the same shape as shape with the dimension along [axis] removed. * * @param axis index is into the specified axis. By default, the index is into the flattened array. * @return new [K
= 0 * * @return [Long] value. */ /** * Return the indices of the maximum values along the given axis of array. * * @return [Long] value. */ /** * Return the indices of the minimum values along the given axis of array. * * @return [Long] value. */ /** * Return the indices of the maximum values along the given axis of array. * * @return [Long] value. */ /** * Return the indices of the minimum values along the given axis of array. * * @return [Long] value. */ /** * Return the indices of the maximum values along the given axis of array. * * @return [Long] value. */ /** * Return the indices of the minimum values along the given axis of array. * * @return [Long] value. */ /** * Return the indices of the maximum values along the given axis of array. * * @return [Long] value. */ /** * Return the indices of the minimum values along the given axis of
min ( axis : Int ) : KtNDArray < T > { if ( axis < 0 ) axis = axis + KtNDArray . length if ( axis < 0 ) axis = axis + KtNDArray . length if ( axis < 0 ) axis = axis + KtNDArray . length if ( axis < 0 ) axis = axis + KtNDArray . length if ( axis < 0 ) axis = axis + KtNDArray . length if ( axis < 0 ) axis = axis + KtNDArray . length if ( axis < 0 ) axis = axis + KtNDArray . length if ( axis < 0 ) axis = axis + KtNDArray . length if ( axis < 0 ) axis = axis + KtNDArray . length if ( axis < 0 ) axis = axis + KtNDArray . length if ( axis < 0 ) axis = axis + KtNDArray . length if ( axis < 0 ) axis = axis + KtNDArray . length if ( axis < 0 ) axis = axis + KtNDArray . length if ( axis

p ( ) : KtNDArray < T > { if ( ! inplace ) { KtNDArray < T > out = new KtNDArray < T > (); } else { KtNDArray < T > out = this; } for ( int i = 0; i < out.length; i++ ) { for ( int j = 0; j < out[i].length; j++ ) { KtNDArray < T > tmp = out[i][j]; out[i][j] = out[j][i]; out[j][i] = tmp; } } return out; } /** * Swap the bytes of the array elements. * * @param inplace if 'true', swap swap in-place. Default value 'false'. * @return [KtNDArray]. If inplace 'true' return view, else copy data to new buffer. */ KtNDArray < T > . byteSwap ( inplace : Boolean = false ) : KtND



( order : Order = Order . C ) : KtNDArray < T > = KtNDArray < T > . copy ( order : Order = Order . C ) : KtNDArray < T > = KtNDArray < T > . copy ( order : Order = Order . C ) : KtNDArray < T > = KtNDArray < T > . copy ( order : Order = Order . C ) : KtNDArray < T > = KtNDArray < T > . copy ( order : Order = Order . C ) : KtNDArray < T > = KtNDArray < T > . copy ( order : Order = Order . C ) : KtNDArray < T > = KtNDArray < T > . copy ( order : Order = Order . C ) : KtNDArray < T > = KtNDArray < T > . copy ( order : Order = Order . C ) : KtNDArray < T > = KtNDArray < T > . copy ( order : Order = Order . C ) : KtNDArray < T > = KtNDArray < T > . copy ( order : Order = Order . C ) : KtND



dot ( b : KtNDArray < T > ) : KtNDArray < T > * * @param b second array. * @return returns the dot product this array and b array. */ public static < T > KtNDArray < T > dot ( KtNDArray < T > b : KtNDArray < T > ) : KtNDArray < T > { KtNDArray < T > result = new KtNDArray < T > (); for ( int i = 0; i < this.length; i++ ) { result[i] = this[i] * b[i]; } return result; } /** * Dot product of two arrays. * * @param b second array. * @return returns the dot product this array and b array. */ public static < T > KtNDArray < T > dot ( KtNDArray < T > b : KtNDArray < T > ) : KtNDArray < T > { KtNDArray < T > result = new KtNDArray < T > ();
fun < T : Any > KtNDArray < T > ( file : String ) * Dump a pickle of the array to the specified file. * @param file filename. */ public static < T : Any > void dump ( KtNDArray < T > array, String file ) { try { FileOutputStream fos = new FileOutputStream ( file ); ObjectOutputStream oos = new ObjectOutputStream ( fos ); oos.writeObject ( array ); oos.close (); } catch ( IOException e ) { e.printStackTrace (); } } /** * Dump a pickle of the array to the specified file. * @param file filename. */ public static < T : Any > void dump ( KtNDArray < T > array, String file ) { try { FileOutputStream fos = new FileOutputStream ( file ); ObjectOutputStream oos = new ObjectOutputStream ( fos ); oos.writeObject ( array ); oos.close (); }
fun < T : Any > KtNDArray < T > . dumps ( ) : String { StringBuilder sb = new StringBuilder (); sb.append ( "{" ); for ( int i = 0; i < this.length; i++ ) { sb.append ( this[i] ); sb.append ( "," ); } sb.append ( "}" ); return sb.toString (); } /** * Returns the pickle of the array as a string. */ KtNDArray < T > . dumps ( ) : String { StringBuilder sb = new StringBuilder (); sb.append ( "{" ); for ( int i = 0; i < this.length; i++ ) { sb.append ( this[i] ); sb.append ( "," ); } sb.append ( "}" ); return sb.toString (); } /** * Returns the pickle of the array as a string. */ KtNDArray < T > . dumps ( ) : String {
( KtNDArray < T > a : KtNDArray < T > ) { for ( int i = 0; i < a.length; i++ ) { a[i] = value; } } /** * Fill the array with a vector value. * * @param value - all elements of a will be assigned this value. * * @param value - all elements of b will be assigned this value. * * @param value - all elements of c will be assigned this value. * * @param value - all elements of d will be assigned this value. * * @param value - all elements of e will be assigned this value. * * @param value - all elements of f will be assigned this value. * * @param value - all elements of g will be assigned this value. * * @param value - all elements of h will be assigned this value. * * @param value - all elements of i will be assigned this value. * * @param value - all elements of j will be assigned this value. * * @param value -
flatten ( order : Order = Order . C ) : KtNDArray < T > { if ( order == Order . C ) { return KtNDArray < T > (); } else if ( order == Order . D ) { return KtNDArray < T > (); } else if ( order == Order . E ) { return KtNDArray < T > (); } else if ( order == Order . F ) { return KtNDArray < T > (); } else if ( order == Order . G ) { return KtNDArray < T > (); } else if ( order == Order . H ) { return KtNDArray < T > (); } else if ( order == Order . I ) { return KtNDArray < T > (); } else if ( order == Order . J ) { return KtNDArray < T > (); } else if ( order == Order . K )

inline { return this[arg] } /** * Copy an element of an array to a standard Python/Java scalar and return it. */ fun < reified T : Any > KtNDArray < T > . item ( vararg arg : Int ) : T = this[arg] /** * Copy an element of an array to a standard Python/Java scalar and return it. */ fun < reified T : Any > KtNDArray < T > . item ( vararg arg : Int ) : T = this[arg] /** * Copy an element of an array to a standard Python/Java scalar and return it. */ fun < reified T : Any > KtNDArray < T > . item ( vararg arg : Int ) : T = this[arg] /** * Copy an element of an array to a standard Python/Java scalar and return it. */ fun < reified T : Any > KtNDArray < T > . item ( vararg arg : Int ) : T = this[arg] /** * Copy an element of an array to a standard Python/Java
inline fun < reified T : Number > KtNDArray < T > . max ( a : KtNDArray < T >, axis : int = -1 ) : reified T = a.max ( axis ) ? a : a.min ( axis ) ? a : a.max ( axis ) ? a : a.min ( axis ) ? a : a.max ( axis ) ? a : a.min ( axis ) ? a : a.max ( axis ) ? a : a.min ( axis ) ? a : a.max ( axis ) ? a : a.min ( axis ) ? a : a.max ( axis ) ? a : a.min ( axis ) ? a : a.max ( axis ) ? a : a.min ( axis ) ? a : a.max ( axis ) ? a : a.min ( axis ) ? a : a.max ( axis ) ? a : a.min ( axis ) ? a : a.max ( axis ) ? a : a.min ( axis ) ? a : a.max ( axis ) ? a : a.min ( axis ) ? a : a.max ( axis ) ? a : a.min ( axis ) ? a
fun ( ) : Double = { * var sum = 0.0 * for ( var i = 0; i < this.length; i++ ) { * sum += this[i] * } * return sum / this.length * } */ /** * Returns the maximum of the array elements along given axis. * * @return [Double]. */ /** * Returns the average of the array elements along given axis. * * @return [Double]. */ /** * Returns the maximum of the array elements along given axis. * * @return [Double]. */ /** * Returns the minimum of the array elements along given axis. * * @return [Double]. */ /** * Returns the average of the array elements along given axis. * * @return [Double]. */ /** * Returns the maximum of the array elements along given axis. * * @return [Double]. */ /** * Returns the minimum of the array elements along given axis. * * @return [Double]. */ /**
fun < T : Number > KtNDArray < T > . mean ( vararg axis : IntArray ) : KtNDArray < Double > /** * @param axis Int or IntArray - axis or axes along which the means are computed. * @return [KtNDArray]. */ varfun < T : Number > KtNDArray < T > . mean ( vararg axis : Int ) : KtNDArray < Double > /** * @param axis Int or IntArray - axis or axes along which the means are computed. * @return [KtNDArray]. */ varfun < T : Number > KtNDArray < T > . mean ( vararg axis : IntArray ) : KtNDArray < Double > /** * @param axis Int or IntArray - axis or axes along which the means are computed. * @return [KtNDArray]. */ varfun < T : Number > KtNDArray < T > . mean ( vararg axis : Int ) : KtNDArray < Double > /** * @param axis Int or IntArray - axis or axes along which the means are computed. * @
inline fun < reified T : Any > KtNDArray < T > . min ( a : KtNDArray < T >, b : KtNDArray < T > ) : reified T = a.min ( b ); /** * Return the maximum along a given axis. * * @return [T] value. */ fun < reified T : Any > KtNDArray < T > . max ( ) : T ? trickleinline fun < reified T : Any > KtNDArray < T > . max ( a : KtNDArray < T >, b : KtNDArray < T > ) : reified T = a.max ( b ); /** * Return the sum along a given axis. * * @return [T] value. */ fun < reified T : Any > KtNDArray < T > . sum ( ) : T ? trickleinline fun < reified T : Any > KtNDArray < T > . sum ( a : KtNDArray < T >, b : KtNDArray < T > ) : reified T = a.sum ( b ); /** * Return
un ( vararg axis : Int ) : KtNDArray < T > { if ( axis < 0 ) { throw new IllegalArgumentException ( "axis < 0" ); } if ( axis < 0 ) { throw new IllegalArgumentException ( "axis < 0" ); } if ( axis < 0 ) { throw new IllegalArgumentException ( "axis < 0" ); } if ( axis < 0 ) { throw new IllegalArgumentException ( "axis < 0" ); } if ( axis < 0 ) { throw new IllegalArgumentException ( "axis < 0" ); } if ( axis < 0 ) { throw new IllegalArgumentException ( "axis < 0" ); } if ( axis < 0 ) { throw new IllegalArgumentException ( "axis < 0" ); } if ( axis < 0 ) { throw new IllegalArgumentException ( "axis < 0" ); } if ( axis
ndarray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . KtNDArray < T > . Kt

inline { * * @return [T] value. */ fun < reified T : Number > KtNDArray < T > . prod ( ) : T { * * @return [T] value. */ fun < reified T : Number > KtNDArray < T > . prod ( ) : T { * * @return [T] value. */ fun < reified T : Number > KtNDArray < T > . prod ( ) : T { * * @return [T] value. */ fun < reified T : Number > KtNDArray < T > . prod ( ) : T { * * @return [T] value. */ fun < reified T : Number > KtNDArray < T > . prod ( ) : T { * * @return [T] value. */ fun < reified T : Number > KtNDArray < T > . prod ( ) : T { * * @return [T] value. */ fun < reified T : Number > KtNDArray < T > . prod ( ) : T { *
fun < T : Number > KtNDArray < T > ( vararg axis : Int ) : KtNDArray < T > ( vararg axis : Int ) : KtNDArray < T > ( vararg axis : Int ) : KtNDArray < T > ( vararg axis : Int ) : KtNDArray < T > ( vararg axis : Int ) : KtNDArray < T > ( vararg axis : Int ) : KtNDArray < T > ( vararg axis : Int ) : KtNDArray < T > ( vararg axis : Int ) : KtNDArray < T > ( vararg axis : Int ) : KtNDArray < T > ( vararg axis : Int ) : KtNDArray < T > ( vararg axis : Int ) : KtNDArray < T > ( vararg axis : Int ) : KtNDArray < T > ( vararg axis : Int ) : KtNDArray < T > ( vararg axis : Int ) : KtNDArray < T > ( vararg axis : Int ) : KtNDArray < T > ( vararg axis : Int ) : KtNDArray < T > ( vararg
( vararg axis : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axis : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axis : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axis : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axis : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axis : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axis : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axis : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axis : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axis : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axis : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axis : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axi
fun < T : Any > KtNDArray < T > . set ( indices : IntArray , values : Array < T > , mode : Mode = Mode . RAISE ) /** * Set array.flat.get(n) = values.get(n) for all n in indices. */ /** * Set array.flat.set(n) = values.set(n) for all n in indices. */ /** * Set array.flat.get(n) = values.get(n) for all n in indices. */ /** * Set array.flat.set(n) = values.set(n) for all n in indices. */ /** * Set array.flat.get(n) = values.get(n) for all n in indices. */ /** * Set array.flat.set(n) = values.set(n) for all n in indices. */ /** * Set array.flat.get(n) = values.get(n) for all n in indices. */ /** * Set array.flat.set(n) = value
flatten ( order : Order = Order . C ) : KtNDArray < T > * * @param order The order of the flattened array. * * @return view of [KtNDArray]. * */ public KtNDArray < T > ravel ( order : Order = Order . C ) : KtNDArray < T > { if ( order == Order . C ) { return this; } else if ( order == Order . F ) { return this.flatten ( order = Order . F ); } else if ( order == Order . C . F ) { return this.flatten ( order = Order . C . F ); } else if ( order == Order . C . F . F ) { return this.flatten ( order = Order . C . F . F ); } else if ( order == Order . F . F . F ) { return this.flatten ( order = Order . F . F . F ); } else if ( order == Order . F .

fun < T : Any > ( vararg dims : Int , order : Order = Order . C ) : KtNDArray < T > ( vararg dims : Int , order : Order = Order . C ) : KtNDArray < T > ( vararg dims : Int , order : Order = Order . C ) : KtNDArray < T > ( vararg dims : Int , order : Order = Order . C ) : KtNDArray < T > ( vararg dims : Int , order : Order = Order . C ) : KtNDArray < T > ( vararg dims : Int , order : Order = Order . C ) : KtNDArray < T > ( vararg dims : Int , order : Order = Order . C ) : KtNDArray < T > ( vararg dims : Int , order : Order = Order . C ) : KtNDArray < T > ( vararg dims : Int , order : Order = Order . C ) : KtNDArray < T > ( vararg dims : Int , order : Order = Order . C ) : KtNDArray < T > ( vararg dims : Int , order :
fun < T : Any > KtNDArray < T > ( vararg dims : Int ) = { if ( dims.length == 0 ) { throw new IllegalArgumentException ( "cannot resize empty array" ); } if ( dims.length == 1 ) { throw new IllegalArgumentException ( "cannot resize one-dimensional array" ); } if ( dims.length == 2 ) { throw new IllegalArgumentException ( "cannot resize two-dimensional array" ); } if ( dims.length == 3 ) { throw new IllegalArgumentException ( "cannot resize three-dimensional array" ); } if ( dims.length == 4 ) { throw new IllegalArgumentException ( "cannot resize four-dimensional array" ); } if ( dims.length == 5 ) { throw new IllegalArgumentException ( "cannot resize five-dimensional array" ); } if ( dims.length == 6 ) { throw new IllegalArgumentException ( "cannot resize six-dimensional array" );

< T > [] { if ( side.equalsIgnoreCase (" left" ) ) { var i = 0; while ( i < a.length ) { if ( a[i] < v ) { i++; } else { break; } } return i; } else if ( side.equalsIgnoreCase (" right" ) ) { var i = a.length - 1; while ( i >= 0 ) { if ( a[i] > v ) { i--; } else { break; } } return i; } else { throw new IllegalArgumentException (); } } } /** * Find indices where elements of v should be inserted in a to maintain order. * @param v * @param side * @return */ /** * Find indices where elements of v should be inserted in a to maintain order.
( array : KtNDArray < T > ) : KtNDArray < T > { if ( offset < 0 ) offset = array.length + offset if ( offset > array.length ) offset = offset % array.length array[offset] = value return array } fun < T : Any , reified R : Any > KtNDArray < T > . setfield ( value : R , offset : Int = 0 ) : KtNDArray < T > { if ( offset < 0 ) offset = 0 if ( offset > array.length ) offset = offset % array.length array[offset] = value return array } fun < T : Any , reified R : Any > KtNDArray < T > . setfield ( value : R , offset : Int = array.length ) : KtNDArray < T > { if ( offset < 0 ) offset = array.length if ( offset > array.length ) offset = offset % array.length array[offset] = value return array } fun < T : Any , reified R : Any
= { if ( write == null ) write = 0; if ( align == null ) align = 0; if ( uic == null ) uic = 0; if ( write == 0 && align == 0 && uic == 0 ) { this.flags.writeable = true; this.flags.aligned = true; this.flags.uic = true; } else { this.flags.writeable = write; this.flags.aligned = align; this.flags.uic = uic; } } /** * Set array flags READONLY, ALIGNED, (READONLY and UPDATEIFCOPY), respectively. */ ktndarray < T : Any > KtNDArray < T > . setFlags ( write : Int ? = null , align : Int ? = null , uic : Int ? = null ) ron = { if ( write == null ) write = 0; if ( align == null ) align = 0; if ( uic == null ) uic = 0; if ( write == 0 &&
fun < T : Any > KtNDArray < T > . sort ( axis : Int = 0 , kind : KindSort ? = null ) * * @param axis The axis along which to sort. * @param kind The kind of sort to use. * * @return The sorted array. */ public static < T > KtNDArray < T > . sort ( axis : Int = - 1 , kind : KindSort ? = null ) public static < T > KtNDArray < T > . sort ( axis : Int = 0 , kind : KindSort ? = null ) public static < T > KtNDArray < T > . sort ( axis : Int = 1 , kind : KindSort ? = null ) public static < T > KtNDArray < T > . sort ( axis : Int = 2 , kind : KindSort ? = null ) public static < T > KtNDArray < T > . sort ( axis : Int = 3 , kind : KindSort ? = null ) public static < T > KtNDArray < T > . sort ( axis : Int = 4 , kind : KindSort ? = null ) public static < T > K
( axis : Int ? = null ) : KtNDArray < T > ( axis : Int ? = null ) : KtNDArray < T > ( axis : Int ? = null ) : KtNDArray < T > ( axis : Int ? = null ) : KtNDArray < T > ( axis : Int ? = null ) : KtNDArray < T > ( axis : Int ? = null ) : KtNDArray < T > ( axis : Int ? = null ) : KtNDArray < T > ( axis : Int ? = null ) : KtNDArray < T > ( axis : Int ? = null ) : KtNDArray < T > ( axis : Int ? = null ) : KtNDArray < T > ( axis : Int ? = null ) : KtNDArray < T > ( axis : Int ? = null ) : KtNDArray < T > ( axis : Int ? = null ) : KtNDArray < T > ( axis : Int ? = null ) : KtNDArray < T > ( axis : Int ? = null ) : KtNDArray < T > ( axis : Int ? = null ) : KtNDArray < T
: KtNDArray < T > { if ( ddof < 0 ) throw new IllegalArgumentException ( "ddof must be non-negative" ); if ( ddof < 1 ) throw new IllegalArgumentException ( "ddof must be greater than or equal to 1" ); if ( ddof < 0.5 ) throw new IllegalArgumentException ( "ddof must be greater than or equal to 0.5" ); if ( ddof > 1.5 ) throw new IllegalArgumentException ( "ddof must be less than or equal to 1.5" ); if ( ddof < 0 ) throw new IllegalArgumentException ( "ddof must be non-negative" ); if ( ddof > 1 ) throw new IllegalArgumentException ( "ddof must be greater than or equal to 1" ); if ( ddof < 0.5 ) throw new IllegalArgumentException ( "ddof must be greater than or equal to 0.5" ); if ( ddof > 1.5 ) throw new IllegalArgumentException ( "ddof must be less than or equal to 1.5" ); if
inline { var sum = 0 for ( var i = 0; i < this.size; i++ ) { sum += this[i] } return sum } /** * Average of array elements over a given axis. * * @return [T] value. */ fun < reified T : Number > KtNDArray < T > . average ( ) : T ?lakeinline { var sum = 0 for ( var i = 0; i < this.size; i++ ) { sum += this[i] } return sum / this.size } /** * Max of array elements over a given axis. * * @return [T] value. */ fun < reified T : Number > KtNDArray < T > . max ( ) : T ?lakeinline { var max = 0 for ( var i = 0; i < this.size; i++ ) { if ( this[i] > max ) { max = this[i] } } return max } /**
fun < T : Number > KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtNDArray < T > ( axis : Int ) : KtND
fun < T : Any > KtNDArray < T > ( axis1 : Int , axis2 : Int ) : KtNDArray < T > ( axis2 : Int , axis1 : Int ) : KtNDArray < T > ( axis1 : Int , axis2 : Int ) : KtNDArray < T > ( axis2 : Int , axis1 : Int ) : KtNDArray < T > ( axis1 : Int , axis2 : Int ) : KtNDArray < T > ( axis2 : Int , axis1 : Int ) : KtNDArray < T > ( axis1 : Int , axis2 : Int ) : KtNDArray < T > ( axis2 : Int , axis1 : Int ) : KtNDArray < T > ( axis1 : Int , axis2 : Int ) : KtNDArray < T > ( axis2 : Int , axis1 : Int ) : KtNDArray < T > ( axis1 : Int , axis2 : Int ) : KtNDArray < T > ( axis2 : Int , axis1 : Int ) : KtNDArray < T > ( axis1 : Int , axis2 : Int ) : KtND
fun < T : Any > ( indices : KtNDArray < Long > , axis : Int ? = null , mode : Mode = Mode . RAISE ) : KtNDArray < T > ( indices : KtNDArray < Long > , axis : Int ? = null , mode : Mode = Mode . RAISE ) : KtNDArray < T > ( indices : KtNDArray < Long > , axis : Int ? = null , mode : Mode = Mode . RAISE ) : KtNDArray < T > ( indices : KtNDArray < Long > , axis : Int ? = null , mode : Mode = Mode . RAISE ) : KtNDArray < T > ( indices : KtNDArray < Long > , axis : Int ? = null , mode : Mode = Mode . RAISE ) : KtNDArray < T > ( indices : KtNDArray < Long > , axis : Int ? = null , mode : Mode = Mode . RAISE ) : KtNDArray < T > ( indices : KtNDArray < Long > , axis : Int ? = null , mode : Mode = Mode . RAISE ) : KtNDArray < T > ( indices : Kt
( order : Order = Order . C ) : ByteArray ( order : Order = Order . C ) { if ( order == Order . C ) { if ( order == Order . F ) { if ( order == Order . C ) { if ( order == Order . F ) { if ( order == Order . C ) { if ( order == Order . F ) { if ( order == Order . C ) { if ( order == Order . F ) { if ( order == Order . C ) { if ( order == Order . F ) { if ( order == Order . C ) { if ( order == Order . F ) { if ( order == Order . C ) { if ( order == Order . F ) { if ( order == Order . C ) { if ( order == Order . F ) { if ( order
( arr : KtNDArray < T > ) = let f = File.open ( fid , "wt" , format ) in f.writeKtNDArray ( arr ) f.close () /** * Read array from a file as text or binary (default). */ KtNDArray < T > . fromFile ( fid : String , sep : String = " ike" , format : String = " ike" ) = let f = File.open ( fid , "rt" , format ) in f.readKtNDArray () f.close () /** * Read array from a file as text or binary (default). */ KtNDArray < T > . fromFile ( fid : String , sep : String = " ike" , format : String = " ike" ) = let f = File.open ( fid , "rt" , format ) in f.readKtNDArray () f.close () /** * Read array from a file as text or binary (default). */ KtND
{ if ( axis1 < 0 || axis2 < 0 || axis1 >= KtNDArray . size || axis2 >= KtNDArray . size ) throw new IllegalArgumentException () if ( axis1 == axis2 ) throw new IllegalArgumentException () if ( axis1 < 0 || axis2 < 0 ) throw new IllegalArgumentException () if ( axis1 >= KtNDArray . size || axis2 >= KtNDArray . size ) throw new IllegalArgumentException () if ( axis1 == axis2 ) throw new IllegalArgumentException () if ( axis1 < 0 || axis2 < 0 ) throw new IllegalArgumentException () if ( axis1 >= KtNDArray . size || axis2 >= KtNDArray . size ) throw new IllegalArgumentException () if ( axis1 == axis2 ) throw new IllegalArgumentException () if ( axis1 < 0 || axis2 < 0 ) throw new IllegalArgumentException () if ( axis1 >= KtNDArray . size || axis2 >= KtNDArray . size ) throw new IllegalArgumentException () if ( axi
( vararg axes : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axes : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axes : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axes : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axes : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axes : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axes : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axes : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axes : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axes : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axes : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axes : Int ? = emptyArray ( ) ) : KtNDArray < T > ( vararg axe
. * * @param ddof : The divisor used in the calculation. * * @return : The variance of the array elements, along given axis. */ public static < T : Number > Double KtNDArray < T > . `var` ( ddof : Int = 0 ) : Double. * * @param ddof : The divisor used in the calculation. * * @return : The variance of the array elements, along given axis. */ public static < T : Number > Double KtNDArray < T > . `mean` ( ddof : Int = 0 ) : Double. * * @param ddof : The divisor used in the calculation. * * @return : The mean of the array elements, along given axis. */ public static < T : Number > Double KtNDArray < T > . `mean` ( ddof : Int = 0 ) : Double. * * @param ddof : The divisor used in the calculation. * * @return : The mean of the array elements, along given axis. */ public static < T : Number > Double K
( ) : KtNDArray < T > { return new KtNDArray < T > ( ); } /** * New view of array with the same data. */ KtNDArray < T > . view ( ) : KtNDArray < T > { return new KtNDArray < T > ( ); } /** * New view of array with the same data. */ KtNDArray < T > . view ( ) : KtNDArray < T > { return new KtNDArray < T > ( ); } /** * New view of array with the same data. */ KtNDArray < T > . view ( ) : KtNDArray < T > { return new KtNDArray < T > ( ); } /** * New view of array with the same data. */ KtNDArray < T > . view ( ) : KtNDArray < T > { return new KtNDArray < T > ( ); } /** * New view of array with the same data. */ KtNDArray

fun main ( ) #include <tensorflow/examples/tutorials/mnist/mnist.py> #include <tensorflow/examples/tutorials/mnist/input_data.py> #include <tensorflow/examples/tutorials/mnist/mnist_slim.py> #include <tensorflow/examples/tutorials/mnist/mnist_ops.py> #include <tensorflow/examples/tutorials/mnist/mnist_arg_scope.py> #include <tensorflow/examples/tutorials/mnist/mnist_model.py> #include <tensorflow/examples/tutorials/mnist/mnist_train.py> #include <tensorflow/examples/tutorials/mnist/mnist_eval.py> #include <tensorflow/examples/tutorials/mnist/mnist_arg_scope.py> #include <tensorflow/examples/tutorials/mnist/mnist_ops.py
( ) { var a = [1,2,3,4,5,6,7,8,9] var b = [1,2,3,4,5,6,7,8,9] var c = [1,2,3,4,5,6,7,8,9] var d = [1,2,3,4,5,6,7,8,9] var e = [1,2,3,4,5,6,7,8,9] var f = [1,2,3,4,5,6,7,8,9] var g = [1,2,3,4,5,6,7,8,9] var h = [1,2,3,4,5,6,7,8,9] var i = [1,2,3,4,5,6,7,8,9] var j = [1,2,3,4,5,6,7,8,9] var k = [1,2,3

: Boolean = true fun isApplicable ( configuration : CompilerConfiguration ) : Boolean = true fun isApplicable ( configuration : CompilerConfiguration ) : Boolean = true fun isApplicable ( configuration : CompilerConfiguration ) : Boolean = true fun isApplicable ( configuration : CompilerConfiguration ) : Boolean = true fun isApplicable ( configuration : CompilerConfiguration ) : Boolean = true fun isApplicable ( configuration : CompilerConfiguration ) : Boolean = true fun isApplicable ( configuration : CompilerConfiguration ) : Boolean = true fun isApplicable ( configuration : CompilerConfiguration ) : Boolean = true fun isApplicable ( configuration : CompilerConfiguration ) : Boolean = true fun isApplicable ( configuration : CompilerConfiguration ) : Boolean = true fun isApplicable ( configuration : CompilerConfiguration ) : Boolean = true fun isApplicable ( configuration : CompilerConfiguration ) : Boolean = true fun isApplicable ( configuration : CompilerConfiguration ) : Boolean = true fun isApplicable ( configuration : CompilerConfiguration ) : Boolean = true fun isApplicable ( configuration : CompilerConfiguration ) :
{ if (configuration == null) { return false; } if (configuration.compilerConfiguration == null) { return false; } if (configuration.compilerConfiguration.compilerConfiguration == null) { return false; } if (configuration.compilerConfiguration.compilerConfiguration.compilerConfiguration == null) { return false; } if (configuration.compilerConfiguration.compilerConfiguration.compilerConfiguration.compilerConfiguration == null) { return false; } if (configuration.compilerConfiguration.compilerConfiguration.compilerConfiguration.compilerConfiguration.compilerConfiguration == null) { return false; } if (configuration.compilerConfiguration.compilerConfiguration.compilerConfiguration.compilerConfiguration.compilerConfiguration.compilerConfiguration.compilerConfiguration == null) { return false; } if (configuration.compilerConfiguration.compilerConfiguration.compilerConfiguration.compilerConfiguration.compilerConfiguration.compilerConfiguration.compilerConfiguration.compilerConfiguration.compiler




private fun isValid ( sqlQuery : String ) : Boolean { if ( sqlQuery.startsWith("SELECT") ) { return true; } else { return false; } } private fun isValid ( sqlQuery : String ) : Boolean { if ( sqlQuery.startsWith("INSERT") ) { return true; } else { return false; } } private fun isValid ( sqlQuery : String ) : Boolean { if ( sqlQuery.startsWith("UPDATE") ) { return true; } else { return false; } } private fun isValid ( sqlQuery : String ) : Boolean { if ( sqlQuery.startsWith("DELETE") ) { return true; } else { return false; } } private fun isValid ( sqlQuery : String ) : Boolean { if ( sqlQuery.startsWith("CREATE") ) { return true; } else { return false; }











public fun DataFrame . Companion . getSchemaForAllSqlTables ( connection : Connection ) : List < DataFrameSchema > /** * Retrieves the schema of all non-system tables in the database using the provided database connection. * * @param [connection] the database connection. * @return a list of [DataFrameSchema] objects representing the schema of each non-system table. */ /** * Retrieves the schema of all non-system tables in the database using the provided database connection. * * @param [connection] the database connection. * @return a list of [DataFrameSchema] objects representing the schema of each non-system table. */ /** * Retrieves the schema of all non-system tables in the database using the provided database connection. * * @param [connection] the database connection. * @return a list of [DataFrameSchema] objects representing the schema of each non-system table. */ /** * Retrieves the schema of all non-system tables in the database using the provided database connection. * * @param [connection] the

= mutableListOf< TableColumnMetadata >() /** * Retrieves the metadata of the columns in the result set. * * @param rs the result set * @return a mutable list of [TableColumnMetadata] objects, * where each TableColumnMetadata object contains information such as the column type, * JDBC type, size, and name. */ /** * Retrieves the metadata of the columns in the result set. * * @param rs the result set * @return a mutable list of [TableColumnMetadata] objects, * where each TableColumnMetadata object contains information such as the column type, * JDBC type, size, and name. */ /** * Retrieves the metadata of the columns in the result set. * * @param rs the result set * @return a mutable list of [TableColumnMetadata] objects, * where each TableColumnMetadata object contains information such as the column type, * JDBC type, size, and name. */ /** * Retrieves the metadata of the columns in the result set.


private { * * @return The generated KType. */ private fun generateKType ( dbType : DbType , tableColumnMetadata : TableColumnMetadata ) : KType { * * @return The generated KType. */ private fun generateKType ( dbType : DbType , tableColumnMetadata : TableColumnMetadata ) : KType { * * @return The generated KType. */ private fun generateKType ( dbType : DbType , tableColumnMetadata : TableColumnMetadata ) : KType { * * @return The generated KType. */ private fun generateKType ( dbType : DbType , tableColumnMetadata : TableColumnMetadata ) : KType { * * @return The generated KType. */ private fun generateKType ( dbType : DbType , tableColumnMetadata : TableColumnMetadata ) : KType { * * @return The generated KType. */ private fun generateKType ( dbType : DbType , tableColumnMetadata : TableColumnMetadata ) : KType { * * @return The generated
Map = tableColumnMetadata.getCommonSqlToKTypeMapping() /** * Creates a mapping between common SQL types and their corresponding KTypes. * * @param tableColumnMetadata The metadata of the table column. * @return The KType associated with the SQL type, or a default type if no mapping is found. */ private fun makeCommonSqlToKTypeMapping ( tableColumnMetadata : TableColumnMetadata ) : KType = tableColumnMetadata.getCommonSqlToKTypeMapping() /** * Creates a mapping between common SQL types and their corresponding KTypes. * * @param tableColumnMetadata The metadata of the table column. * @return The KType associated with the SQL type, or a default type if no mapping is found. */ private fun makeCommonSqlToKTypeMapping ( tableColumnMetadata : TableColumnMetadata ) : KType = tableColumnMetadata.getCommonSqlToKTypeMapping() /** * Creates a mapping between common SQL types and their corresponding KTypes. * * @param tableColumnMetadata The metadata of the table column
funCPointer < CPointed > . customExtension ( ) * { * std::cout << *this << std::endl; * return *this; * } * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

( ) { var a = [1,2,3,4,5,6,7,8,9] var b = [1,2,3,4,5,6,7,8,9] var c = [1,2,3,4,5,6,7,8,9] var d = [1,2,3,4,5,6,7,8,9] var e = [1,2,3,4,5,6,7,8,9] var f = [1,2,3,4,5,6,7,8,9] var g = [1,2,3,4,5,6,7,8,9] var h = [1,2,3,4,5,6,7,8,9] var i = [1,2,3,4,5,6,7,8,9] var j = [1,2,3,4,5,6,7,8,9] var k = [1,2,3
: Boolean { return this.wasAlreadyCalled } /** * This check used to avoid cyclic calls. For example: * override fun toString(): String = super.toString() */ /** * This check used to avoid cyclic calls. For example: * override fun toString(): String = super.toString() */ /** * This check used to avoid cyclic calls. For example: * override fun toString(): String = super.toString() */ /** * This check used to avoid cyclic calls. For example: * override fun toString(): String = super.toString() */ /** * This check used to avoid cyclic calls. For example: * override fun toString(): String = super.toString() */ /** * This check used to avoid cyclic calls. For example: * override fun toString(): String = super.toString() */ /** * This check used to avoid cyclic calls. For example: * override fun toString(): String = super.toString() */ /** * This check used to avoid cycl

{ } /** * Abbreviated form (e.g., WWW, HTTP,etc.) */ inline fun < T , C : TagConsumer < T > > C . abbr ( classes : String ? = null , crossinline block : ABBR . ( ) -> Unit = { } ) : T /** * Abbreviated form (e.g., WWW, HTTP,etc.) */ inline fun < T , C : TagConsumer < T > > C . abbr ( classes : String ? = null , crossinline block : ABBR . ( ) -> Unit = { } ) : T /** * Abbreviated form (e.g., WWW, HTTP,etc.) */ inline fun < T , C : TagConsumer < T > > C . abbr ( classes : String ? = null , crossinline block : ABBR . ( ) -> Unit = { } ) : T /** * Abbreviated form (e.g., WWW, HTTP,etc.) */ inline fun < T , C : TagConsumer < T > > C . abbr ( classes : String ? = null , crossinline block
/** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information on author */ /** * Information
{ if ( shape == null ) { return null } if ( alt == null ) { return null } if ( classes == null ) { return null } if ( crossinline == null ) { return null } if ( block == null ) { return null } return shape.area( alt , classes , crossinline ) } /** * Server-side image map area */ static inline fun < T , C : TagConsumer < T > > C . area ( shape : AreaShape ? = null , alt : String ? = null , classes : String ? = null , crossinline block : AREA . ( ) -> Unit = { } , ) : T static inline fun < T , C : TagConsumer < T > > C . area ( shape : AreaShape ? = null , alt : String ? = null , classes : String ? = null , crossinline block : AREA . ( ) -> Unit = { } , ) : T static inline fun < T , C : TagConsumer < T > > C . area ( shape : AreaShape ? = null , alt : String
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () :
{ } /** * Video player */ vide@ HtmlTagMarker vide public inline fun < T , C : TagConsumer < T > > C . video ( classes : String ? = null , crossinline block : VIDEO . ( ) -> Unit = { } ) : T vide { } /** * Image player */ image@ HtmlTagMarker image public inline fun < T , C : TagConsumer < T > > C . image ( classes : String ? = null , crossinline block : IMAGE . ( ) -> Unit = { } ) : T image { } /** * Audio player */ audio@ HtmlTagMarker audio public inline fun < T , C : TagConsumer < T > > C . audio ( classes : String ? = null , crossinline block : AUDIO . ( ) -> Unit = { } ) : T audio { } /** * Video player */ vide@ HtmlTagMarker vide public inline fun < T , C : TagConsumer < T > > C . video ( classes : String ? = null , crossinline block : VIDEO . ( ) -> Unit = { } ) : T vide { } /**
{ return this } } /** * Italic text style */ itate@ HtmlTagMarker ita public inline fun < T , C : TagConsumer < T > > C . i ( classes : String ? = null , crossinline block : I . ( ) -> Unit = { } ) : T ita { return this } } /** * Underline text style */ underline@ HtmlTagMarker underline public inline fun < T , C : TagConsumer < T > > C . u ( classes : String ? = null , crossinline block : U . ( ) -> Unit = { } ) : T underline { return this } } /** * Superscript text style */ superscript@ HtmlTagMarker superscript public inline fun < T , C : TagConsumer < T > > C . s ( classes : String ? = null , crossinline block : S . ( ) -> Unit = { } ) : T superscript { return this } } /** * Strike text style */ strike@ HtmlTagMarker strike public inline fun < T , C : TagConsumer < T > > C . s ( classes : String
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () : Unit = { } private fun < T , C : TagConsumer < T > > C () :
{ } /** * I18N BiDi over-ride */ fun < T , C : TagConsumer < T > > C . bdo ( classes : String ? = null , crossinline block : BDO . ( ) -> Unit = { } ) : T /** * I18N BiDi over-ride */ fun < T , C : TagConsumer < T > > C . bdo ( classes : String ? = null , crossinline block : BDO . ( ) -> Unit = { } ) : T /** * I18N BiDi over-ride */ fun < T , C : TagConsumer < T > > C . bdo ( classes : String ? = null , crossinline block : BDO . ( ) -> Unit = { } ) : T /** * I18N BiDi over-ride */ fun < T , C : TagConsumer < T > > C . bdo ( classes : String ? = null , crossinline block : BDO . ( ) -> Unit = { } ) : T /** * I18N BiDi over-ride */ fun < T , C : TagConsumer < T
{ @Override public void blockQuote ( classes : String ? = null , crossinline block : BLOCKQUOTE . ( ) -> Unit = { } ) { super . blockQuote ( classes : String ? = null , crossinline block : BLOCKQUOTE . ( ) -> Unit = { } ) super . blockQuote ( classes : String ? = null , crossinline block : BLOCKQUOTE . ( ) -> Unit = { } ) super . blockQuote ( classes : String ? = null , crossinline block : BLOCKQUOTE . ( ) -> Unit = { } ) super . blockQuote ( classes : String ? = null , crossinline block : BLOCKQUOTE . ( ) -> Unit = { } ) super . blockQuote ( classes : String ? = null , crossinline block : BLOCKQUOTE . ( ) -> Unit = { } ) super . blockQuote ( classes : String ? = null , crossinline block : BLOCKQUOTE . ( ) -> Unit = { } ) super . blockQuote ( classes : String ? = null , crossinline block : BLOCKQUOTE . ( ) -> Unit = { } )
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ } * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
@ HtmlTagMarker * * @param formEncType : ButtonFormEncType ? = null * @param formMethod : ButtonFormMethod ? = null * @param name : String ? = null * @param type : ButtonType ? = null * @param classes : String ? = null * @param crossinline block : BUTTON . ( ) -> Unit = { } * * @return Unit */ private fun < T , C : TagConsumer < T > > C . button ( formEncType : ButtonFormEncType ? = null , formMethod : ButtonFormMethod ? = null , name : String ? = null , type : ButtonType ? = null , classes : String ? = null , crossinline block : BUTTON . ( ) -> Unit = { } , ) : T /** * Push button * * @param formEncType : ButtonFormEncType ? = null * @param formMethod : ButtonFormMethod ? = null * @param name : String ? = null * @param type : ButtonType ? = null * @param classes : String ? = null * @param crossinline block : BUTTON
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * @param classes * @param crossinline block * @return */ inline fun < T , C : TagConsumer < T > > C . cite ( classes : String ? = null , crossinline block : CITE . ( ) -> Unit = { } ) : T /** * @param classes * @param crossinline block * @return */ inline fun < T , C : TagConsumer < T > > C . cite ( classes : String ? = null , crossinline block : CITE . ( ) -> Unit = { } ) : T /** * @param classes * @param crossinline block * @return */ inline fun < T , C : TagConsumer < T > > C . cite ( classes : String ? = null , crossinline block : CITE . ( ) -> Unit = { } ) : T /** * @param classes * @param crossinline block * @return */ inline fun < T , C : TagConsumer < T > > C . cite ( classes : String ? = null , crossinline block : CITE . ( ) -> Unit = { } ) : T /** *
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ } /** * Table row */ ikey@ HtmlTagMarker ikey public inline fun < T , C : TagConsumer < T > > C . row ( classes : String ? = null , crossinline block : ROW . ( ) -> Unit = { } ) : T ikey { } /** * Table column */ ikey@ HtmlTagMarker ikey public inline fun < T , C : TagConsumer < T > > C . col ( classes : String ? = null , crossinline block : COL . ( ) -> Unit = { } ) : T ikey { } /** * Table row */ ikey@ HtmlTagMarker ikey public inline fun < T , C : TagConsumer < T > > C . row ( classes : String ? = null , crossinline block : ROW . ( ) -> Unit = { } ) : T ikey { } /** * Table column */ ikey@ HtmlTagMarker ikey public inline fun < T , C : TagConsumer < T > > C . col ( classes : String ? = null , cro
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
private fun < T , C : TagConsumer < T > > C . details ( classes : String ? = null , crossinline block : DETAILS . ( ) -> Unit = { } ) : Unit = { } private fun < T , C : TagConsumer < T > > C . details ( classes : String ? = null , crossinline block : DETAILS . ( ) -> Unit = { } ) : Unit = { } private fun < T , C : TagConsumer < T > > C . details ( classes : String ? = null , crossinline block : DETAILS . ( ) -> Unit = { } ) : Unit = { } private fun < T , C : TagConsumer < T > > C . details ( classes : String ? = null , crossinline block : DETAILS . ( ) -> Unit = { } ) : Unit = { } private fun < T , C : TagConsumer < T > > C . details ( classes : String ? = null , crossinline block : DETAILS . ( ) -> Unit = { } ) : Unit = { } private fun < T , C : TagConsumer < T > > C . details ( classes : String ? = null , crossinline block : DETAILS
{ } fun < T , C : TagConsumer < T > > C . dfn ( classes : String ? = null , crossinline block : DFN . ( ) -> Unit = { } ) : T fun < T , C : TagConsumer < T > > C . dfn ( classes : String ? = null , crossinline block : DFN . ( ) -> Unit = { } ) : T fun < T , C : TagConsumer < T > > C . dfn ( classes : String ? = null , crossinline block : DFN . ( ) -> Unit = { } ) : T fun < T , C : TagConsumer < T > > C . dfn ( classes : String ? = null , crossinline block : DFN . ( ) -> Unit = { } ) : T fun < T , C : TagConsumer < T > > C . dfn ( classes : String ? = null , crossinline block : DFN . ( ) -> Unit = { } ) : T fun < T , C : TagConsumer < T > > C . dfn ( classes : String ? = null , crossinline block : DFN . ( ) -> Unit = {
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ } /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language/style container */ /** * Generic language
{ * @param classes * @param crossinline block * @return */ public inline fun < T , C : TagConsumer < T > > dl ( classes : String ? = null , crossinline block : DL . ( ) -> Unit = { } ) : T { if ( classes == null ) { return this } else if ( classes.isEmpty() ) { return this } else if ( classes.isBlank() ) { return this } else if ( classes.isBlankLine() ) { return this } else if ( classes.isBlankColumn() ) { return this } else if ( classes.isBlankRow() ) { return this } else if ( classes.isBlankColumnLine() ) { return this } else if ( classes.isBlankColumnLine() ) { return this } else if ( classes.isBlankRowLine() ) { return this } else if ( classes.isBlankRowLine() ) { return this } else if ( classes.isBl
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ } */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /** * Plugin */ /**
{ } /** * Form control group */ inline fun < T , C : TagConsumer < T > > C . fieldSet ( classes : String ? = null , crossinline block : FIELDSET . ( ) -> Unit = { } ) : T /** * Form control group */ inline fun < T , C : TagConsumer < T > > C . fieldSet ( classes : String ? = null , crossinline block : FIELDSET . ( ) -> Unit = { } ) : T /** * Form control group */ inline fun < T , C : TagConsumer < T > > C . fieldSet ( classes : String ? = null , crossinline block : FIELDSET . ( ) -> Unit = { } ) : T /** * Form control group */ inline fun < T , C : TagConsumer < T > > C . fieldSet ( classes : String ? = null , crossinline block : FIELDSET . ( ) -> Unit = { } ) : T /** * Form control group */ inline fun < T , C : TagConsumer < T > > C . fieldSet ( classes : String ? = null , crossinline block
.figcaption ( classes : String ? = null , crossinline block : FIGCAPTION . ( ) -> Unit = { } ) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ footer ( classes : String ? = null , crossinline block : footer ( classes : String ? = null , crossinline block : footer ( classes : String ? = null , crossinline block : footer ( classes : String ? = null , crossinline block : footer ( classes : String ? = null , crossinline block : footer ( classes : String ? = null , crossinline block : footer ( classes : String ? = null , crossinline block : footer ( classes : String ? = null , crossinline block : footer ( classes : String ? = null , crossinline block : footer ( classes : String ? = null , crossinline block : footer ( classes : String ? = null , crossinline block : footer ( classes : String ? = null , crossinline block : footer ( classes : String ? = null , crossinline block : footer ( classes : String ? = null , crossinline block : footer ( classes : String ? = null , crossinline block : footer ( classes : String ? = null , crossinline block : footer ( classes : String ? = null , crossinline block : footer ( classes : String ? = null , crossinline block : footer (
( action : String ? = null , encType : FormEncType ? = null , method : FormMethod ? = null , classes : String ? = null , crossinline block : FORM . ( ) -> Unit = { } , ) : C . form ( action : String ? = null , encType : FormEncType ? = null , method : FormMethod ? = null , classes : String ? = null , crossinline block : C . form ( action : String ? = null , encType : FormEncType ? = null , method : FormMethod ? = null , classes : String ? = null , crossinline block : C . form ( action : String ? = null , encType : FormEncType ? = null , method : FormMethod ? = null , classes : String ? = null , crossinline block : C . form ( action : String ? = null , encType : FormEncType ? = null , method : FormMethod ? = null , classes : String ? = null , crossinline block : C . form ( action : String ? = null , encType : FormEncType ? = null , method : FormMethod ? = null , classes : String ? = null , crossinline block : C . form ( action : String
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
. h2 ( classes : String ? = null , crossinline block : H2 . ( ) -> Unit = { } ) : C . h2 ( classes : String ? = null , crossinline block : C . h2 ( classes : String ? = null , crossinline block : C . h2 ( classes : String ? = null , crossinline block : C . h2 ( classes : String ? = null , crossinline block : C . h2 ( classes : String ? = null , crossinline block : C . h2 ( classes : String ? = null , crossinline block : C . h2 ( classes : String ? = null , crossinline block : C . h2 ( classes : String ? = null , crossinline block : C . h2 ( classes : String ? = null , crossinline block : C . h2 ( classes : String ? = null , crossinline block : C . h2 ( classes : String ? = null , crossinline block : C . h2 ( classes : String ? = null , crossinline block : C . h2 ( classes : String ? = null , crossinline block : C . h2 ( classes : String ? = null , crossinline block : C . h2 (
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ } /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document
public inline fun < T , C : TagConsumer < T > > C . `footer` ( classes : String ? = null , crossinline block : FOOTER . ( ) -> Unit = { } ) : T inline fun < T , C : TagConsumer < T > > C . `navbar` ( classes : String ? = null , crossinline block : NAVBAR . ( ) -> Unit = { } ) : T inline fun < T , C : TagConsumer < T > > C . `sidebar` ( classes : String ? = null , crossinline block : SIDEBAR . ( ) -> Unit = { } ) : T inline fun < T , C : TagConsumer < T > > C . `sidebar` ( classes : String ? = null , crossinline block : SIDEBAR . ( ) -> Unit = { } ) : T inline fun < T , C : TagConsumer < T > > C . `sidebar` ( classes : String ? = null , crossinline block : SIDEBAR . ( ) -> Unit = { } ) : T inline fun < T , C : TagConsumer < T > > C . `sidebar` ( classes : String ? = null ,
{ } /** * Vertical rule * @param classes * @return */ inline fun < T , C : TagConsumer < T > > C . vr ( classes : String ? = null , crossinline block : VR . ( ) -> Unit = { } ) : T vr { } /** * Horizontal rule * @param classes * @return */ inline fun < T , C : TagConsumer < T > > C . hr ( classes : String ? = null , crossinline block : HR . ( ) -> Unit = { } ) : T hr { } /** * Vertical rule * @param classes * @return */ inline fun < T , C : TagConsumer < T > > C . vr ( classes : String ? = null , crossinline block : VR . ( ) -> Unit = { } ) : T vr { } /** * Horizontal rule * @param classes * @return */ inline fun < T , C : TagConsumer < T > > C . hr ( classes : String ? = null , crossinline block : HR . ( ) -> Unit = { } ) : T hr
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ *
{ } /** * Bold text style */ bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ HtmlTagMarker * bg@ H
* * @param sandbox * @param classes * @param content * @return */ public inline fun < T , C : TagConsumer < T > > C . iframe ( sandbox : IframeSandbox ? = null , classes : String ? = null , content : String = " iframe" , ) : T iframe * * @param sandbox * @param classes * @param content * @return */ public inline fun < T , C : TagConsumer < T > > C . iframe ( sandbox : IframeSandbox ? = null , classes : String ? = null , content : String = " iframe" , ) : T iframe * * @param sandbox * @param classes * @param content * @return */ public inline fun < T , C : TagConsumer < T > > C . iframe ( sandbox : IframeSandbox ? = null , classes : String ? = null , content : String = " iframe" , ) : T iframe * * @param sandbox * @param classes * @param content * @return */ public inline fun < T , C : TagConsumer
( sandbox : IframeSandbox ? = null , classes : String ? = null , crossinline block : IFRAME . ( ) -> Unit = { } , ) : C . iframe ( sandbox : IframeSandbox ? = null , classes : String ? = null , crossinline block : IFRAME . ( ) -> Unit = { } , ) : C . iframe ( sandbox : IframeSandbox ? = null , classes : String ? = null , crossinline block : IFRAME . ( ) -> Unit = { } , ) : C . iframe ( sandbox : IframeSandbox ? = null , classes : String ? = null , crossinline block : IFRAME . ( ) -> Unit = { } , ) : C . iframe ( sandbox : IframeSandbox ? = null , classes : String ? = null , crossinline block : IFRAME . ( ) -> Unit = { } , ) : C . iframe ( sandbox : IframeSandbox ? = null , classes : String ? = null , crossinline block : IFRAME . ( ) -> Unit = { } , ) : C . iframe ( sandbox : IframeSandbox ? = null , classes : String ? =
( alt : String ? = null , src : String ? = null , loading : ImgLoading ? = null , classes : String ? = null , crossinline block : IMG . ( ) -> Unit = { } , ) : C . img ( alt : String ? = null , src : String ? = null , loading : ImgLoading ? = null , classes : String ? = null , crossinline block : IMG . ( ) -> Unit = { } , ) : C . img ( alt : String ? = null , src : String ? = null , loading : ImgLoading ? = null , classes : String ? = null , crossinline block : IMG . ( ) -> Unit = { } , ) : C . img ( alt : String ? = null , src : String ? = null , loading : ImgLoading ? = null , classes : String ? = null , crossinline block : IMG . ( ) -> Unit = { } , ) : C . img ( alt : String ? = null , src : String ? = null , loading : ImgLoading ? = null , classes : String ? = null , crossinline block : IMG . ( ) -> Unit = { } , ) : C . img (
@ HtmlTagMarker * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control */ /** * Form control *
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * * @param keyType * @param classes * @param crossinline block * @return */ private fun < T , C : TagConsumer < T > > C . keyGen ( keyType : KeyGenKeyType ? = null , classes : String ? = null , crossinline block : KEYGEN . ( ) -> Unit = { } , ) : T /** * Cryptographic key-pair generator form control */ private fun < T , C : TagConsumer < T > > C . keyGen ( keyType : KeyGenKeyType ? = null , classes : String ? = null , crossinline block : KEYGEN . ( ) -> Unit = { } , ) : T /** * Cryptographic key-pair generator form control */ private fun < T , C : TagConsumer < T > > C . keyGen ( keyType : KeyGenKeyType ? = null , classes : String ? = null , crossinline block : KEYGEN . ( ) -> Unit = { } , ) : T /** * Cryptographic key-pair generator form control */ private fun < T , C : TagConsumer < T > > C . keyGen
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
/** * Fieldset legend */ inline fun < T , C : TagConsumer < T > > C . legend ( classes : String ? = null , crossinline block : LEGEND . ( ) -> Unit = { } ) : T /** * Fieldset legend */ inline fun < T , C : TagConsumer < T > > C . legend ( classes : String ? = null , crossinline block : LEGEND . ( ) -> Unit = { } ) : T /** * Fieldset legend */ inline fun < T , C : TagConsumer < T > > C . legend ( classes : String ? = null , crossinline block : LEGEND . ( ) -> Unit = { } ) : T /** * Fieldset legend */ inline fun < T , C : TagConsumer < T > > C . legend ( classes : String ? = null , crossinline block : LEGEND . ( ) -> Unit = { } ) : T /** * Fieldset legend */ inline fun < T , C : TagConsumer < T > > C . legend ( classes : String ? = null , crossinline block
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
( href : String ? = null , rel : String ? = null , type : String ? = null , crossinline block : LINK . ( ) -> Unit = { } , ) : C . link ( href : String ? = null , rel : String ? = null , type : String ? = null , crossinline block : LINK . ( ) -> Unit = { } , ) : C . link ( href : String ? = null , rel : String ? = null , type : String ? = null , crossinline block : LINK . ( ) -> Unit = { } , ) : C . link ( href : String ? = null , rel : String ? = null , type : String ? = null , crossinline block : LINK . ( ) -> Unit = { } , ) : C . link ( href : String ? = null , rel : String ? = null , type : String ? = null , crossinline block : LINK . ( ) -> Unit = { } , ) : C . link ( href : String ? = null , rel : String ? = null , type : String ? = null , crossinline block : LINK . ( ) -> Unit = { } , ) : C . link ( href : String ? = null , rel :
{ } */ public inline fun < T , C : TagConsumer < T > > C . main ( classes : String ? = null , crossinline block : MAIN . ( ) -> Unit = { } ) : TagConsumer < T > { } public inline fun < T , C : TagConsumer < T > > C . main ( classes : String ? = null , crossinline block : MAIN . ( ) -> Unit = { } ) : TagConsumer < T > { } public inline fun < T , C : TagConsumer < T > > C . main ( classes : String ? = null , crossinline block : MAIN . ( ) -> Unit = { } ) : TagConsumer < T > { } public inline fun < T , C : TagConsumer < T > > C . main ( classes : String ? = null , crossinline block : MAIN . ( ) -> Unit = { } ) : TagConsumer < T > { } public inline fun < T , C : TagConsumer < T > > C . main ( classes : String ? = null , crossinline block : MAIN . ( ) -> Unit = { } ) : TagConsumer < T > { } public
( name : String ? = null , classes : String ? = null , crossinline block : MAP . ( ) -> Unit = { } ) { @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("unchecked") @SuppressWarnings("un
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * @param name * @param content * @param charset * @param crossinline block * @return */ public inline fun < T , C : TagConsumer < T > > C . meta ( name : String ? = null , content : String ? = null , charset : String ? = null , crossinline block : META . ( ) -> Unit = { } , ) : T /** * Generic metainformation */ public inline fun < T , C : TagConsumer < T > > C . meta ( name : String ? = null , content : String ? = null , charset : String ? = null , crossinline block : META . ( ) -> Unit = { } , ) : T /** * Generic metainformation */ public inline fun < T , C : TagConsumer < T > > C . meta ( name : String ? = null , content : String ? = null , charset : String ? = null , crossinline block : META . ( ) -> Unit = { } , ) : T /** * Generic metainformation */ public inline fun < T , C : TagConsumer < T >
{ } /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */ /** * Gauge */
{ @Override public void nav ( ) { super . nav () @Override public void nav ( ) { super . nav () @Override public void nav ( ) { super . nav () @Override public void nav ( ) { super . nav () @Override public void nav ( ) { super . nav () @Override public void nav ( ) { super . nav () @Override public void nav ( ) { super . nav () @Override public void nav ( ) { super . nav () @Override public void nav ( ) { super . nav () @Override public void nav ( ) { super . nav () @Override public void nav ( ) { super . nav () @Override public void nav (
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ } /** * Option group * @param label * @param classes * @param crossinline block * @return */ inline fun < T , C : TagConsumer < T > > C . optGroup ( label : String ? = null , classes : String ? = null , crossinline block : OPTGROUP . ( ) -> Unit = { } , ) : T /** * Option group * @param label * @param classes * @param crossinline block * @return */ inline fun < T , C : TagConsumer < T > > C . optGroup ( label : String ? = null , classes : String ? = null , crossinline block : OPTGROUP . ( ) -> Unit = { } , ) : T /** * Option group * @param label * @param classes * @param crossinline block * @return */ inline fun < T , C : TagConsumer < T > > C . optGroup ( label : String ? = null , classes : String ? = null , crossinline block : OPTGROUP . ( ) -> Unit = { } , ) : T /** * Option group * @param
/** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /** * Selectable choice */ /**
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ if ( classes != null ) { return classes.output( this ) ; } else { return this.output( this ) ; } } /** * Calculated input value */ inline fun < T , C : TagConsumer < T > > C . input ( classes : String ? = null , crossinline block : INPUT . ( ) -> Unit = { } ) : T { if ( classes != null ) { return classes.input( this ) ; } else { return this.input( this ) ; } } /** * Calculated output value */ inline fun < T , C : TagConsumer < T > > C . output ( classes : String ? = null , crossinline block : OUTPUT . ( ) -> Unit = { } ) : T { if ( classes != null ) { return classes.output( this ) ; } else { return this.output( this ) ; } } /** * Calculated input value */ inline fun < T , C : TagConsumer < T > > C
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
/** * Named property value * @param name * @param value * @param crossinline block * @return */ inline fun < T , C : TagConsumer < T > > C . `param` ( name : String ? = null , `value` : String ? = null , crossinline block : PARAM . ( ) -> Unit = { } , ) : T /** * Named property value * @param name * @param value * @param crossinline block * @return */ inline fun < T , C : TagConsumer < T > > C . `param` ( name : String ? = null , `value` : String ? = null , crossinline block : PARAM . ( ) -> Unit = { } , ) : T /** * Named property value * @param name * @param value * @param crossinline block * @return */ inline fun < T , C : TagConsumer < T > > C . `param` ( name : String ? = null , `value` : String ? = null , crossinline block : PARAM . ( ) -> Unit = { } , )
{ return this } } /** * Images container */ inline fun < T , C : TagConsumer < T > > C . image ( crossinline block : PICTURE . ( ) -> Unit = { } ) : Unit { return this } /** * Images container */ inline fun < T , C : TagConsumer < T > > C . image ( crossinline block : PICTURE . ( ) -> Unit = { } ) : Unit { return this } /** * Images container */ inline fun < T , C : TagConsumer < T > > C . image ( crossinline block : PICTURE . ( ) -> Unit = { } ) : Unit { return this } /** * Images container */ inline fun < T , C : TagConsumer < T > > C . image ( crossinline block : PICTURE . ( ) -> Unit = { } ) : Unit { return this } /** * Images container */ inline fun < T , C : TagConsumer < T > > C . image ( crossinline block : PICTURE . ( ) -> Unit = { } ) : Unit { return this } /** * Image
( classes : String ? = null , crossinline block : PRE . ( ) -> Unit = { } ) : C . pre ( classes : String ? = null , crossinline block : PRE . ( ) -> Unit = { } ) : C . pre ( classes : String ? = null , crossinline block : PRE . ( ) -> Unit = { } ) : C . pre ( classes : String ? = null , crossinline block : PRE . ( ) -> Unit = { } ) : C . pre ( classes : String ? = null , crossinline block : PRE . ( ) -> Unit = { } ) : C . pre ( classes : String ? = null , crossinline block : PRE . ( ) -> Unit = { } ) : C . pre ( classes : String ? = null , crossinline block : PRE . ( ) -> Unit = { } ) : C . pre ( classes : String ? = null , crossinline block : PRE . ( ) -> Unit = { } ) : C . pre ( classes : String ? = null , crossinline block : PRE . ( ) -> Unit = { } ) : C . pre ( classes : String ? = null , crossinline block : PRE . ( ) -> Unit = { } )
{ if ( ! classes ) { throw new IllegalArgumentException( "classes is required" ) ; } if ( ! crossinline ) { throw new IllegalArgumentException( "crossinline is required" ) ; } if ( ! progress ) { throw new IllegalArgumentException( "progress is required" ) ; } if ( ! classes ) { throw new IllegalArgumentException( "classes is required" ) ; } if ( ! crossinline ) { throw new IllegalArgumentException( "crossinline is required" ) ; } if ( ! progress ) { throw new IllegalArgumentException( "progress is required" ) ; } if ( ! classes ) { throw new IllegalArgumentException( "classes is required" ) ; } if ( ! crossinline ) { throw new IllegalArgumentException( "crossinline is required" ) ; } if ( ! progress ) { throw new IllegalArgumentException( "progress is required" ) ; } if ( ! classe
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ } /** * Parenthesis for ruby annotation text */ inline fun < T , C : TagConsumer < T > > C . rp ( classes : String ? = null , crossinline block : RP . ( ) -> Unit = { } ) : T /** * Parenthesis for ruby annotation text */ inline fun < T , C : TagConsumer < T > > C . rp ( classes : String ? = null , crossinline block : RP . ( ) -> Unit = { } ) : T /** * Parenthesis for ruby annotation text */ inline fun < T , C : TagConsumer < T > > C . rp ( classes : String ? = null , crossinline block : RP . ( ) -> Unit = { } ) : T /** * Parenthesis for ruby annotation text */ inline fun < T , C : TagConsumer < T > > C . rp ( classes : String ? = null , crossinline block : RP . ( ) -> Unit = { } ) : T /** * Parenthesis for ruby annotation text */ inline fun < T , C : TagConsumer < T > > C . rp ( classes : String
{ } /** * Ruby annotation text */ rt ( classes : String ? = null , crossinline block : RT . ( ) -> Unit = { } ) : RT . ( ) -> Unit = { } /** * Ruby annotation text */ rt ( classes : String ? = null , crossinline block : RT . ( ) -> Unit = { } ) : RT . ( ) -> Unit = { } /** * Ruby annotation text */ rt ( classes : String ? = null , crossinline block : RT . ( ) -> Unit = { } ) : RT . ( ) -> Unit = { } /** * Ruby annotation text */ rt ( classes : String ? = null , crossinline block : RT . ( ) -> Unit = { } ) : RT . ( ) -> Unit = { } /** * Ruby annotation text */ rt ( classes : String ? = null , crossinline block : RT . ( ) -> Unit = { } ) : RT . ( ) -> Unit = { } /** * Ruby annotation text */ rt ( classes : String ? = null , crossinline block : RT . ( ) -> Unit = { } )
* * @param classes : String ? = null * * @param crossinline block : RUBY . ( ) -> Unit = { } * * @return T * */ public inline fun < T , C : TagConsumer < T > > C . ruby ( classes : String ? = null , crossinline block : RUBY . ( ) -> Unit = { } ) : T public inline fun < T , C : TagConsumer < T > > C . ruby ( classes : String ? = null , crossinline block : RUBY . ( ) -> Unit = { } ) : T public inline fun < T , C : TagConsumer < T > > C . ruby ( classes : String ? = null , crossinline block : RUBY . ( ) -> Unit = { } ) : T public inline fun < T , C : TagConsumer < T > > C . ruby ( classes : String ? = null , crossinline block : RUBY . ( ) -> Unit = { } ) : T public inline fun < T , C : TagConsumer < T > > C . ruby ( classes : String ?
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ if ( ! classes ) throw new IllegalArgumentException () ; if ( ! crossinline block ) throw new IllegalArgumentException () ; if ( ! this ) throw new IllegalArgumentException () ; if ( ! classes ) throw new IllegalArgumentException () ; if ( ! crossinline block ) throw new IllegalArgumentException () ; if ( ! this ) throw new IllegalArgumentException () ; if ( ! classes ) throw new IllegalArgumentException () ; if ( ! crossinline block ) throw new IllegalArgumentException () ; if ( ! this ) throw new IllegalArgumentException () ; if ( ! classes ) throw new IllegalArgumentException () ; if ( ! crossinline block ) throw new IllegalArgumentException () ; if ( ! this ) throw new IllegalArgumentException () ; if ( ! classes ) throw new IllegalArgumentException () ; if ( ! crossinline block ) throw new IllegalArgumentException () ; if ( ! this ) throw new IllegalArgumentException () ; if ( ! classes ) throw new IllegalArgumentException () ; if ( ! crossinline block ) throw new IllegalArgumentException () ; if ( ! this ) throw new IllegalArgumentException () ; if ( ! classes ) throw new IllegalArg
( type : String ? = null , src : String ? = null , crossorigin : ScriptCrossorigin ? = null , content : String = " xylophone" ) : T xylophone ( type : String ? = null , src : String ? = null , crossorigin : ScriptCrossorigin ? = null , content : String = " xylophone" ) : T xylophone ( type : String ? = null , src : String ? = null , crossorigin : ScriptCrossorigin ? = null , content : String = " xylophone" ) : T xylophone ( type : String ? = null , src : String ? = null , crossorigin : ScriptCrossorigin ? = null , content : String = " xylophone" ) : T xylophone ( type : String ? = null , src : String ? = null , crossorigin : ScriptCrossorigin ? = null , content : String = " xylophone" ) : T xylophone ( type : String ? = null , src : String ? = null , crossorigin : ScriptCrossorigin ? = null , content : String = " xylophone" ) : T xylophone ( type : String ? = null , src : String ? = null , cro
( src : String ? = null , type : String ? = null , crossorigin : ScriptCrossorigin ? = null , crossinline block : SCRIPT . ( ) -> Unit = { } , ) : C . script ( src : String ? = null , type : String ? = null , crossorigin : ScriptCrossorigin ? = null , crossinline block : C . script ( src : String ? = null , type : String ? = null , crossorigin : ScriptCrossorigin ? = null , crossinline block : C . script ( src : String ? = null , type : String ? = null , crossorigin : ScriptCrossorigin ? = null , crossinline block : C . script ( src : String ? = null , type : String ? = null , crossorigin : ScriptCrossorigin ? = null , crossinline block : C . script ( src : String ? = null , type : String ? = null , crossorigin : ScriptCrossorigin ? = null , crossinline block : C . script ( src : String ? = null , type : String ? = null , crossorigin : ScriptCrossorigin ? = null , crossinline block : C . script ( src : String ? = null , type : String ? = null , crossorigin : Script
{ } /** * Generic document or application section */ inline fun < T , C : TagConsumer < T > > C . section ( classes : String ? = null , crossinline block : SECTION . ( ) -> Unit = { } ) : T /** * Generic document or application section */ inline fun < T , C : TagConsumer < T > > C . section ( classes : String ? = null , crossinline block : SECTION . ( ) -> Unit = { } ) : T /** * Generic document or application section */ inline fun < T , C : TagConsumer < T > > C . section ( classes : String ? = null , crossinline block : SECTION . ( ) -> Unit = { } ) : T /** * Generic document or application section */ inline fun < T , C : TagConsumer < T > > C . section ( classes : String ? = null , crossinline block : SECTION . ( ) -> Unit = { } ) : T /** * Generic document or application section */ inline fun < T , C : TagConsumer < T > > C . section ( classes : String ? = null , crossinline block : SECTION .
@ HtmlTagMarker /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option selector */ /** * Option
{ } /** * Large text style */ xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker xlarge@ HtmlTagMarker x
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ } /** * Generic language/style container */ html@ HtmlTagMarker html public inline fun < T , C : TagConsumer < T > > C . span ( classes : String ? = null , crossinline block : SPAN . ( ) -> Unit = { } ) : T html { } /** * Generic language/style container */ div@ HtmlTagMarker div public inline fun < T , C : TagConsumer < T > > C . span ( classes : String ? = null , crossinline block : SPAN . ( ) -> Unit = { } ) : T div { } /** * Generic language/style container */ paragraph@ HtmlTagMarker paragraph public inline fun < T , C : TagConsumer < T > > C . span ( classes : String ? = null , crossinline block : SPAN . ( ) -> Unit = { } ) : T paragraph { } /** * Generic language/style container */ table@ HtmlTagMarker table public inline fun < T , C : TagConsumer < T > > C . span ( classes : String ? = null , crossinline block : SPAN . ( ) -
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
/** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /** * Style info */ /**
{ * @param type * @param crossinline block * @return */ inline fun < T , C : TagConsumer < T > > C . style ( type : String ? = null , crossinline block : STYLE . ( ) -> Unit = { } ) : T /** * Style info */ inline fun < T , C : TagConsumer < T > > C . style ( type : String ? = null , crossinline block : STYLE . ( ) -> Unit = { } ) : T /** * Style info */ inline fun < T , C : TagConsumer < T > > C . style ( type : String ? = null , crossinline block : STYLE . ( ) -> Unit = { } ) : T /** * Style info */ inline fun < T , C : TagConsumer < T > > C . style ( type : String ? = null , crossinline block : STYLE . ( ) -> Unit = { } ) : T /** * Style info */ inline fun < T , C : TagConsumer < T > > C . style ( type : String ? = null , crossinline block :
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * * @param classes * * @param crossinline block * * @return */ public inline fun < T , C : TagConsumer < T > > C . table ( classes : String ? = null , crossinline block : TABLE . ( ) -> Unit = { } ) : T { * * @param classes * * @param crossinline block * * @return */ public inline fun < T , C : TagConsumer < T > > C . table ( classes : String ? = null , crossinline block : TABLE . ( ) -> Unit = { } ) : T { * * @param classes * * @param crossinline block * * @return */ public inline fun < T , C : TagConsumer < T > > C . table ( classes : String ? = null , crossinline block : TABLE . ( ) -> Unit = { } ) : T { * * @param classes * * @param crossinline block * * @return */ public inline fun < T , C : TagConsumer < T > > C . table ( classes : String ? = null , crossinline block :
( classes : String ? = null , crossinline block : TBODY . ( ) -> Unit = { } ) : TagConsumer < T > . tbody ( classes : String ? = null , crossinline block : TBODY . ( ) -> Unit = { } ) : TagConsumer < T > . tbody ( classes : String ? = null , crossinline block : TBODY . ( ) -> Unit = { } ) : TagConsumer < T > . tbody ( classes : String ? = null , crossinline block : TBODY . ( ) -> Unit = { } ) : TagConsumer < T > . tbody ( classes : String ? = null , crossinline block : TBODY . ( ) -> Unit = { } ) : TagConsumer < T > . tbody ( classes : String ? = null , crossinline block : TBODY . ( ) -> Unit = { } ) : TagConsumer < T > . tbody ( classes : String ? = null , crossinline block : TBODY . ( ) -> Unit = { } ) : TagConsumer < T > . tbody ( classes : String ? = null , crossinline block : TBODY . ( ) -> Unit = { } ) : TagConsumer < T > . tbody
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ } /** * Template */ inline fun < T , C : TagConsumer < T > > C . template ( classes : String ? = null , crossinline block : TEMPLATE . ( ) -> Unit = { } ) : T /** * Template */ inline fun < T , C : TagConsumer < T > > C . template ( classes : String ? = null , crossinline block : TEMPLATE . ( ) -> Unit = { } ) : T /** * Template */ inline fun < T , C : TagConsumer < T > > C . template ( classes : String ? = null , crossinline block : TEMPLATE . ( ) -> Unit = { } ) : T /** * Template */ inline fun < T , C : TagConsumer < T > > C . template ( classes : String ? = null , crossinline block : TEMPLATE . ( ) -> Unit = { } ) : T /** * Template */ inline fun < T , C : TagConsumer < T > > C . template ( classes : String ? = null , crossinline block : TEMPLATE . ( ) -> Unit =
{ * * @param rows * @param cols * @param wrap * @param classes * @param content * @return */ public static < T , C : TagConsumer < T > > C . textArea ( rows : String ? = null , cols : String ? = null , wrap : TextAreaWrap ? = null , classes : String ? = null , content : String = " " ) : T { * * @param rows * @param cols * @param wrap * @param classes * @param content * @return */ public static < T , C : TagConsumer < T > > C . textArea ( rows : String ? = null , cols : String ? = null , wrap : TextAreaWrap ? = null , classes : String ? = null , content : String = " " ) : T { * * @param rows * @param cols * @param wrap * @param classes * @param content * @return */ public static < T , C : TagConsumer < T > > C . textArea ( rows : String ? = null ,
( rows : String ? = null , cols : String ? = null , wrap : TextAreaWrap ? = null , classes : String ? = null , crossinline block : TEXTAREA . ( ) -> Unit = { } , ) : C . textArea ( rows : String ? = null , cols : String ? = null , wrap : TextAreaWrap ? = null , classes : String ? = null , crossinline block : C . textArea ( rows : String ? = null , cols : String ? = null , wrap : TextAreaWrap ? = null , classes : String ? = null , crossinline block : C . textArea ( rows : String ? = null , cols : String ? = null , wrap : TextAreaWrap ? = null , classes : String ? = null , crossinline block : C . textArea ( rows : String ? = null , cols : String ? = null , wrap : TextAreaWrap ? = null , classes : String ? = null , crossinline block : C . textArea ( rows : String ? = null , cols : String ? = null , wrap : TextAreaWrap ? = null , classes : String ? = null , crossinline block :
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
/** * Table row cell */ inline fun < T , C : TagConsumer < T > > C . tr ( scope : ThScope ? = null , classes : String ? = null , crossinline block : TH . ( ) -> Unit = { } , ) : T /** * Table column cell */ inline fun < T , C : TagConsumer < T > > C . td ( scope : ThScope ? = null , classes : String ? = null , crossinline block : TH . ( ) -> Unit = { } , ) : T /** * Table header cell */ inline fun < T , C : TagConsumer < T > > C . th ( scope : ThScope ? = null , classes : String ? = null , crossinline block : TH . ( ) -> Unit = { } , ) : T /** * Table row cell */ inline fun < T , C : TagConsumer < T > > C . tr ( scope : ThScope ? = null , classes : String ? = null , crossinline block : TH . ( ) -> Unit = { } , ) : T /** * Table column cell */ inline fun < T ,
{ } /** * Table body */ inline fun < T , C : TagConsumer < T > > C . body ( classes : String ? = null , crossinline block : BODY . ( ) -> Unit = { } ) : T /** * Table footer */ inline fun < T , C : TagConsumer < T > > C . footer ( classes : String ? = null , crossinline block : FOOTER . ( ) -> Unit = { } ) : T /** * Table header */ inline fun < T , C : TagConsumer < T > > C . thead ( classes : String ? = null , crossinline block : THEAD . ( ) -> Unit = { } ) : T /** * Table body */ inline fun < T , C : TagConsumer < T > > C . body ( classes : String ? = null , crossinline block : BODY . ( ) -> Unit = { } ) : T /** * Table footer */ inline fun < T , C : TagConsumer < T > > C . footer ( classes : String ? = null , crossinline block : FOOTER . ( )
{ if ( classes == null ) throw new IllegalArgumentException( "Time must be specified" ) ; if ( crossinline block ) throw new IllegalArgumentException( "Time must be specified" ) ; if ( ! classes ) throw new IllegalArgumentException( "Time must be specified" ) ; if ( ! crossinline block ) throw new IllegalArgumentException( "Time must be specified" ) ; if ( ! crossinline block ) throw new IllegalArgumentException( "Time must be specified" ) ; if ( ! crossinline block ) throw new IllegalArgumentException( "Time must be specified" ) ; if ( ! crossinline block ) throw new IllegalArgumentException( "Time must be specified" ) ; if ( ! crossinline block ) throw new IllegalArgumentException( "Time must be specified" ) ; if ( ! crossinline block ) throw new IllegalArgumentException( "Time must be specified" ) ; if ( ! crossinline block ) throw new IllegalArgumentException( "Time must be specified" ) ; if ( ! crossinline block ) throw new IllegalArgumentException( "Time must be specified" ) ; if ( ! crossinline block ) throw new IllegalArgumentException( "Time must
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ } /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document body */ /** * Document
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , crossinline block : ul ( classes : String ? = null , cro
( classes : String ? = null , crossinline block : VAR . ( ) -> Unit = { } ) : C . htmlVar ( classes : String ? = null , crossinline block : VAR . ( ) -> Unit = { } ) : C . htmlVar ( classes : String ? = null , crossinline block : VAR . ( ) -> Unit = { } ) : C . htmlVar ( classes : String ? = null , crossinline block : VAR . ( ) -> Unit = { } ) : C . htmlVar ( classes : String ? = null , crossinline block : VAR . ( ) -> Unit = { } ) : C . htmlVar ( classes : String ? = null , crossinline block : VAR . ( ) -> Unit = { } ) : C . htmlVar ( classes : String ? = null , crossinline block : VAR . ( ) -> Unit = { } ) : C . htmlVar ( classes : String ? = null , crossinline block : VAR . ( ) -> Unit = { } ) : C . htmlVar ( classes : String ? = null , crossinline block : VAR . ( ) -> Unit = { } ) : C . htmlVar ( classes : String
{ } /** * Video player */ inline fun < T , C : TagConsumer < T > > C . video ( classes : String ? = null , crossinline block : VIDEO . ( ) -> Unit = { } ) : T /** * Video player */ inline fun < T , C : TagConsumer < T > > C . video ( classes : String ? = null , crossinline block : VIDEO . ( ) -> Unit = { } ) : T /** * Video player */ inline fun < T , C : TagConsumer < T > > C . video ( classes : String ? = null , crossinline block : VIDEO . ( ) -> Unit = { } ) : T /** * Video player */ inline fun < T , C : TagConsumer < T > > C . video ( classes : String ? = null , crossinline block : VIDEO . ( ) -> Unit = { } ) : T /** * Video player */ inline fun < T , C : TagConsumer < T > > C . video ( classes : String ? = null , crossinline block : VIDEO . ( ) -> Unit = { } ) : T /**
{ if ( this == Dispatchers.Main ) { return "Main" } else if ( this == Dispatchers.Main.immediate ) { return "Main.immediate" } else { return this.toString() } } /** * Returns a name of this main dispatcher for debugging purposes. This implementation returns * `Dispatchers.Main` or `Dispatchers.Main.immediate` if it is the same as the corresponding * reference in [Dispatchers] or a short class-name representation with address otherwise. */ /** * Returns a name of this main dispatcher for debugging purposes. This implementation returns * `Dispatchers.Main` or `Dispatchers.Main.immediate` if it is the same as the corresponding * reference in [Dispatchers] or a short class-name representation with address otherwise. */ /** * Returns a name of this main dispatcher for debugging purposes. This implementation returns * `Dispatchers.Main` or `Dispatchers.Main.immediate` if it is the same as the corresponding * reference in [Dispatcher
= null * @return */ public static String toStringInternalImpl ( ) : String { if ( this == null ) { return "null"; } else { return this.toString(); } } /** * Internal method for more specific [toString] implementations. It returns non-null * string if this dispatcher is set in the platform as the main one. * @suppress */ public static String toStringInternalImpl ( ) : String { if ( this == null ) { return "null"; } else { return this.toString(); } } /** * Internal method for more specific [toString] implementations. It returns non-null * string if this dispatcher is set in the platform as the main one. * @suppress */ public static String toStringInternalImpl ( ) : String { if ( this == null ) { return "null"; } else { return this.toString(); } }
fun testRunClassFileWithoutExtensionInDefaultPackage ( ) { /* * @param [in] $tmpdir/test/DefaultPackageKt/DefaultPackageKt.class * @param [in] $tmpdir/test/DefaultPackageKt/DefaultPackageKt.class * @param [in] $tmpdir/test/DefaultPackageKt/DefaultPackageKt.class * @param [in] $tmpdir/test/DefaultPackageKt/DefaultPackageKt.class * @param [in] $tmpdir/test/DefaultPackageKt/DefaultPackageKt.class * @param [in] $tmpdir/test/DefaultPackageKt/DefaultPackageKt.class * @param [in] $tmpdir/test/DefaultPackageKt/DefaultPackageKt.class * @param [in] $tmpdir/test/DefaultPackageKt/DefaultPackageKt.class * @param [in] $tmpdir/test/DefaultPackageKt/DefaultPackageKt.class * @param [in] $tmpdir
fun { /* * @param {string} name * @param {string} extension * @param {string} path * @returns {string} */ var name = "test.HelloWorldKt"; var extension = "kt"; var path = "$tmpdir/test/HelloWorldKt.class"; var fileName = name + "." + extension; var filePath = path + "/" + fileName; return filePath; } /** * A class whose full qualified name is `test.HelloWorldKt` and is located in path `$tmpdir/test/HelloWorldKt.kt` */ ktfun testRunClassFileWithExtensionInDefaultPackage ( ) ktfun { /* * @param {string} name * @param {string} extension * @param {string} path * @returns {string} */ var name = "test.HelloWorldKt"; var extension = "kt"; var path = "$tmpdir/test/HelloWorldKt
fun ( ) * * @param engine * * @return * */ public static void reset ( ) { if ( engine == null ) { throw new IllegalArgumentException ( "engine is null" ); } if ( engine == null ) { throw new IllegalArgumentException ( "engine is null" ); } if ( engine == null ) { throw new IllegalArgumentException ( "engine is null" ); } if ( engine == null ) { throw new IllegalArgumentException ( "engine is null" ); } if ( engine == null ) { throw new IllegalArgumentException ( "engine is null" ); } if ( engine == null ) { throw new IllegalArgumentException ( "engine is null" ); } if ( engine == null ) { throw new IllegalArgumentException ( "engine is null" ); } if ( engine == null ) { throw new IllegalArgumentException ( "engine is null
fun () = let globalState = restoreGlobalState () in globalState /** * Restore global state of global object. * * See also [restoreGlobalState] */ globalfun restoreGlobalState () = let globalState = loadGlobalState () in globalState /** * Load global state of global object. * * See also [restoreGlobalState] */ globalfun restoreGlobalState () = let globalState = loadGlobalState () in globalState /** * Load global state of global object. * * See also [restoreGlobalState] */ globalfun restoreGlobalState () = let globalState = loadGlobalState () in globalState /** * Load global state of global object. * * See also [restoreGlobalState] */ globalfun restoreGlobalState () = let globalState = loadGlobalState () in globalState /** * Load global state of global object. * * See also [restoreGlobalState] */ globalfun restoreGlobalState () = let globalState = loadGlobalState () in
fun * * @param globalObject The global object to restore. * * @return The restored global object. */ void restoreGlobalState ( globalObject *globalObject ) { if ( globalObject == NULL ) { fprintf ( stderr, "Failed to restore global state.\n" ); exit ( EXIT_FAILURE ); } globalObject = globalObject->globalObject; } /* * @param globalObject The global object to restore. * * @return The restored global object. */ void saveGlobalState ( globalObject *globalObject ) { if ( globalObject == NULL ) { fprintf ( stderr, "Failed to save global state.\n" ); exit ( EXIT_FAILURE ); } globalObject = globalObject->globalObject; } /* * @param globalObject The global object to save. * * @return The saved global object. */ globalObject *saveGlobalState ( globalObject *globalObject ) { if ( globalObject == NULL
( ) { /* * Release held resources. * * Must be called explicitly before an object is garbage collected to avoid leaking resources. */ } A: I think you are looking for something like this: #include <stdio.h> #include <stdlib.h> #include <string.h> int main(int argc, char *argv[]) { FILE *fp = fopen(argv[1], "r"); if (fp == NULL) { fprintf(stderr, "Could not open file %s\n", argv[1]); exit(EXIT_FAILURE); } char *line = NULL; size_t len = 0; ssize_t read; while ((read = getline(&line, &len, fp)) != -1) { printf("%s\n", line); } fclose(fp); return 0; } A: I think you are looking for something like

* * @param assertionFileName path to xml with expected test results, relative to test resources root * * @param vararg testReportNames test report names * * @param vararg testReportNames test report names * * @param vararg testReportNames test report names * * @param vararg testReportNames test report names * * @param vararg testReportNames test report names * * @param vararg testReportNames test report names * * @param vararg testReportNames test report names * * @param vararg testReportNames test report names * * @param vararg testReportNames test report names * * @param vararg testReportNames test report names * * @param vararg testReportNames test report names * * @param vararg testReportNames test report names * * @param vararg testReportNames test report names * * @param vararg testReportNames test report names * * @param vararg testReportNames test report names * * @param vararg testReportNames test report names * * @param vararg testReport
* * @param taskPath * @return */ public static String getOutputForTask ( String taskPath ) : String { if ( taskPath == null ) { throw new IllegalArgumentException ( "taskPath must not be null" ); } else if ( taskPath.length () == 0 ) { throw new IllegalArgumentException ( "taskPath must not be empty" ); } else if ( taskPath.contains ( "*" ) ) { throw new IllegalArgumentException ( "taskPath must not contain '*'" ); } else if ( taskPath.contains ( "/" ) ) { throw new IllegalArgumentException ( "taskPath must not contain '/'" ); } else if ( taskPath.contains ( "\\" ) ) { throw new IllegalArgumentException ( "taskPath must not contain '\\'" ); } else if ( taskPath.contains ( "." ) ) { throw new IllegalArgumentException ( "taskPath must not contain


.ModuleCompilerAnalyzedOutput ( session : FirSession , firFiles : List < FirFile > , diagnosticsReporter : BaseDiagnosticsCollector ) : ModuleCompilerAnalyzedOutput ( session : FirSession , firFiles : List < FirFile > , diagnosticsReporter : BaseDiagnosticsCollector ) : ModuleCompilerAnalyzedOutput ( session : FirSession , firFiles : List < FirFile > , diagnosticsReporter : BaseDiagnosticsCollector ) : ModuleCompilerAnalyzedOutput ( session : FirSession , firFiles : List < FirFile > , diagnosticsReporter : BaseDiagnosticsCollector ) : ModuleCompilerAnalyzedOutput ( session : FirSession , firFiles : List < FirFile > , diagnosticsReporter : BaseDiagnosticsCollector ) : ModuleCompilerAnalyzedOutput ( session : FirSession , firFiles : List < FirFile > , diagnosticsReporter : BaseDiagnosticsCollector ) : ModuleCompilerAnalyzedOutput ( session : FirSession , firFiles : List < FirFile > , diagnosticsReporter : BaseDiagnosticsCollector ) : ModuleCompilerAnalyzedOutput ( session : FirSession , firFiles : List
fun.onnx.ssd.ssd_object_detection_model ssdLightAPI.onnx.ssd.ssd_object_detection_model ssdLightAPI.onnx.ssd.ssd_object_detection_model ssdLightAPI.onnx.ssd.ssd_object_detection_model ssdLightAPI.onnx.ssd.ssd_object_detection_model ssdLightAPI.onnx.ssd.ssd_object_detection_model ssdLightAPI.onnx.ssd.ssd_object_detection_model ssdLightAPI.onnx.ssd.ssd_object_detection_model ssdLightAPI.onnx.ssd.ssd_object_detection_model ssdLightAPI.onnx.ssd.ssd_object_detection_model ssdLightAPI.onnx.ssd.ssd_object_detection_model ssdLightAPI.onnx.ssd.ssd_object_detection_model ssdLightAPI.onn
( ) { var a = [1,2,3,4,5,6,7,8,9] var b = [1,2,3,4,5,6,7,8,9] var c = [1,2,3,4,5,6,7,8,9] var d = [1,2,3,4,5,6,7,8,9] var e = [1,2,3,4,5,6,7,8,9] var f = [1,2,3,4,5,6,7,8,9] var g = [1,2,3,4,5,6,7,8,9] var h = [1,2,3,4,5,6,7,8,9] var i = [1,2,3,4,5,6,7,8,9] var j = [1,2,3,4,5,6,7,8,9] var k = [1,2,3
fun lenet5Classic ( ) #include <stdio.h> #include <stdlib.h> #include <string.h> #include <sys/types.h> #include <sys/stat.h> #include <fcntl.h> #include <unistd.h> #include <dirent.h> #include <sys/path.h> #include <sys/types.h> #include <sys/stat.h> #include <fcntl.h> #include <unistd.h> #include <dirent.h> #include <sys/path.h> #include <sys/types.h> #include <sys/stat.h> #include <fcntl.h> #include <unistd.h> #include <dirent.h> #include <sys/path.h> #include <sys/types.h> #include <sys/stat.h> #include <fcntl.h> #include <unistd.h> #
( ) { var a = [1,2,3,4,5,6,7,8,9] var b = [1,2,3,4,5,6,7,8,9] var c = [1,2,3,4,5,6,7,8,9] var d = [1,2,3,4,5,6,7,8,9] var e = [1,2,3,4,5,6,7,8,9] var f = [1,2,3,4,5,6,7,8,9] var g = [1,2,3,4,5,6,7,8,9] var h = [1,2,3,4,5,6,7,8,9] var i = [1,2,3,4,5,6,7,8,9] var j = [1,2,3,4,5,6,7,8,9] var k = [1,2,3

{ if ( imageProxy.isNullOrEmpty() ) { return "" } if ( imageProxy.width == 0 ) { return "" } if ( imageProxy.height == 0 ) { return "" } if ( imageProxy.width == 1 && imageProxy.height == 1 ) { return "" } if ( imageProxy.width == 1 && imageProxy.height != 1 ) { return "" } if ( imageProxy.width != 1 && imageProxy.height == 1 ) { return "" } if ( imageProxy.width != 1 && imageProxy.height != 1 ) { return "" } if ( imageProxy.width != 1 && imageProxy.height != 1 ) { return "" } if ( imageProxy.width != 1 && imageProxy.height != 1 ) { return "" } if ( imageProxy.width != 1 && imageProxy.height != 1 ) { return "" } if ( imageProxy.width != 1 && imageProxy.

public fun ByteString . decodeToString ( charset : Charset ) : String * * @param charset the charset to decode data into a string. */ /** * Decodes the content of a byte string to a string using given [charset]. * * @param charset the charset to decode data into a string. */ /** * Decodes the content of a byte string to a string using given [charset]. * * @param charset the charset to decode data into a string. */ /** * Decodes the content of a byte string to a string using given [charset]. * * @param charset the charset to decode data into a string. */ /** * Decodes the content of a byte string to a string using given [charset]. * * @param charset the charset to decode data into a string. */ /** * Decodes the content of a byte string to a string using given [charset]. * * @param charset the charset to decode data into a string. */
{ if ( this == null ) throw new IllegalArgumentException () if ( this.isEmpty() ) throw new IllegalArgumentException () if ( charset == null ) throw new IllegalArgumentException () if ( charset.isNullOrEmpty() ) throw new IllegalArgumentException () if ( charset.isUpperCase() ) throw new IllegalArgumentException () if ( charset.isLowerCase() ) throw new IllegalArgumentException () if ( charset.isDigit() ) throw new IllegalArgumentException () if ( charset.isWhitespace() ) throw new IllegalArgumentException () if ( charset.isPunctuation() ) throw new IllegalArgumentException () if ( charset.isSeparator() ) throw new IllegalArgumentException () if ( charset.isBinary() ) throw new IllegalArgumentException () if ( charset.isUnicode() ) throw new IllegalArgumentException () if ( charset.isUnicode16() ) throw new IllegalArgumentException () if ( charset.isUn





Fun ( bufferedImage , detectedObjects ) { return new JPanel ( detectedObjects ) { @Override public Dimension getPreferredSize () { return new Dimension ( bufferedImage.getWidth () , bufferedImage.getHeight () ) ; } @Override public void paintComponent ( Graphics g ) { super .paintComponent ( g ) ; for ( int i = 0 ; i < detectedObjects.size () ; i ++ ) { Graphics2D g2d = ( Graphics2D ) g ; g2d.draw ( detectedObjects.get ( i ) ) ; } } } } /** * Create a component with the given [bufferedImage] and [detectedObjects] drawn on top of it. */ createDetectedObjectsPanel ( bufferedImage : BufferedImage , detectedObjects : List < DetectedObject > ) { return new JPanel () { @Override public Dimension getPreferredSize () { return new Dimension ( bufferedImage.getWidth () , bufferedImage.getHeight ()
fun = new JPanel () { private BufferedImage bufferedImage; private DetectedPose detectedPose; public JPanel () { this.bufferedImage = bufferedImage; this.detectedPose = detectedPose; } public void paintComponent (Graphics g) { super.paintComponent (g); g.drawImage (bufferedImage, 0, 0, bufferedImage.getWidth(), bufferedImage.getHeight(), BufferedImage.TYPE_INT_ARGB); g.drawLine (0, 0, 0, 0); g.drawLine (0, 0, 0, 0); g.drawLine (0, 0, 0, 0); g.drawLine (0, 0, 0, 0); g.drawLine (0, 0, 0, 0); g.drawLine (0, 0, 0, 0); g.drawLine (0, 0, 0, 0); g.drawLine (0, 0, 0, 0); g.drawLine (0, 0, 0,
Fun = new JPanel () { private final BufferedImage bufferedImage; private final MultiPoseDetectionResult multiPoseDetectionResult; public JPanel () { this.bufferedImage = bufferedImage; this.multiPoseDetectionResult = multiPoseDetectionResult; } @Override public void paintComponent (Graphics g) { super.paintComponent (g); Graphics2D g2d = (Graphics2D) g; g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIASING); g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIASING); g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIASING); g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
fun = new JPanel () { private final BufferedImage bufferedImage; private final List < Landmark > landmarks; public JPanel () { this.bufferedImage = bufferedImage; this.landmarks = new ArrayList < Landmark > (); } @Override public void paintComponent (Graphics g) { super.paintComponent (g); for ( Landmark landmark : landmarks ) { drawLandmark ( g, landmark ); } } private void drawLandmark ( Graphics g , Landmark landmark ) { int x = landmark.x; int y = landmark.y; int width = landmark.width; int height = landmark.height; g.drawLine ( x , y , x + width , y ); g.drawLine ( x , y + height , x + width , y + height ); g.drawLine ( x + width , y , x + width , y + height ); g.drawLine ( x + width , y + height , x , y + height ); } }
protected onCompleted ( value : T ) : void { if ( value == null ) { throw new NullPointerException(); } } /** * This function is invoked once when the job was completed abnormally with the specified [value], * right before all the waiters for the coroutine's completion are notified. */ onAbnormal ( value : T ) onAbnormal ( value : T ) : void { if ( value == null ) { throw new NullPointerException(); } } /** * This function is invoked once when the job was completed abnormally with the specified [value], * right before all the waiters for the coroutine's completion are notified. */ onAbnormal ( value : T ) onAbnormal ( value : T ) : void { if ( value == null ) { throw new NullPointerException(); } } /** * This function is invoked once when the job was completed abnormally with the specified [value], * right before all the waiters for the coroutine's completion are notified. */ onAbnormal ( value : T ) onAbnormal (

: Result < T > { return this.resumeWith(result) } /** * Completes execution of this with coroutine with the specified result. */ resumeWith ( result : Result < T > ) : Result < T > { return this.resumeWith(result) } /** * Completes execution of this with coroutine with the specified result. */ resumeWith ( result : Result < T > ) : Result < T > { return this.resumeWith(result) } /** * Completes execution of this with coroutine with the specified result. */ resumeWith ( result : Result < T > ) : Result < T > { return this.resumeWith(result) } /** * Completes execution of this with coroutine with the specified result. */ resumeWith ( result : Result < T > ) : Result < T > { return this.resumeWith(result) } /** * Completes execution of this with coroutine with the specified result. */ resumeWith ( result : Result < T > ) : Result < T > {

LegacyImplementationMetadataConfigurationName : String = "legacyImplementationMetadataConfigurationName" * addDependencyForLegacyImplementationMetadataConfigurationName : String = "legacyImplementationMetadataConfigurationName" * addDependencyForLegacyImplementationMetadataConfigurationName : String = "legacyImplementationMetadataConfigurationName" * addDependencyForLegacyImplementationMetadataConfigurationName : String = "legacyImplementationMetadataConfigurationName" * addDependencyForLegacyImplementationMetadataConfigurationName : String = "legacyImplementationMetadataConfigurationName" * addDependencyForLegacyImplementationMetadataConfigurationName : String = "legacyImplementationMetadataConfigurationName" * addDependencyForLegacyImplementationMetadataConfigurationName : String = "legacyImplementationMetadataConfigurationName" * addDependencyForLegacyImplementationMetadataConfigurationName : String = "legacyImplementationMetadataConfigurationName" * addDependencyForLegacyImplementationMetadataConfigurationName : String = "legacyImplementationMetadataConfigurationName" * addDependencyForLegacyImplementation
: String { if ( declaration.isExported() ) { return "" } if ( declaration.isPrivate() ) { return "" } if ( declaration.isStatic() ) { return "" } if ( declaration.isFunction() ) { return "" } if ( declaration.isClass() ) { return "" } if ( declaration.isEnum() ) { return "" } if ( declaration.isInterface() ) { return "" } if ( declaration.isStruct() ) { return "" } if ( declaration.isUnion() ) { return "" } if ( declaration.isArray() ) { return "" } if ( declaration.isMap() ) { return "" } return "" } /** * Produces the name to be used for non-exported LLVM declarations corresponding to [declaration]. * * Note: since these declarations are going to be private, the name is only required not
{ if ( this == null ) { return "null" } else if ( this.isEmpty() ) { return "null" } else if ( this.isBlank() ) { return "null" } else if ( this.isBlankOrNull() ) { return "null" } else if ( this.isBlankOrBlankOrNull() ) { return "null" } else if ( this.isBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBl
{ if ( this.isEmpty() ) throw new NoSuchElementException () return this.first() } /** * Returns the last element. * * @throws NoSuchElementException if the progression is empty. */ kotlin@ SinceKotlin ( " kotlin" ) public fun IntProgression . last ( ) : Int { if ( this.isEmpty() ) throw new NoSuchElementException () return this.last() } /** * Returns the element at the specified index. * * @throws IndexOutOfBoundsException if the index is out of bounds. */ kotlin@ SinceKotlin ( " kotlin" ) public fun IntProgression . get ( index : Int ) : Int { if ( index < 0 || index >= this.size ) throw new IndexOutOfBoundsException () return this.get( index ) } /** * Returns the element at the specified index. * * @throws IndexOutOfBoundsException if the index is out of bounds.
? { if ( this.isEmpty () ) throw new NoSuchElementException () ; return this.first () ; } /** * Returns the last element. * * @throws NoSuchElementException if the progression is empty. */ kotlin@ SinceKotlin ( " kotlin" ) public fun LongProgression . last ( ) : Long ? { if ( this.isEmpty () ) throw new NoSuchElementException () ; return this.last () ; } /** * Returns the number of elements. * * @throws NoSuchElementException if the progression is empty. */ kotlin@ SinceKotlin ( " kotlin" )
{ if ( this.isEmpty() ) throw new NoSuchElementException () return this.first() } /** * Returns the last element. * * @throws NoSuchElementException if the progression is empty. */ kotlin@ SinceKotlin ( " kotlin" ) public fun CharProgression . last ( ) : Char { if ( this.isEmpty() ) throw new NoSuchElementException () return this.last() } /** * Returns the number of elements. * * @throws NoSuchElementException if the progression is empty. */ kotlin@ SinceKotlin ( " kotlin" ) public fun CharProgression . size ( ) : Int { if ( this.isEmpty() ) throw new NoSuchElementException () return this.size() } /** * Returns the number of elements. * * @throws NoSuchElementException if the progression is empty. */ kotlin@ SinceKotlin ( " kotlin" ) public fun CharProgression
/** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null`
/** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /** * Returns the last element, or `null` if the progression is empty. */ /**
/** * Returns the last element, or `null` if the progression is empty. */ charProgression . lastOrNull ( ) : Char ? /** * Returns the first element, or `null` if the progression is empty. */ charProgression . firstOrNull ( ) : Char ? /** * Returns the last element, or `null` if the progression is empty. */ charProgression . lastOrNull ( ) : Char ? /** * Returns the first element, or `null` if the progression is empty. */ charProgression . firstOrNull ( ) : Char ? /** * Returns the last element, or `null` if the progression is empty. */ charProgression . lastOrNull ( ) : Char ? /** * Returns the first element, or `null` if the progression is empty. */ charProgression . firstOrNull ( ) : Char ? /** * Returns the last element, or `null` if the progression is empty. */ charProgression . lastOrNull ( ) : Char ? /** * Returns the first element, or `null` if the progression i
{ if ( this.isEmpty () ) throw new NoSuchElementException () return this.size () - 1 } /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the last element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty. *
{ if ( this.isEmpty () ) throw new NoSuchElementException () return this[ this.size - 1 ] } /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the last element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty.
{ if ( this.isEmpty () ) throw new NoSuchElementException () return this.get ( this.size () - 1 ) } /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the last element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element. * * @throws NoSuchElementException if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element. * * @throws NoSuchElementException if the progression i
{ if ( this.isEmpty () ) return null return this[ this.size - 1 ] } /** * Returns the first element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.firstOrNull ( ) : Int ? */ /** * Returns the last element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.firstOrNull ( ) : Int ? */ /** * Returns the first element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.firstOrNull ( ) : Int ? */ /** * Returns the first element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.firstOrNull ( ) : Int ? */ /** * Returns the first element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.
@ SinceKotlin ( " kotlin" ) /** * Returns the first element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the last element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ /** * Returns the first element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.
{ if ( this == null ) throw new IllegalArgumentException () if ( this.isEmpty () ) throw new IllegalArgumentException () return this.last () } /** * Returns the first element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.first */ fun CharProgression . firstOrNull ( ) : Char ? flow { if ( this == null ) throw new IllegalArgumentException () if ( this.isEmpty () ) throw new IllegalArgumentException () return this.first () } /** * Returns the last element, or `null` if the progression is empty. * * @sample samples.collections.Collections.Elements.last */ fun CharProgression . lastOrNull ( ) : Char ? flow { if ( this == null ) throw new IllegalArgumentException () if ( this.isEmpty () ) throw new IllegalArgumentException () return this.last () } /** * Returns the first element, or `null` if the progression i
@ kotlin . internal @ kotlin . InlineOnly @ kotlin . internal @ kotlin . InlineOnly @ kotlin . internal @ kotlin . InlineOnly @ kotlin . internal @ kotlin . InlineOnly @ kotlin . internal @ kotlin . InlineOnly @ kotlin . internal @ kotlin . InlineOnly @ kotlin . internal @ kotlin . InlineOnly @ kotlin . internal @ kotlin . InlineOnly @ kotlin . internal @ kotlin . InlineOnly @ kotlin . internal @ kotlin . InlineOnly @ kotlin . internal @ kotlin . InlineOnly @ kotlin . internal @ kotlin . InlineOnly @ kotlin . internal @ kotlin . InlineOnly @ kotlin . internal @ kotlin . InlineOnly @ kotlin . internal @ kotlin . InlineOnly @ kotlin . internal @ kotlin . InlineOnly @ kotlin . internal @ kotlin . InlineOnly @ kotlin . internal @ kotlin . InlineOnly @ kotlin
{ if ( this.isEmpty() ) throw IllegalArgumentException( "Range is empty" ) return this.first() } /** * Returns a random element from this range. * * @throws IllegalArgumentException if this range is empty. */ kotlin@ SinceKotlin ( " kotlin" ) public inline fun LongRange . random ( ) : Long { if ( this.isEmpty() ) throw IllegalArgumentException( "Range is empty" ) return this.first() } /** * Returns a random element from this range. * * @throws IllegalArgumentException if this range is empty. */ kotlin@ SinceKotlin ( " kotlin" ) public inline fun LongRange . random ( ) : Long { if ( this.isEmpty() ) throw IllegalArgumentException( "Range is empty" ) return this.first() } /** * Returns a random element from this range. * * @throws IllegalArgumentException if this range is empty. */ k
@ kotlin . internal @ kotlin . InlineOnly @ kotlin . public inline fun CharRange . random ( start : Int, end : Int ) : Char /** * Returns a random element from this range. * * @throws IllegalArgumentException if this range is empty. */ char@ SinceKotlin ( " char" ) @kotlin . internal @ kotlin . InlineOnly @ kotlin . public inline fun CharRange . random ( start : Int, end : Int ) : Char /** * Returns a random element from this range. * * @throws IllegalArgumentException if this range is empty. */ byte@ SinceKotlin ( " byte" ) @kotlin . internal @ kotlin . InlineOnly @ kotlin . public inline fun CharRange . random ( start : Int, end : Int ) : Byte /** * Returns a random element from this range. * * @throws IllegalArgumentException if this range is empty. */ short@ SinceKotlin ( " short" ) @kotlin
{ if ( this.isEmpty() ) throw IllegalArgumentException () return random.nextInt ( this.size ) } /** * Returns a random element from this range using the specified source of randomness. * * @throws IllegalArgumentException if this range is empty. */ kotlin@ SinceKotlin ( " kotlin" ) fun IntRange . random ( random : Random ) : Int { if ( this.isEmpty() ) throw IllegalArgumentException () return random.nextInt ( this.size ) } /** * Returns a random element from this range using the specified source of randomness. * * @throws IllegalArgumentException if this range is empty. */ kotlin@ SinceKotlin ( " kotlin" ) fun IntRange . random ( random : Random ) : Int { if ( this.isEmpty() ) throw IllegalArgumentException () return random.nextInt ( this.size ) } /** * Returns a random element from this range using the specified source of randomness.
{ if ( this.isEmpty() ) { throw new IllegalArgumentException( "Range is empty" ) } return this.random( random ) } /** * Returns a random element from this range using the specified source of randomness. * * @throws IllegalArgumentException if this range is empty. */ kotlin@ SinceKotlin ( " kotlin" ) public fun LongRange . random ( random : Random ) : Long { if ( this.isEmpty() ) { throw new IllegalArgumentException( "Range is empty" ) } return this.random( random ) } /** * Returns a random element from this range using the specified source of randomness. * * @throws IllegalArgumentException if this range is empty. */ kotlin@ SinceKotlin ( " kotlin" ) public fun LongRange . random ( random : Random ) : Long { if ( this.isEmpty() ) { throw new IllegalArgumentException( "Range is empty" ) }
{ if ( this.isEmpty() ) { throw IllegalArgumentException () } if ( this.start == this.end ) { throw IllegalArgumentException () } if ( this.start > this.end ) { throw IllegalArgumentException () } if ( this.start == this.end ) { throw IllegalArgumentException () } if ( this.start > this.end ) { throw IllegalArgumentException () } if ( this.start > this.end ) { throw IllegalArgumentException () } if ( this.start > this.end ) { throw IllegalArgumentException () } if ( this.start > this.end ) { throw IllegalArgumentException () } if ( this.start > this.end ) { throw IllegalArgumentException () } if ( this.start > this.end ) { throw IllegalArgumentException () } if ( this.start > this.end ) { throw Illegal
*/ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /**
/** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `
*/ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /** * Returns a random element from this range, or `null` if this range is empty. */ /**
/** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ fun IntRange . randomOrNull ( random : Random ) : Int? /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ fun IntRange . randomOrNull ( random : Random ) : Int? /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ fun IntRange . randomOrNull ( random : Random ) : Int? /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ fun IntRange . randomOrNull ( random : Random ) : Int? /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ fun IntRange . randomOrNull ( random : Random ) : Int? /** * Returns a random element from this range using the specified source
/** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ fun LongRange . randomOrNull ( random : Random ) : Long? /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ fun LongRange . randomOrNull ( random : Random ) : Long? /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ fun LongRange . randomOrNull ( random : Random ) : Long? /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ fun LongRange . randomOrNull ( random : Random ) : Long? /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ fun LongRange . randomOrNull ( random : Random ) : Long? /** * Returns a random element from this range using the specified source
/** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ CharRange . randomOrNull ( random : Random ) : Char /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ CharRange . randomOrNull ( random : Random ) : Char /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ CharRange . randomOrNull ( random : Random ) : Char /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ CharRange . randomOrNull ( random : Random ) : Char /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty. */ CharRange . randomOrNull ( random : Random ) : Char /** * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.
/** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. *
/** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. *
/** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. * * Always returns `false` if the [element] is `null`. */ /** * Returns `true` if this range contains the specified [element]. *
{ if ( value < 0 ) return false; if ( value > 255 ) return false; return true; } /** * Checks if the specified [value] belongs to this range. */ iphone/** * Checks if the specified [value] belongs to this range. */ iphone/** * Checks if the specified [value] belongs to this range. */ iphone/** * Checks if the specified [value] belongs to this range. */ iphone/** * Checks if the specified [value] belongs to this range. */ iphone/** * Checks if the specified [value] belongs to this range. */ iphone/** * Checks if the specified [value] belongs to this range. */ iphone/** * Checks if the specified [value] belongs to this range. */ iphone/** * Checks if the specified [value] belongs to this range. */ iphone/** * Checks if the specified [value] belongs to this range. */ iphone/** * Checks if the specified [value] belongs to this range. */ iphone/** * Check
{ if ( value < 0 ) { return false; } if ( value > this.size ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm . JvmName ( " kotlin" ) public operator fun ClosedRange < Byte > . contains ( value : Byte ) : Boolean { if ( value < 0 ) { return false; } if ( value > this.size ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm . JvmName ( " kotlin" )
{ if ( value < 0 ) { return false; } else if ( value > 255 ) { return false; } else { return true; } } /** * Checks if the specified [value] belongs to this range. */ iphone@ kotlin . jvm . JvmName ( " iphone" ) iphone public operator fun ClosedRange < Short > . contains ( value : Byte ) : Boolean { if ( value < 0 ) { return false; } else if ( value > 255 ) { return false; } else { return true; } } /** * Checks if the specified [value] belongs to this range. */ iphone@ kotlin . jvm . JvmName ( " iphone" ) iphone public operator fun ClosedRange < Short > . contains ( value : Byte ) : Boolean { if ( value < 0 ) { return false; } else if ( value > 255 ) { return false; } else {
@ kotlin . jvm . JvmName ( " kotlin" )
@ kotlin . jvm . JvmName ( " kotlin" ) /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Byte > . contains ( value : Byte ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Int > . contains ( value : Int ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Long > . contains ( value : Long ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range,
*/ public operator fun OpenEndRange < Int > . contains ( value : Byte ) : Boolean { if ( value < 0 ) { return false } if ( value > 255 ) { return false } return true } /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Int > . contains ( value : Int ) : Boolean { if ( value < 0 ) { return false } if ( value > 255 ) { return false } return true } /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Int > . contains ( value : Int ) : Boolean { if ( value < 0 ) { return false } if ( value > 255 ) { return false } return true } /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Int > . contains ( value : Int ) : Boolean {
fun OpenEndRange < Byte > . contains ( value : Byte ) : Boolean */ public operator fun OpenEndRange < Byte > . contains ( value : Byte ) : Boolean { return value >= 0 && value <= 255 } /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Byte > . contains ( value : Byte ) : Boolean { return value >= 0 && value <= 255 } /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Byte > . contains ( value : Byte ) : Boolean { return value >= 0 && value <= 255 } /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Byte > . contains ( value : Byte ) : Boolean { return value >= 0 && value <= 255 } /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Byte > . contains ( value : Byte ) : Boolean { return
public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean */ /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean /** * Checks if
{ if ( value < 0 ) { return false } if ( value > 255 ) { return false } return true } /** * Checks if the specified [value] belongs to this range. */ fun IntRange . contains ( value : Byte ) : Boolean { if ( value < 0 ) { return false } if ( value > 255 ) { return false } return true } /** * Checks if the specified [value] belongs to this range. */ fun IntRange . contains ( value : Byte ) : Boolean { if ( value < 0 ) { return false } if ( value > 255 ) { return false } return true } /** * Checks if the specified [value] belongs to this range. */ fun IntRange . contains ( value : Byte ) : Boolean { if ( value < 0 ) { return false } if ( value > 255 ) { return false } return true } /**
{ if ( value < 0 ) { return false } else if ( value > this.size ) { return false } else { return true } } /** * Checks if the specified [value] belongs to this range. */ longRange@ kotlin . internal . InlineOnly public inline operator fun LongRange . contains ( value : Long ) : Boolean { if ( value < 0 ) { return false } else if ( value > this.size ) { return false } else { return true } } /** * Checks if the specified [value] belongs to this range. */ byteRange@ kotlin . internal . InlineOnly public inline operator fun ByteRange . contains ( value : Byte ) : Boolean { if ( value < 0 ) { return false } else if ( value > this.size ) { return false } else { return true } } /** * Checks if the specified [value] belongs to this range. */ shortRange
@ kotlin . jvm . JvmName ( " kotlin" )
@ kotlin . jvm . JvmName ( " kotlin" ) /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value belongs to this range, false otherwise. */ public operator fun ClosedRange < Long > . contains ( value : Long ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value belongs to this range, false otherwise. */ public operator fun ClosedRange < Double > . contains ( value : Double ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value belongs to this range, false otherwise. */ public operator fun ClosedRange < Float > . contains ( value : Float ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value belongs to this range,
@ kotlin . jvm . JvmName ( " kotlin" ) /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value belongs to this range, false otherwise. */ /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value belongs to this range, false otherwise. */ /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value belongs to this range, false otherwise. */ /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value belongs to this range, false otherwise. */ /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value belongs to this range, false otherwise
@ kotlin . jvm . JvmName ( " kotlin" )
{ return value >= this.min && value <= this.max; } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm . JvmName ( " iphone" ) iphone public operator fun ClosedRange < Int > . contains ( value : Int ) : Boolean return value >= this.min && value <= this.max; } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm . JvmName ( " iphone" ) iphone public operator fun ClosedRange < String > . contains ( value : String ) : Boolean return value >= this.min && value <= this.max; } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm . JvmName ( " iphone" ) iphone public operator fun ClosedRange < String > . contains ( value : String ) : Boolean return value >= this.min && value <= this.max; } /** * Checks if the specified [value] belong
@ kotlin . jvm . JvmName ( " kotlin" ) /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Int > . contains ( value : Int ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Int > . contains ( value : Int ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Int > . contains ( value : Int ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value i
@ kotlin . jvm . JvmName ( " kotlin" ) /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Long > . contains ( value : Long ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Long > . contains ( value : Long ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Long > . contains ( value : Long ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range,
@ kotlin . jvm . JvmName ( " kotlin" ) /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Byte > . contains ( value : Byte ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Byte > . contains ( value : Byte ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Byte > . contains ( value : Byte ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range,
@ kotlin . jvm . JvmName ( " kotlin" ) /** * Checks if the specified [value] belongs to this range. * * @param value the value to check * @return true if the value is in the range, false otherwise */ fun ClosedRange < Short > . contains ( value : Short ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value the value to check * @return true if the value is in the range, false otherwise */ fun ClosedRange < Short > . contains ( value : Short ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value the value to check * @return true if the value is in the range, false otherwise */ fun ClosedRange < Short > . contains ( value : Short ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value the value to check * @return true if the value is in the range, false otherwise */ fun ClosedRange < Short > . contain
{ if ( value < this.min ) return false if ( value > this.max ) return true return this.min <= value && value <= this.max } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm . JvmName ( " iphone" ) iphone public operator fun ClosedRange < String > . contains ( value : String ) : Boolean if ( value < this.min ) return false if ( value > this.max ) return true return this.min <= value && value <= this.max } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm . JvmName ( " android" ) android public operator fun ClosedRange < String > . contains ( value : String ) : Boolean if ( value < this.min ) return false if ( value > this.max ) return true return this.min <= value && value <= this.max } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm
fun OpenEndRange < Double > . contains ( value : Double ) : Boolean /** * Checks if the specified [value] belongs to this range. */ fun OpenEndRange < Double > . contains ( value : Double ) : Boolean /** * Checks if the specified [value] belongs to this range. */ fun OpenEndRange < Double > . contains ( value : Double ) : Boolean /** * Checks if the specified [value] belongs to this range. */ fun OpenEndRange < Double > . contains ( value : Double ) : Boolean /** * Checks if the specified [value] belongs to this range. */ fun OpenEndRange < Double > . contains ( value : Double ) : Boolean /** * Checks if the specified [value] belongs to this range. */ fun OpenEndRange < Double > . contains ( value : Double ) : Boolean /** * Checks if the specified [value] belongs to this range. */ fun OpenEndRange < Double > . contains ( value : Double ) : Boolean /** * Checks if the specified [value] belongs to this range. */ fun OpenEndRange
{ if ( value < 0 ) { return false; } else if ( value > this.size ) { return false; } else { return true; } } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm . JvmName ( " iphone" ) iphone public operator fun ClosedRange < Long > . contains ( value : Long ) : Boolean if ( value < 0 ) { return false; } else if ( value > this.size ) { return false; } else { return true; } } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm . JvmName ( " android" ) android public operator fun ClosedRange < Long > . contains ( value : Long ) : Boolean if ( value < 0 ) { return false; } else if ( value > this.size ) { return false; } else { return true; } } /**
{ if ( value < 0 ) { return false; } else if ( value > 255 ) { return false; } else { return true; } } /** * Checks if the specified [value] belongs to this range. */ byte@ kotlin . jvm . JvmName ( " byte" ) public operator fun ClosedRange < Byte > . contains ( value : Byte ) : Boolean { if ( value < 0 ) { return false; } else if ( value > 255 ) { return false; } else { return true; } } /** * Checks if the specified [value] belongs to this range. */ short@ kotlin . jvm . JvmName ( " short" )
{ if ( value < 0 ) { return false; } else if ( value > this.size ) { return false; } else { return true; } } /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range.
@ kotlin . jvm . JvmName ( " kotlin" )
@ kotlin . jvm . JvmName ( " kotlin" ) /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Float > . contains ( value : Float ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Int > . contains ( value : Int ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Long > . contains ( value : Long ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value i
public operator fun OpenEndRange < Long > . contains ( value : Long ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Long > . contains ( value : Long ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Long > . contains ( value : Long ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Long > . contains ( value : Long ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Long > . contains ( value : Long ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Long > . contains ( value : Long ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Long > . contains ( value : Long ) : Boolean /** * Checks if the specified
public operator fun OpenEndRange < Byte > . contains ( value : Byte ) : Boolean */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if the specified [value] belongs to this range. */ /** * Checks if
public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean { return value >= 0 && value <= this.size() } /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean { return value >= 0 && value <= this.size() } /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean { return value >= 0 && value <= this.size() } /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean { return value >= 0 && value <= this.size() } /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean
{ if ( value < 0 ) { return false } else if ( value > this.size ) { return false } else { return true } } /** * Checks if the specified [value] belongs to this range. */ longRange@ kotlin . internal . InlineOnly public inline operator fun LongRange . contains ( value : Long ) : Boolean { if ( value < 0 ) { return false } else if ( value > this.size ) { return false } else { return true } } /** * Checks if the specified [value] belongs to this range. */ shortRange@ kotlin . internal . InlineOnly public inline operator fun ShortRange . contains ( value : Short ) : Boolean { if ( value < 0 ) { return false } else if ( value > this.size ) { return false } else { return true } } /** * Checks if the specified [value] belongs to this range. */ byteRange
{ if ( value < 0 ) { return false; } else if ( value > this.size ) { return false; } else { return true; } } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm . JvmName ( " iphone" ) iphone public operator fun ClosedRange < Int > . contains ( value : Long ) : Boolean if ( value < 0 ) { return false; } else if ( value > this.size ) { return false; } else { return true; } } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm . JvmName ( " android" ) android public operator fun ClosedRange < Int > . contains ( value : Long ) : Boolean if ( value < 0 ) { return false; } else if ( value > this.size ) { return false; } else { return true; } } /**
{ if ( value < 0 ) { return false; } if ( value > 255 ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range. */ byte@ kotlin . jvm . JvmName ( " byte" ) public operator fun ClosedRange < Byte > . contains ( value : Byte ) : Boolean { if ( value < 0 ) { return false; } if ( value > 255 ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range. */ short@ kotlin . jvm . JvmName ( " short" )
{ if ( value < 0 ) { return false; } else if ( value > this.size ) { return false; } else { return true; } } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm . JvmName ( " iphone" ) iphone public operator fun ClosedRange < Short > . contains ( value : Short ) : Boolean if ( value < 0 ) { return false; } else if ( value > this.size ) { return false; } else { return true; } } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm . JvmName ( " android" ) android public operator fun ClosedRange < Short > . contains ( value : Short ) : Boolean if ( value < 0 ) { return false; } else if ( value > this.size ) { return false; } else { return true; } } /**
@ kotlin . jvm . JvmName ( " kotlin" )
@ kotlin . jvm . JvmName ( " kotlin" ) /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Float > . contains ( value : Float ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Int > . contains ( value : Int ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range, false otherwise. */ public operator fun ClosedRange < Long > . contains ( value : Long ) : Boolean /** * Checks if the specified [value] belongs to this range. * * @param value The value to check. * @return true if the value is in the range,
public operator fun OpenEndRange < Int > . contains ( value : Int ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Int > . contains ( value : Int ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Int > . contains ( value : Int ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Int > . contains ( value : Int ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Int > . contains ( value : Int ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Int > . contains ( value : Int ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Int > . contains ( value : Int ) : Boolean /** * Checks if the specified
fun OpenEndRange < Byte > . contains ( value : Byte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Byte > . contains ( value : Byte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Byte > . contains ( value : Byte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Byte > . contains ( value : Byte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Byte > . contains ( value : Byte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Byte > . contains ( value : Byte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Byte > . contains ( value : Byte ) : Boolean /** *
public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short )
{ if ( value < this.min ) return false if ( value > this.max ) return true return this.min <= value && value <= this.max } /** * Checks if the specified [value] belongs to this range. */ fun IntRange . contains ( value : Long ) : Boolean { if ( value < this.min ) return false if ( value > this.max ) return true return this.min <= value && value <= this.max } /** * Checks if the specified [value] belongs to this range. */ fun IntRange . contains ( value : Long ) : Boolean { if ( value < this.min ) return false if ( value > this.max ) return true return this.min <= value && value <= this.max } /** * Checks if the specified [value] belongs to this range. */ fun IntRange . contains ( value : Long ) : Boolean { if ( value < this.min ) return false if ( value > this.max ) return true return this.min <= value && value <= thi
{ if ( value < 0 ) { return false; } else if ( value > this.size ) { return false; } else { return true; } } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm . JvmName ( " iphone" ) iphone public operator fun ClosedRange < Int > . contains ( value : Short ) : Boolean if ( value < 0 ) { return false; } else if ( value > this.size ) { return false; } else { return true; } } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm . JvmName ( " android" ) android public operator fun ClosedRange < Int > . contains ( value : Short ) : Boolean if ( value < 0 ) { return false; } else if ( value > this.size ) { return false; } else { return true; } } /**
{ if ( value < 0 ) { return false; } if ( value > this.size ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm . JvmName ( " iphone" ) iphone public operator fun ClosedRange < Short > . contains ( value : Short ) : Boolean if ( value < 0 ) { return false; } if ( value > this.size ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range. */ kotlin . jvm . JvmName ( " android" ) android public operator fun ClosedRange < Short > . contains ( value : Short ) : Boolean if ( value < 0 ) { return false; } if ( value > this.size ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range
{ if ( value < 0 ) { return false; } if ( value > 255 ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range. */ iphone@ kotlin . jvm . JvmName ( " iphone" ) iphone public operator fun ClosedRange < Short > . contains ( value : Short ) : Boolean if ( value < 0 ) { return false; } if ( value > 255 ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range. */ iphone@ kotlin . jvm . JvmName ( " iphone" ) iphone public operator fun ClosedRange < Integer > . contains ( value : Integer ) : Boolean if ( value < 0 ) { return false; } if ( value > 255 ) { return false; } return true; } /** * Checks if the
@ kotlin . jvm . JvmName ( " kotlin" )
@ kotlin . jvm . JvmName ( " kotlin" ) /** * Checks if the specified [value] belongs to this range. */ public operator fun ClosedRange < Float > . contains ( value : Float ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun ClosedRange < Int > . contains ( value : Int ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun ClosedRange < Long > . contains ( value : Long ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun ClosedRange < Short > . contains ( value : Short ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun ClosedRange < Byte > . contains ( value : Byte ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun ClosedRange < Short > . contains ( value : Short ) : Boolean /** * Checks if the specified [value] belongs to thi
public operator fun OpenEndRange < Int > . contains ( value : Long ) : Boolean A: You can do it like this: fun main(args: Array<String>) { val list = listOf(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L, 12L, 13L, 14L, 15L, 16L, 17L, 18L, 19L, 20L, 21L, 22L, 23L, 24L, 25L, 26L, 27L, 28L, 29L, 30L, 31L, 32L, 33L, 34L, 35L, 36L, 37L, 38L, 39L, 40L, 41L, 42L, 43L, 44L, 45L, 46L, 47L, 48L, 49L, 50L, 51L, 52L, 53L, 54L, 55L, 56L, 57L, 58L, 59L, 60L, 61L, 62L, 63L, 64L, 65L, 66L, 67L, 68L, 69
public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean */ /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Long > . contains ( value : Long ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Integer > . contains ( value : Integer ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Float > . contains ( value : Float ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Double > . contains ( value : Double ) : Boolean /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Boolean > . contains ( value : Boolean ) : Boolean /** * Checks if
*/ public operator fun OpenEndRange < Byte > . contains ( value : Byte ) : Boolean { return value >= 0 && value <= 255 } /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Short > . contains ( value : Short ) : Boolean { return value >= 0 && value <= 65535 } /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Int > . contains ( value : Int ) : Boolean { return value >= 0 && value <= 2147483647 } /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Long > . contains ( value : Long ) : Boolean { return value >= 0 && value <= 9223372036854775807 } /** * Checks if the specified [value] belongs to this range. */ public operator fun OpenEndRange < Float > . contains ( value : Float ) : Boolean { return value >= 0
{ if ( value < 0 ) return false if ( value > this.max ) return false return true } /** * Checks if the specified [value] belongs to this range. */ fun IntRange . contains ( value : Short ) : Boolean { if ( value < 0 ) return false if ( value > this.max ) return false return true } /** * Checks if the specified [value] belongs to this range. */ fun IntRange . contains ( value : Short ) : Boolean { if ( value < 0 ) return false if ( value > this.max ) return false return true } /** * Checks if the specified [value] belongs to this range. */ fun IntRange . contains ( value : Short ) : Boolean { if ( value < 0 ) return false if ( value > this.max ) return false return true } /** * Checks if the specified [value] belongs to this range. */ fun IntRange . contains ( value : Short ) : Boolean { if ( value < 0 ) return false
{ if ( value < 0 ) { return false; } if ( value > this.max ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range. */ fun LongRange . contains ( value : Short ) : Boolean { if ( value < 0 ) { return false; } if ( value > this.max ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range. */ fun LongRange . contains ( value : Long ) : Boolean { if ( value < 0 ) { return false; } if ( value > this.max ) { return false; } return true; } /** * Checks if the specified [value] belongs to this range. */ fun LongRange . contains ( value : Long ) : Boolean { if ( value < 0 ) { return false; } if ( value > this.max )
= if ( to <= this ) IntProgression ( this, to ) else IntProgression ( this, to - 1 ) /** * Returns a progression from this value up to the specified [from] value with the step +1. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [from] value should be less than or equal to `this` value. * If the [from] value is greater than `this` value the returned progression is empty. */ if ( from <= this ) IntProgression ( this, from ) else IntProgression ( this, from + 1 ) /** * Returns a progression from this value down to the specified [from] value with the step +1. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [
= if ( to <= this ) LongProgression () else LongProgression ( to - 1, this - to ) /** * Returns a progression from this value up to the specified [from] value with the step +1. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [to] value should be less than or equal to `this` value. * If the [to] value is greater than `this` value the returned progression is empty. */ fun LongProgression . upTo ( from : Byte ) : LongProgression = if ( from >= this ) LongProgression () else LongProgression ( from + 1, this - from ) /** * Returns a progression from this value up to the specified [from] value with the step +1. * * The [from] value should be greater than or equal to `this` value. * If the [
= { if ( to <= this ) return IntProgression ( this, to ) else return IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( Int
= if ( to <= this ) IntProgression () else IntProgression ( downTo ( to - 1 ) ) /** * Returns a progression from this value up to the specified [from] value with the step 1. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [from] value should be less than or equal to `this` value. * If the [from] value is greater than `this` value the returned progression is empty. * * The [to] value should be less than or equal to `this` value. * If the [to] value is greater than `this` value the returned progression is empty. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [to] value should be greater than or equal to `this` value.
= if to <= this then CharProgression ( this, to ) else CharProgression ( this, to - 1 ) /** * Returns a progression from this value up to the specified [from] value with the step +1. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [to] value should be less than or equal to `this` value. * If the [to] value is greater than `this` value the returned progression is empty. */ fun Char . upTo ( from : Char ) : CharProgression = if from <= this then CharProgression ( this, from ) else CharProgression ( this, from + 1 ) /** * Returns a progression from this value up to the specified [from] value with the step +1. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression i
= if ( to <= this ) IntProgression () else IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 )
= if ( to <= this ) LongProgression () else LongProgression ( to - 1, this - 1 ) /** * Returns a progression from this value up to the specified [from] value with the step +1. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [to] value should be less than or equal to `this` value. * If the [to] value is greater than `this` value the returned progression is empty. */ fun LongProgression . upTo ( from : Int ) : LongProgression = if ( from <= this ) LongProgression () else LongProgression ( from + 1, this - 1 ) /** * Returns a progression from this value up to the specified [from] value with the step +1. * * The [from] value should be greater than or equal to `this` value. * If the
= if ( to <= this ) new IntProgression ( this, to ) else new IntProgression ( this, to - 1 ) /** * Returns a progression from this value up to the specified [from] value with the step 1. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [from] value should be less than or equal to `this` value. * If the [from] value is greater than `this` value the returned progression is empty. */ fun Byte . upTo ( from : Int ) : IntProgression byte = if ( from <= this ) new IntProgression ( this, from ) else new IntProgression ( this, from + 1 ) /** * Returns a progression from this value up to the specified [from] value with the step 1. * * The [from] value should be greater than or equal to `this` value
= if ( to <= this ) new IntProgression ( this, to ) else new IntProgression ( this, to - 1 ) /** * Returns a progression from this value up to the specified [from] value with the step 1. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [from] value should be less than or equal to `this` value. * If the [from] value is greater than `this` value the returned progression is empty. */ fun Short . upTo ( from : Int ) : IntProgression Short = if ( from <= this ) new IntProgression ( this, from ) else new IntProgression ( this, from + 1 ) /** * Returns a progression from this value up to the specified [from] value with the step 1. * * The [from] value should be greater than or equal to `this` value
= { if ( to <= this ) return new LongProgression ( this, to ) else return new LongProgression ( this, to - 1 ) } /** * Returns a progression from this value up to the specified [from] value with the step 1. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [from] value should be less than or equal to `this` value. * If the [from] value is greater than `this` value the returned progression is empty. */ fun LongProgression . upTo ( from : Long ) : LongProgression = { if ( from <= this ) return new LongProgression ( this, from ) else return new LongProgression ( this, from + 1 ) } /** * Returns a progression from this value up to the specified [from] value with the step 1. * * The [from] value should be greater than or equal to `this`
= if ( to <= this ) LongProgression () else LongProgression ( to - 1, this - 1 ) /** * Returns a progression from this value up to the specified [from] value with the step +1. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [from] value should be less than or equal to `this` value. * If the [from] value is greater than `this` value the returned progression is empty. */ LongProgression . upTo ( from : Long ) : LongProgression = if ( from <= this ) LongProgression () else LongProgression ( from + 1, this - 1 ) /** * Returns a progression from this value up to the specified [from] value with the step +1. * * The [from] value should be greater than or equal to `this` value. * If the [
= { if ( to <= this ) return new LongProgression ( this, to ) else return new LongProgression ( this, to - 1 ) } /** * Returns a progression from this value up to the specified [from] value with the step 1. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [from] value should be greater than or equal to `thi
= if ( to <= this ) then this else if ( to < this ) then this - 1 else if ( to < 0 ) then 0 else if ( to == 0 ) then 0 else if ( to == 1 ) then 1 else if ( to == 2 ) then 2 else if ( to == 3 ) then 3 else if ( to == 4 ) then 4 else if ( to == 5 ) then 5 else if ( to == 6 ) then 6 else if ( to == 7 ) then 7 else if ( to == 8 ) then 8 else if ( to == 9 ) then 9 else if ( to == 10 ) then 10 else if ( to == 11 ) then 11 else if ( to == 12 ) then 12 else if ( to == 13 ) then
= if ( to <= this ) IntProgression () else IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: IntProgression downTo ( to - 1 ) :: Int
= if ( to <= this ) then this else downTo ( to - 1 ) /** * Returns a progression from this value up to the specified [from] value with the step +1. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than `this` value the returned progression is empty. * * The [from] value should be greater than or equal to `this` value. * If the [from] value is less than
= { if ( to <= this ) return IntProgression ( this, to ) else return IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( IntProgression ( Int
= if ( to <= this ) IntProgression () else IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 ) ) :: IntProgression ( downTo ( to - 1 )
{ return IntProgression(this.length - 1, 0) } /** * Returns a progression that goes over the same range in the same direction with the same step. */ fun IntProgression . forward ( ) : IntProgression { return IntProgression(0, this.length - 1) } /** * Returns a progression that goes over the same range in the opposite direction with the same step. */ fun IntProgression . backward ( ) : IntProgression { return IntProgression(this.length - 1, 0) } /** * Returns a progression that goes over the same range in the same direction with the same step. */ fun IntProgression . forwardAndBackward ( ) : IntProgression { return IntProgression(0, this.length - 1) } /** * Returns a progression that goes over the same range in the opposite direction with the same step. */ fun IntProgression . backwardAndForward ( ) : IntProgression { return IntProgression(this.length - 1, 0) } /** * Returns a progression that
{ return LongProgression(this.length - 1, this.start, this.step) } /** * Returns a progression that goes over the same range in the same direction with the same step. */ fun LongProgression . forward ( ) : LongProgression { return LongProgression(0, this.start, this.step) } /** * Returns a progression that goes over the same range in the opposite direction with the same step. */ fun LongProgression . reversed ( ) : LongProgression { return LongProgression(this.length - 1, this.start, this.step) } /** * Returns a progression that goes over the same range in the same direction with the same step. */ fun LongProgression . forward ( ) : LongProgression { return LongProgression(0, this.start, this.step) } /** * Returns a progression that goes over the same range in the opposite direction with the same step. */ fun LongProgression . reversed ( ) : LongProgression { return LongProgression(this.length - 1, this.
{ return CharProgression(this.length - 1, this.start, this.step) } /** * Returns a progression that goes over the same range in the same direction with the same step. */ charProgression public fun CharProgression ( start : Int, step : Int ) : CharProgression { return CharProgression(start, start + step, step) } /** * Returns a progression that goes over the same range in the opposite direction with the same step. */ charProgression public fun CharProgression ( start : Int, step : Int ) : CharProgression { return CharProgression(start, start - step, step) } /** * Returns a progression that goes over the same range in the same direction with the same step. */ charProgression public fun CharProgression ( start : Int, step : Int ) : CharProgression { return CharProgression(start, start, step) } /** * Returns a progression that goes over the same range in the opposite direction with the same step. */ charProgression public fun CharProgression ( start : Int, step : Int )
{ return IntProgression ( step ) } /** * Returns a progression that goes over the same range with the given step. * * @sample samples.ranges.Ranges.stepFloat */ floatProgression . step ( step : Float ) : FloatProgression step { return FloatProgression ( step ) } /** * Returns a progression that goes over the same range with the given step. * * @sample samples.ranges.Ranges.stepDouble */ doubleProgression . step ( step : Double ) : DoubleProgression step { return DoubleProgression ( step ) } /** * Returns a progression that goes over the same range with the given step. * * @sample samples.ranges.Ranges.stepLong */ longProgression . step ( step : Long ) : LongProgression step { return LongProgression ( step ) } /** * Returns a progression that goes over the same range with the given step. * * @sample samples.ranges.Ranges.stepBoolean */ booleanProgression . step ( step : Boolean )
: LongProgression { if ( step < 0 ) throw new IllegalArgumentException () if ( step == 0 ) throw new IllegalArgumentException () if ( step == 1 ) throw new IllegalArgumentException () if ( step == 2 ) throw new IllegalArgumentException () if ( step == 3 ) throw new IllegalArgumentException () if ( step == 4 ) throw new IllegalArgumentException () if ( step == 5 ) throw new IllegalArgumentException () if ( step == 6 ) throw new IllegalArgumentException () if ( step == 7 ) throw new IllegalArgumentException () if ( step == 8 ) throw new IllegalArgumentException () if ( step == 9 ) throw new IllegalArgumentException () if ( step == 10 ) throw new IllegalArgumentException () if ( step == 11 ) throw new IllegalArgumentException () if ( step == 12 ) throw new IllegalArgumentException () if ( step == 13 ) throw new IllegalArgumentException () if ( step == 14 ) throw new IllegalArgumentException () if ( step == 15 ) throw new Illegal
= if ( step < 0 ) throw new IllegalArgumentException () else if ( step == 0 ) throw new IllegalArgumentException () else if ( step == 1 ) throw new IllegalArgumentException () else if ( step == 2 ) throw new IllegalArgumentException () else if ( step == 3 ) throw new IllegalArgumentException () else if ( step == 4 ) throw new IllegalArgumentException () else if ( step == 5 ) throw new IllegalArgumentException () else if ( step == 6 ) throw new IllegalArgumentException () else if ( step == 7 ) throw new IllegalArgumentException () else if ( step == 8 ) throw new IllegalArgumentException () else if ( step == 9 ) throw new IllegalArgumentException () else if ( step == 10 ) throw new IllegalArgumentException () else if ( step == 11 ) throw new IllegalArgumentException () else if ( step == 12 ) throw new IllegalArgumentException () else if ( step == 13 ) throw new IllegalArgumentException () else if ( step == 14 ) throw new IllegalArgumentException
{ if ( to <= this ) { return IntRange( 0, this ) } else { return IntRange( this, to ) } } /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is greater than `this` value, then the returned range is infinite. * * If the [to] value is greater than `this` value, then the returned range is infinite. * * If the [to] value is greater than `this` value, then the returned range is infinite. * * If the [to] value is greater than `this` value, then the returned range is infinite. * * If the [to] value is greater than `this` value, then the returned range is infinite. * * If the [to] value is greater than `this` value, then the returned range is infinite. * * If the [to
* * @param to * @return a range from this value up to but excluding the specified [to] value. */ public infix fun Long . until ( to : Byte ) : LongRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * @param to * @return a range from this value up to but excluding the specified [to] value. */ public infix fun Long . until ( to : Byte ) : LongRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * @param to * @return a range from this value up to but excluding the specified [to] value. */ public infix fun Long . until ( to : Byte ) : LongRange /** * Returns a range from this value up to but excluding the
{ if ( to <= this ) { return IntRange( 0, this ) } else { return IntRange( this, to ) } } /** * Returns a range from this value up to but excluding the specified [from] value. * * If the [from] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [from] value is greater than or equal to `this` value, then the returned range is [from, to). * * If the [to] value is greater than or equal to `this` value, then the returned range is [from, to). * * If the [from] value is greater than or equal to `this` value, then the returned range is [from, to). * * If the [to] value is greater than or equal to `this` value, then the returned range is [from, to). * * If the [
{ if ( to <= this ) { return IntRange( 0, this ) } else { return IntRange( this, to ) } } /** * Returns a range from this value up to but excluding the specified [from] value. * * If the [from] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [from] value is greater than or equal to `this` value, then the returned range is inclusive. * * If the [to] value is greater than or equal to `this` value, then the returned range is exclusive. * * If the [from] value is less than `this` value, then the returned range is inclusive. * * If the [to] value is less than `this` value, then the returned range is exclusive. * * If the [from] value is greater than `this` value, then the returned range is inclusive.
{ if ( to <= this ) { return CharRange.empty } else { return CharRange( this, to ) } } /** * Returns a range from this value up to but excluding the specified [from] value. * * If the [from] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [from] value is greater than `this` value, then the returned range is [from, this]. * * If the [to] value is greater than `this` value, then the returned range is [this, to]. */ char . until ( from : Char ) : CharRange char { if ( from <= this ) { return CharRange.empty } else { return CharRange( this, from ) } } /** * Returns a range from this value up to but excluding the specified [from] value. * * If the [
{ if ( to <= this ) { return IntRange( 0, this ) } else { return IntRange( this, to ) } } /** * Returns a range from this value up to but excluding the specified [from] value. * * If the [from] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [from] value is greater than or equal to `this` value, then the returned range is empty. * * If the [to] value is greater than or equal to `this` value, then the returned range is empty. * * If the [from] value is greater than or equal to `this` value, then the returned range is empty. * * If the [to] value is greater than or equal to `this` value, then the returned range is empty. * * If the [from] value is greater than or equal to `this`
* @param to * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun Long . until ( to : Int ) : LongRange * @param to * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun LongRange . until ( to : Int ) : LongRange * @param to * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun LongRange . until ( to : Int ) : LongRange * @param to * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is le
{ if ( to <= this ) { return IntRange( 0, this ) } else { return IntRange( this, to ) } } /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this`
{ if ( to <= this ) { return IntRange( 0, this ) } else { return IntRange( this, to ) } } /** * Returns a range from this value up to but excluding the specified [from] value. * * If the [from] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [from] value is greater than or equal to `this` value, then the returned range is empty. * * If the [to] value is greater than or equal to `this` value, then the returned range is empty. * * Returns a range from this value up to but excluding the specified [from] value. * * If the [from] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range i
* * @param to * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun Int . until ( to : Long ) : LongRange * * @param to * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun Int . until ( to : Long ) : LongRange * * @param to * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun Int . until ( to : Long ) : LongRange * * @param to * @return a range from this value up to but excluding the specified [to] value. *
* * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun LongRange . until ( to : Long ) : LongRange * * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun LongRange . until ( to : LongRange ) : LongRange * * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun LongRange . until ( to : LongRange ) : LongRange * * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `
* @param to * @return a range from this value up to but excluding the specified [to] value. */ public infix fun Byte . until ( to : Long ) : LongRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun Byte . until ( to : Byte ) : ByteRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun Byte . until ( to : Byte ) : ByteRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun Byte . until ( to : Byte ) : ByteRange /** * Return
* * @param to * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun Short . until ( to : Long ) : LongRange * * @param to * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun Long . until ( to : Long ) : LongRange * * @param to * @return a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun Long . until ( to : Long ) : LongRange * * @param to * @return a range from this value up to but excluding the specified [to] value. *
{ if ( to <= this ) { return IntRange( 0, this ) } else { return IntRange( this, to ) } } /** * Returns a range from this value up to but excluding the specified [from] value. * * If the [from] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [from] value is greater than or equal to `this` value, then the returned range is empty. * * If the [to] value is greater than or equal to `this` value, then the returned range is empty. * * If the [from] value is greater than or equal to `this` value, then the returned range is empty. * * If the [to] value is greater than or equal to `this` value, then the returned range is empty. * * If the [from] value is greater than or equal to `this`
* @param to * @return a range from this value up to but excluding the specified [to] value. */ public infix fun Long . until ( to : Short ) : LongRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun Long . until ( to : Short ) : LongRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun Long . until ( to : Short ) : LongRange /** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */ public infix fun Long . until ( to : Short ) : LongRange /** * Return
{ if ( to <= this ) { return IntRange( 0, this ) } else { return IntRange( this, to ) } } /** * Returns a range from this value up to but excluding the specified [from] value. * * If the [from] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [from] value is greater than or equal to `this` value, then the returned range is empty. * * If the [to] value is greater than or equal to `this` value, then the returned range is empty. * * If the [from] value is greater than or equal to `this` value, then the returned range is empty. * * If the [to] value is greater than or equal to `this` value, then the returned range is empty. * * If the [from] value is greater than or equal to `this`
{ if ( to <= this ) { return IntRange( 0, this ) } else { return IntRange( this, to ) } } /** * Returns a range from this value up to but excluding the specified [from] value. * * If the [from] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. * * If the [from] value is greater than or equal to `this` value, then the returned range is empty. * * If the [to] value is greater than or equal to `this` value, then the returned range is empty. * * Returns a range from this value up to but excluding the specified [from] value. * * If the [from] value is less than or equal to `this` value, then the returned range is empty. * * If the [to] value is less than or equal to `this` value, then the returned range i

{ if ( this < minimumValue ) { return minimumValue } else { return this } } /** * Ensures that this value is not greater than the specified [maximumValue]. * * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ /** * Ensures that this value is not greater than the specified [maximumValue]. * * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ /** * Ensures that this value is not less than the specified [minimumValue]. * * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ /**
her : Short { if ( this < minimumValue ) { return minimumValue } else { return this } } /** * Ensures that this value is not greater than the specified [maximumValue]. * * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ /** * Ensures that this value is not less than the specified [minimumValue]. * * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ /** * Ensures that this value is not greater than the specified [maximumValue]. * * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */
{ if ( this < minimumValue ) { return minimumValue } else { return this } } /** * Ensures that this value is not greater than the specified [maximumValue]. * * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ /** * Ensures that this value is not greater than the specified [maximumValue]. * * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ /** * Ensures that this value is not less than the specified [minimumValue]. * * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ /**
{ if ( this < minimumValue ) { return minimumValue; } else { return this; } } /** * Ensures that this value is not greater than the specified [maximumValue]. * * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ fun Long . coerceAtMost ( maximumValue : Long ) : Long { if ( this > maximumValue ) { return maximumValue; } else { return this; } } /** * Ensures that this value is not less than the specified [minimumValue]. * * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtEqual */ fun Long . coerceAtEqual ( minimumValue : Long ) : Long { if ( thi
t { if ( this < minimumValue ) { return minimumValue } else { return this } } /** * Ensures that this value is not greater than the specified [maximumValue]. * * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ /** * Ensures that this value is not greater than the specified [maximumValue]. * * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ /** * Ensures that this value is not less than the specified [minimumValue]. * * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ /**
t { if ( this < minimumValue ) { return minimumValue } else { return this } } /** * Ensures that this value is not greater than the specified [maximumValue]. * * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ public fun Double . coerceAtMost ( maximumValue : Double ) : Double ? : Double { if ( this > maximumValue ) { return maximumValue } else { return this } } /** * Ensures that this value is not less than the specified [minimumValue]. * * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtEqual */ public fun Double . coerceAtEqual ( minimumValue : Double ) : Double ? : Double { if (
{ if ( this > maximumValue ) return maximumValue return this } /** * Ensures that this value is not less than the specified [minimumValue]. * * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtLeastComparable */ fun < T : Comparable < T > > T . coerceAtLeast ( minimumValue : T ) : T in { if ( this < minimumValue ) return minimumValue return this } /** * Ensures that this value is not greater than the specified [maximumValue]. * * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMostComparable */ fun < T : Comparable < T > > T . coerceAtMost ( maximumValue : T ) : T in { if ( this > maximumValue ) return maximum
otal : Byte { if ( this > maximumValue ) this = maximumValue return this } /** * Ensures that this value is not less than the specified [minimumValue]. * * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtLeast */ bytepublic fun Byte . coerceAtLeast ( minimumValue : Byte ) : Byte { if ( this < minimumValue ) this = minimumValue return this } /** * Ensures that this value is not greater than the specified [maximumValue]. * * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ bytepublic fun Byte . coerceAtMost ( maximumValue : Byte ) : Byte { if ( this > maximumValue ) this = maximumValue return this } /** * Ensures that thi
hen : Short { if ( this > maximumValue ) return maximumValue return this } /** * Ensures that this value is not less than the specified [minimumValue]. * * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtLeast */ fun Short . coerceAtLeast ( minimumValue : Short ) : Short atLeast : Short { if ( this < minimumValue ) return minimumValue return this } /** * Ensures that this value is not greater than the specified [maximumValue]. * * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ fun Short . coerceAtMost ( maximumValue : Short ) : Short atMost : Short { if ( this > maximumValue ) return maximumValue return this } /** *
{ if ( this > maximumValue ) return maximumValue return this } /** * Ensures that this value is not less than the specified [minimumValue]. * * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtLeast */ fun Int . coerceAtLeast ( minimumValue : Int ) : Int ik { if ( this < minimumValue ) return minimumValue return this } /** * Ensures that this value is not greater than the specified [maximumValue]. * * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ fun Int . coerceAtMost ( maximumValue : Int ) : Int ik { if ( this > maximumValue ) return maximumValue return this } /** * Ensures that this value is not le
{ if ( this > maximumValue ) return maximumValue return this } /** * Ensures that this value is not less than the specified [minimumValue]. * * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtLeast */ public fun Long . coerceAtLeast ( minimumValue : Long ) : Long { if ( this < minimumValue ) return minimumValue return this } /** * Ensures that this value is not greater than the specified [maximumValue]. * * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ public fun Long . coerceAtMost ( maximumValue : Long ) : Long { if ( this > maximumValue ) return maximumValue return this } /** * Ensures that this value i
t { if ( this > maximumValue ) this = maximumValue return this } /** * Ensures that this value is not less than the specified [minimumValue]. * * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtLeast */ floatpublic fun Float . coerceAtLeast ( minimumValue : Float ) : Float if ( this < minimumValue ) this = minimumValue return this } /** * Ensures that this value is not greater than the specified [maximumValue]. * * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ floatpublic fun Float . coerceAtMost ( maximumValue : Float ) : Float if ( this > maximumValue ) this = maximumValue return this } /** * Ensures that this value i
t { if ( this > maximumValue ) return maximumValue return this } /** * Ensures that this value is not less than the specified [minimumValue]. * * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtLeast */ fun Double . coerceAtLeast ( minimumValue : Double ) : Double = if ( this < minimumValue ) minimumValue else this } /** * Ensures that this value is not greater than the specified [maximumValue]. * * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise. * * @sample samples.comparisons.ComparableOps.coerceAtMost */ fun Double . coerceAtMost ( maximumValue : Double ) : Double = if ( this > maximumValue ) maximumValue else this } /** * Ensures that this value is not less than the specified











{ return deserializer.deserialize(config) } /** * Decodes the given [config] into a value of type [T] using the given serializer. * * @param deserializer : DeserializationStrategy < T > * @param config : Config * @return T */ fun < T > decodeFromConfig ( deserializer : DeserializationStrategy < T > , config : Config ) : T { return deserializer.deserialize(config) } /** * Decodes the given [config] into a value of type [T] using the given serializer. * * @param deserializer : DeserializationStrategy < T > * @param config : Config * @return T */ fun < T > decodeFromConfig ( deserializer : DeserializationStrategy < T > , config : Config ) : T { return deserializer.deserialize(config) } /** * Decodes the given [config] into a value of type [T] using the given serializer. * * @param deserializer :
{ if ( isPrimitiveType ( value ) ) throw new SerializationException ( "Cannot serialize primitive type" ); if ( isListType ( value ) ) throw new SerializationException ( "Cannot serialize list type" ); Config config = new Config (); config.value = value; config.serializer = serializer; return config; } /** * Decodes the given [Config] into a [value] using the given [deserializer]. * @throws SerializationException If list or primitive type passed as a [value]. */ /** * Decodes the given [Config] into a [value] using the given [deserializer]. * @throws SerializationException If list or primitive type passed as a [value]. */ /** * Decodes the given [Config] into a [value] using the given [deserializer]. * @throws SerializationException If list or primitive type passed as a [value]. */ /** * Decodes the given [Config] into a [value] using the given [deserializer]. * @throws SerializationException If
{ } /** * Decodes the given [config] into a value of type [T] using a deserializer retrieved * from the reified type parameter. */ fun < reified T > Hocon . decodeFromConfig ( config : Config ) : T { } /** * Decodes the given [config] into a value of type [T] using a deserializer retrieved * from the reified type parameter. */ fun < reified T > Hocon . decodeFromConfig ( config : Config ) : T { } /** * Decodes the given [config] into a value of type [T] using a deserializer retrieved * from the reified type parameter. */ fun < reified T > Hocon . decodeFromConfig ( config : Config ) : T { } /** * Decodes the given [config] into a value of type [T] using a deserializer retrieved * from the reified type parameter. */ fun < reified T > Hocon . decodeFromConfig ( config : Config ) : T { } /** * Decodes the
{ if ( value == null ) { return null; } if ( value.isNull() ) { return null; } if ( value.isBlank() ) { return null; } if ( value.isBoolean() ) { return null; } if ( value.isByte() ) { return null; } if ( value.isByteArray() ) { return null; } if ( value.isDouble() ) { return null; } if ( value.isDoubleArray() ) { return null; } if ( value.isFloat() ) { return null; } if ( value.isFloatArray() ) { return null; } if ( value.isInt() ) { return null; } if ( value.isIntArray() ) { return null; } if ( value.isLong() ) { return null; } if (
= Hocon( from = from , builderAction = builderAction ) * * @param from * @param builderAction * * @return */ fun Hocon ( from : Hocon = Hocon(), builderAction : HoconBuilder ) : Hocon = Hocon( from = from , builderAction = builderAction ) /** * Creates an instance of [Hocon] configured from the optionally given [Hocon instance][from] * and adjusted with [builderAction]. * * @param from * @param builderAction * * @return */ fun Hocon ( from : Hocon = Hocon(), builderAction : HoconBuilder ) : Hocon = Hocon( from = from , builderAction = builderAction ) /** * Creates an instance of [Hocon] configured from the optionally given [Hocon instance][from] * and adjusted with [builderAction]. * * @param from * @param builderAction * * @return */ fun Hocon ( from : Hocon = Hocon(), builderAction : HoconBuilder ) : Hocon = Hocon( from = from , builderAction = builder






{ return this.toString() } /** @suppress for nicer debugging */ double toDouble ( ) : Double? { return this.toDouble() } /** @suppress for nicer debugging */ int toInt ( ) : Int? { return this.toInt() } /** @suppress for nicer debugging */ float toFloat ( ) : Float? { return this.toFloat() } /** @suppress for nicer debugging */ boolean toBoolean ( ) : Boolean? { return this.toBoolean() } /** @suppress for nicer debugging */ byte toByte ( ) : Byte? { return this.toByte() } /** @suppress for nicer debugging */ short toShort ( ) : Short? { return this.toShort() } /** @suppress for nicer debugging */ int toInt ( ) : Int? { return this.toInt() } /** @suppress for nicer debugging */ float toFloat ( ) : Float? { return this.toFloat() } /** @suppress for nicer debugging */ double



{ if ( x == Double.NaN || x == Double.POSITIVE_INFINITY || x == Double.NEGATIVE_INFINITY ) return Double.NaN if ( x == Double.POSITIVE_INFINITY || x == Double.NEGATIVE_INFINITY ) return Double.POSITIVE_INFINITY if ( x == Double.NEGATIVE_INFINITY ) return Double.NEGATIVE_INFINITY if ( x == Double.POSITIVE_INFINITY ) return Double.POSITIVE_INFINITY if ( x == 0.0 ) return 0.0 if ( x == 1.0 ) return 1.0 if ( x == -1.0 ) return -1.0 if ( x == -2.0 ) return -2.0 if ( x == -3.0 ) return -3.0 if ( x == -4.0 ) return -4.0 if ( x == -5.0 ) return -5.0 if ( x == -6.0 ) return -6.0
{ if ( x == Double.NaN || x == Double.POSITIVE_INFINITY || x == Double.NEGATIVE_INFINITY ) { return Double.NaN } if ( x == Double.POSITIVE_INFINITY || x == Double.NEGATIVE_INFINITY ) { return Double.POSITIVE_INFINITY } if ( x == Double.NEGATIVE_INFINITY ) { return Double.NEGATIVE_INFINITY } if ( x == Double.POSITIVE_INFINITY ) { return Double.POSITIVE_INFINITY } if ( x < 0 ) { return Double.NEGATIVE_INFINITY } if ( x > 0 ) { return Double.POSITIVE_INFINITY } return Math.cos ( x ) } /** Computes the sine of the angle [x] given in radians. * * Special cases: * - `sin(NaN|+Inf|-Inf)`
ard fun tan ( x : Double ) : Double { if ( x == Double.POSITIVE_INFINITY ) return Double.POSITIVE_INFINITY if ( x == Double.NEGATIVE_INFINITY ) return Double.NEGATIVE_INFINITY if ( x == Double.POSITIVE_INFINITY || x == Double.NEGATIVE_INFINITY ) return Double.POSITIVE_INFINITY if ( x == Double.NEGATIVE_INFINITY ) return Double.NEGATIVE_INFINITY if ( x == Double.POSITIVE_INFINITY || x == Double.NEGATIVE_INFINITY ) return Double.NEGATIVE_INFINITY if ( x == Double.NEGATIVE_INFINITY ) return Double.POSITIVE_INFINITY if ( x == Double.NEGATIVE_INFINITY ) return Double.NEGATIVE_INFINITY if ( x == Double.POSITIVE_INFINITY || x == Double.NEGATIVE_INFINITY ) return Double.NEGATIVE_INFIN










{ if ( x == Double.POSITIVE_INFINITY || y == Double.POSITIVE_INFINITY ) { return Double.POSITIVE_INFINITY } if ( x == Double.NEGATIVE_INFINITY || y == Double.NEGATIVE_INFINITY ) { return Double.NEGATIVE_INFINITY } if ( x == Double.POSITIVE_INFINITY || y == Double.NEGATIVE_INFINITY ) { return Double.POSITIVE_INFINITY } if ( x == Double.NEGATIVE_INFINITY || y == Double.POSITIVE_INFINITY ) { return Double.NEGATIVE_INFINITY } if ( x == Double.POSITIVE_INFINITY || y == Double.NEGATIVE_INFINITY ) { return Double.POSITIVE_INFINITY } if ( x == Double.NEGATIVE_INFINITY || y == Double.NEGATIVE_INFINITY ) { return Double.N
{ if ( x < 0 ) return NaN if ( x == 0 ) return 0.0 if ( x == 1 ) return 1.0 if ( x == 2 ) return 2.0 if ( x == 3 ) return 3.0 if ( x == 4 ) return 4.0 if ( x == 5 ) return 5.0 if ( x == 6 ) return 6.0 if ( x == 7 ) return 7.0 if ( x == 8 ) return 8.0 if ( x == 9 ) return 9.0 if ( x == 10 ) return 10.0 if ( x == 11 ) return 11.0 if ( x == 12 ) return 12.0 if ( x == 13 ) return 13.0 if ( x == 14 ) return 14.0 if ( x == 15 ) return 15.0 if ( x == 16 ) return 16.0 if ( x == 17 ) return 17.0 if ( x == 18 ) return 18.0 if ( x == 19 ) return 19.0 if (
{ if ( x == Double.POSITIVE_INFINITY ) return Double.POSITIVE_INFINITY if ( x == Double.NEGATIVE_INFINITY ) return Double.NEGATIVE_INFINITY if ( x == Double.POSITIVE_INFINITY ) return Double.POSITIVE_INFINITY if ( x == Double.NEGATIVE_INFINITY ) return Double.NEGATIVE_INFINITY if ( x == Double.NAN ) return Double.NAN if ( x == Double.POSITIVE_INFINITY ) return Double.POSITIVE_INFINITY if ( x == Double.NEGATIVE_INFINITY ) return Double.NEGATIVE_INFINITY if ( x == Double.NAN ) return Double.NAN if ( x == Double.POSITIVE_INFINITY ) return Double.POSITIVE_INFINITY if ( x == Double.NEGATIVE_INFINITY ) return Double.NEGATIVE_INFINITY if ( x == Double.NAN ) return Double.N



{ if ( x == 0.0 ) return 0.0 if ( x == 1.0 ) return 1.0 if ( x == 2.0 ) return 2.0 if ( x == 3.0 ) return 3.0 if ( x == 4.0 ) return 4.0 if ( x == 5.0 ) return 5.0 if ( x == 6.0 ) return 6.0 if ( x == 7.0 ) return 7.0 if ( x == 8.0 ) return 8.0 if ( x == 9.0 ) return 9.0 if ( x == 10.0 ) return 10.0 if ( x == 11.0 ) return 11.0 if ( x == 12.0 ) return 12.0 if ( x == 13.0 ) return 13.0 if ( x == 14.0 ) return 14.0 if ( x == 15.0 ) return 15.0 if ( x == 16.0 ) return 16.0 if ( x == 17.0 ) return 17.0 if
{ if ( x == 0 ) return Double.POSITIVE_INFINITY if ( x < 0 ) return Double.NEGATIVE_INFINITY if ( x == Double.POSITIVE_INFINITY ) return Double.POSITIVE_INFINITY if ( x == Double.NEGATIVE_INFINITY ) return Double.NEGATIVE_INFINITY if ( x == Double.NaN ) return Double.POSITIVE_INFINITY if ( x == Double.Infinity ) return Double.POSITIVE_INFINITY if ( x == Double.NegativeInfinity ) return Double.NEGATIVE_INFINITY if ( x == Double.Epsilon ) return Double.POSITIVE_INFINITY if ( x == Double.MinValue ) return Double.NEGATIVE_INFINITY if ( x == Double.MaxValue ) return Double.POSITIVE_INFINITY if ( x == 0.0 ) return Double.POSITIVE_INFINITY if ( x == 1.0 ) return Double.NEGATIVE_IN




{ if ( x == Double.NaN || x == Double.POSITIVE_INFINITY || x == Double.NEGATIVE_INFINITY ) { return x } if ( x == Double.POSITIVE_INFINITY || x == Double.NEGATIVE_INFINITY ) { return Double.POSITIVE_INFINITY } if ( x == Double.NEGATIVE_INFINITY ) { return Double.NEGATIVE_INFINITY } if ( x == Double.POSITIVE_INFINITY ) { return Double.POSITIVE_INFINITY } if ( x < 0 ) { return Double.NEGATIVE_INFINITY } if ( x > 0 ) { return Double.POSITIVE_INFINITY } if ( x == 0 ) { return 0 } if ( x == 1 ) { return 1 } if ( x == 2 ) { return 2 } if ( x == 3 )
{ if ( x == Double.NaN ) return Double.NaN if ( x == Double.POSITIVE_INFINITY ) return Double.POSITIVE_INFINITY if ( x == Double.NEGATIVE_INFINITY ) return Double.NEGATIVE_INFINITY if ( x == Double.POSITIVE_INFINITY ) return Double.POSITIVE_INFINITY if ( x == Double.NEGATIVE_INFINITY ) return Double.NEGATIVE_INFINITY return Math.abs ( x ) } /** * Returns the absolute value of the given value [x]. * * Special cases: * - `abs(NaN)` is `NaN` * * @see absoluteValue extension property for [Float] */ float@ SinceKotlin ( " fla" ) fla public expect fun abs ( x : Float ) : Float { if ( x == Float.NaN ) return Float.NaN if ( x == Float.POSITIVE_INFINITY ) return Float.POSITIVE_INFINITY
{ if ( x < 0.0 ) return -1.0 if ( x == 0.0 ) return 0.0 if ( x > 0.0 ) return 1.0 return 0.0 } /** * Returns the sign of the given value [x]: * - `-1.0` if the value is negative, * - zero if the value is zero, * - `1.0` if the value is positive * * Special case: * - `sign(NaN)` is `NaN` */ fun sign ( x : Double ) : Double { if ( x < 0.0 ) return -1.0 if ( x == 0.0 ) return 0.0 if ( x > 0.0 ) return 1.0 return 0.0 } /** * Returns the sign of the given value [x]: * - `-1.0` if the value is negative, * - zero if the value is zero, * - `1.0` if the value is positive * * Special case: * - `sign
{ if ( a == null ) return b if ( b == null ) return a return a < b ? a : b } /** * Returns the larger of two values. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN
{ if ( a == b ) return a if ( a == null ) return b if ( b == null ) return a if ( a.isNaN() || b.isNaN() ) return a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b : a.isNaN() ? b


{ if ( n == 0 ) return 1.0 if ( n == 1 ) return this if ( n == 2 ) return this * this if ( n == 3 ) return this * this * this if ( n == 4 ) return this * this * this * this if ( n == 5 ) return this * this * this * this * this if ( n == 6 ) return this * this * this * this * this * this if ( n == 7 ) return this * this * this * this * this * this * this if ( n == 8 ) return this * this * this * this * this * this * this * this if ( n == 9 ) return this * this * this * this * this * this * this * this * this if ( n == 10 ) return this * this * this * this * this * this * this * this * this * this if ( n == 11 ) return this * this * this * this * this * this * this * this * this * this * this if ( n == 12 ) return this * this * this * this * this * this * this *
{ if ( sign == Double.NaN ) return Double.NaN if ( sign == Double.POSITIVE_INFINITY ) return Double.POSITIVE_INFINITY if ( sign == Double.NEGATIVE_INFINITY ) return Double.NEGATIVE_INFINITY if ( sign == Double.POSITIVE_INFINITY ) return Double.POSITIVE_INFINITY if ( sign == Double.NEGATIVE_INFINITY ) return Double.NEGATIVE_INFINITY if ( sign == Double.POSITIVE_INFINITY ) return Double.POSITIVE_INFINITY if ( sign == Double.NEGATIVE_INFINITY ) return Double.NEGATIVE_INFINITY if ( sign == Double.POSITIVE_INFINITY ) return Double.POSITIVE_INFINITY if ( sign == Double.NEGATIVE_INFINITY ) return Double.NEGATIVE_INFINITY if ( sign == Double.POSITIVE_INFINITY ) return Double.POSITIVE_INFINITY if ( sign
{ if ( sign == 0 ) return 0.0 if ( sign == 1 ) return 1.0 if ( sign == -1 ) return -1.0 if ( sign == -2 ) return -2.0 if ( sign == -3 ) return -3.0 if ( sign == -4 ) return -4.0 if ( sign == -5 ) return -5.0 if ( sign == -6 ) return -6.0 if ( sign == -7 ) return -7.0 if ( sign == -8 ) return -8.0 if ( sign == -9 ) return -9.0 if ( sign == -10 ) return -10.0 if ( sign == -11 ) return -11.0 if ( sign == -12 ) return -12.0 if ( sign == -13 ) return -13.0 if ( sign == -14 ) return -14.0 if ( sign == -15 ) return -15.0 if ( sign == -16 ) return -16.0 if ( sign == -
{ if ( this < 0 ) { throw new IllegalArgumentException () } if ( this > Double.POSITIVE_INFINITY ) { throw new IllegalArgumentException () } if ( this == Double.POSITIVE_INFINITY ) { return Double.POSITIVE_INFINITY } if ( this == Double.NEGATIVE_INFINITY ) { return Double.NEGATIVE_INFINITY } if ( this < Double.NEGATIVE_INFINITY ) { return Double.NEGATIVE_INFINITY } if ( this > Double.POSITIVE_INFINITY ) { return Double.POSITIVE_INFINITY } if ( this == Double.POSITIVE_INFINITY ) { return Double.POSITIVE_INFINITY } if ( this < Double.NEGATIVE_INFINITY ) { return Double.NEGATIVE_INFINITY } if ( this > Double.POSITIVE_IN
{ if ( this < 0 ) { return Double.MIN_VALUE } else { return Double.MAX_VALUE } } /** * Returns the [Double] value nearest to this value in direction of positive infinity. */ kotlin@ SinceKotlin ( " kotlin" ) kotlin public expect fun Double . nextUp ( ) : Double kotlin { if ( this > 0 ) { return Double.MAX_VALUE } else { return Double.MIN_VALUE } } /** * Returns the [Double] value nearest to this value in direction of negative infinity. */ kotlin@ SinceKotlin ( " kotlin" ) kotlin public expect fun Double . nextDown ( ) : Double kotlin { if ( this < 0 ) { return Double.MAX_VALUE } else { return Double.MIN_VALUE } } /** * Returns the [Double] value nearest to this value in direction of positive infinity. */ kotlin@ SinceKotlin ( " kotlin



fun sin ( x : Float ) : Float { if ( x == Float.NAN || x == Float.POSITIVE_INFINITY || x == Float.NEGATIVE_INFINITY ) return Float.NAN if ( x == Float.NEGATIVE_INFINITY ) return Float.NEGATIVE_INFINITY if ( x == Float.POSITIVE_INFINITY ) return Float.POSITIVE_INFINITY if ( x == Float.NEGATIVE_INFINITY ) return Float.NEGATIVE_INFINITY return Math.sin ( x ) } fun cos ( x : Float ) : Float { if ( x == Float.NAN || x == Float.POSITIVE_INFINITY || x == Float.NEGATIVE_INFINITY ) return Float.NAN if ( x == Float.NEGATIVE_INFINITY ) return Float.NEGATIVE_INFINITY if ( x == Float.POSITIVE_INFINITY ) return Float.POSITIVE_INFINITY if ( x == Float.NEGATIVE
fun cos ( x : Float ) : Float { if ( x == Float.NAN || x == Float.POSITIVE_INFINITY || x == Float.NEGATIVE_INFINITY ) return Float.NAN if ( x == Float.POSITIVE_INFINITY || x == Float.NEGATIVE_INFINITY ) return Float.POSITIVE_INFINITY if ( x == Float.NEGATIVE_INFINITY ) return Float.NEGATIVE_INFINITY if ( x == Float.NEGATIVE_INFINITY ) return Float.NEGATIVE_INFINITY if ( x == Float.NEGATIVE_INFINITY ) return Float.NEGATIVE_INFINITY if ( x == Float.NEGATIVE_INFINITY ) return Float.NEGATIVE_INFINITY if ( x == Float.NEGATIVE_INFINITY ) return Float.NEGATIVE_INFINITY if ( x == Float.NEGATIVE_INFINITY ) return Float.NEGATIVE_INFINITY if ( x == Float.NEG
fun tan ( x : Float ) : Float { if ( x == Float.NaN || x == Float.Inf || x == Float.NegativeInfinity ) { return Float.NaN } if ( x == Float.PositiveInfinity ) { return Float.PositiveInfinity } if ( x == Float.NegativeInfinity ) { return Float.NegativeInfinity } if ( x < 0 ) { return Float.NegativeInfinity } if ( x > Float.PositiveInfinity ) { return Float.PositiveInfinity } if ( x == Float.Zero ) { return Float.Zero } if ( x == Float.One ) { return Float.One } if ( x == Float.Infinity ) { return Float.Infinity } if ( x == Float.NegativeInfinity ) { return Float.NegativeInfinity } if ( x == Float.NaN ) { return Float.NaN


{ if ( x == Float.NaN ) return Float.NaN if ( x == Float.Infinity ) return Float.NEGATIVE_INFINITY if ( x == Float.NegativeInfinity ) return Float.POSITIVE_INFINITY if ( x < 0 ) return Float.NEGATIVE_INFINITY if ( x > 0 ) return Float.POSITIVE_INFINITY return atan(x) } /** * Computes the inverse tangent of the value [x]; * the returned value is an angle in the range from `-PI/2` to `PI/2` radians. * * Special cases: * - `atan(NaN)` is `NaN` * - `atan(0)` is `0` * - `atan(Infinity)` is `Infinity` * - `atan(NegativeInfinity)` is `-Infinity` */ fun atan2 ( x : Float, y : Float ) : Float { if ( x == Float.NaN ) return Float.NaN













{ if ( x == 0 ) return 0.0f if ( x == 1 ) return 1.0f if ( x == 2 ) return 2.0f if ( x == 3 ) return 3.0f if ( x == 4 ) return 4.0f if ( x == 5 ) return 5.0f if ( x == 6 ) return 6.0f if ( x == 7 ) return 7.0f if ( x == 8 ) return 8.0f if ( x == 9 ) return 9.0f if ( x == 10 ) return 10.0f if ( x == 11 ) return 11.0f if ( x == 12 ) return 12.0f if ( x == 13 ) return 13.0f if ( x == 14 ) return 14.0f if ( x == 15 ) return 15.0f if ( x == 16 ) return 16.0f if ( x == 17 ) return 17.0f if ( x == 18 ) return 18.0f if ( x == 19 )
{ if ( x == 0 ) return 0.0f if ( x == 1 ) return 1.0f if ( x == 2 ) return 2.0f if ( x == 3 ) return 3.0f if ( x == 4 ) return 4.0f if ( x == 5 ) return 5.0f if ( x == 6 ) return 6.0f if ( x == 7 ) return 7.0f if ( x == 8 ) return 8.0f if ( x == 9 ) return 9.0f if ( x == 10 ) return 10.0f if ( x == 11 ) return 11.0f if ( x == 12 ) return 12.0f if ( x == 13 ) return 13.0f if ( x == 14 ) return 14.0f if ( x == 15 ) return 15.0f if ( x == 16 ) return 16.0f if ( x == 17 ) return 17.0f if ( x == 18 ) return 18.0f if ( x == 19 )




{ if ( x == Float.NaN ) return Float.NaN if ( x == Float.Infinity ) return Float.Infinity if ( x == Float.NegativeInfinity ) return Float.NegativeInfinity if ( x == Float.PositiveInfinity ) return Float.PositiveInfinity if ( x == 0.0f ) return 0.0f if ( x == 1.0f ) return 1.0f if ( x == 2.0f ) return 2.0f if ( x == 3.0f ) return 3.0f if ( x == 4.0f ) return 4.0f if ( x == 5.0f ) return 5.0f if ( x == 6.0f ) return 6.0f if ( x == 7.0f ) return 7.0f if ( x == 8.0f ) return 8.0f if ( x == 9.0f ) return 9.0f if ( x == 10.0f ) return 10.0f if ( x == 11
{ if ( x == Float.NaN ) return Float.NaN if ( x == Float.POSITIVE_INFINITY ) return Float.POSITIVE_INFINITY if ( x == Float.NEGATIVE_INFINITY ) return Float.NEGATIVE_INFINITY if ( x == Float.POSITIVE_INFINITY ) return Float.POSITIVE_INFINITY if ( x == Float.NEGATIVE_INFINITY ) return Float.NEGATIVE_INFINITY if ( x == Float.EPSILON ) return Float.EPSILON if ( x == Float.MIN_VALUE ) return Float.MIN_VALUE if ( x == Float.MAX_VALUE ) return Float.MAX_VALUE if ( x == Float.INFINITY ) return Float.INFINITY if ( x == Float.ZERO ) return Float.ZERO if ( x == Float.NAN ) return Float.NAN if ( x == Float.POSITIVE_INFINITY ) return Float.POSITIVE_INFINITY if
{ if ( x < 0 ) { return -1.0f } else if ( x == 0 ) { return 0.0f } else { return 1.0f } } /** * Returns the sign of the given value [x]: * - `-1.0` if the value is negative, * - zero if the value is zero, * - `1.0` if the value is positive * * Special case: * - `sign(NaN)` is `NaN` */ /** * Returns the sign of the given value [x]: * - `-1.0` if the value is negative, * - zero if the value is zero, * - `1.0` if the value is positive * * Special case: * - `sign(NaN)` is `NaN` */ /** * Returns the sign of the given value [x]: * - `-1.0` if the value is negative, * - zero if the value is zero, * - `1.0` if the value
{ if ( a == b ) return a if ( a == null ) return b if ( b == null ) return a return a < b ? a : b } /** * Returns the larger of two values. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`. * * If either value is `NaN`, then the result is `NaN`.
{ if ( a == b ) { return a } else { return a > b ? a : b } } /** * Returns the greater of two values. * * If either value is `NaN`, then the result is `NaN`. * * If both values are `NaN`, then the result is `NaN`. */ max ( a : Float , b : Float ) : Float /** * Returns the greater of two values. * * If either value is `NaN`, then the result is `NaN`. * * If both values are `NaN`, then the result is `NaN`. */ max ( a : Float , b : Float ) : Float /** * Returns the greater of two values. * * If either value is `NaN`, then the result is `NaN`. * * If both values are `NaN`, then the result is `NaN`. */ max ( a : Float , b : Float ) : Float /** * Returns the greater of two values. * * If either value is `NaN`,


/** * Raises this value to the integer power [n]. * * See the other overload of [pow] for details. */ /** * Raises this value to the integer power [n]. * * See the other overload of [pow] for details. */ /** * Raises this value to the integer power [n]. * * See the other overload of [pow] for details. */ /** * Raises this value to the integer power [n]. * * See the other overload of [pow] for details. */ /** * Raises this value to the integer power [n]. * * See the other overload of [pow] for details. */ /** * Raises this value to the integer power [n]. * * See the other overload of [pow] for details. */ /** * Raises this value to the integer power [n]. * * See the other overload of [pow] for details. */ /** * Raises this value to the integer power [n]. *
{ if ( sign == Float.NaN ) return Float.NaN if ( sign == Float.POSITIVE_INFINITY ) return Float.POSITIVE_INFINITY if ( sign == Float.NEGATIVE_INFINITY ) return Float.NEGATIVE_INFINITY if ( sign == Float.POSITIVE_INFINITY ) return Float.POSITIVE_INFINITY if ( sign == Float.NEGATIVE_INFINITY ) return Float.NEGATIVE_INFINITY if ( sign == Float.POSITIVE_INFINITY ) return Float.POSITIVE_INFINITY if ( sign == Float.NEGATIVE_INFINITY ) return Float.NEGATIVE_INFINITY if ( sign == Float.POSITIVE_INFINITY ) return Float.POSITIVE_INFINITY if ( sign == Float.NEGATIVE_INFINITY ) return Float.NEGATIVE_INFINITY if ( sign == Float.POSITIVE_INFINITY ) return Float.POSITIVE_INFINITY if ( sign
{ if ( sign == 0 ) { return Float.ZERO } else if ( sign == 1 ) { return Float.ONE } else if ( sign == -1 ) { return Float.NEGATIVE_ONE } else if ( sign == -2 ) { return Float.NEGATIVE_TWO } else if ( sign == -3 ) { return Float.NEGATIVE_THREE } else if ( sign == -4 ) { return Float.NEGATIVE_FOUR } else if ( sign == -5 ) { return Float.NEGATIVE_FIVE } else if ( sign == -6 ) { return Float.NEGATIVE_SIX } else if ( sign == -7 ) { return Float.NEGATIVE_SEVEN } else if ( sign == -8 ) { return Float.NEGATIVE_EIGHT } else if ( sign == -9 ) { return Float.NEGATIVE_NINE } else if ( sign == -10 ) { return Float


{ if ( n < 0 ) return -n return n } /** * Returns the absolute value of the given value [n]. * * Special cases: * - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow * * @see absoluteValue extension property for [Int] */ /** * Returns the absolute value of the given value [n]. * * Special cases: * - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow * * @see absoluteValue extension property for [Int] */ /** * Returns the absolute value of the given value [n]. * * Special cases: * - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow * * @see absoluteValue extension property for [Int] */ /** * Returns the absolute value of the given value [n]. * * Special cases: * - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow
{ if ( a < b ) { return a } else { return b } } /** * Returns the larger of two values. */ max ( a : Int , b : Int ) : Int/** * Returns the larger of two values. */ max ( a : Int , b : Int ) : Int/** * Returns the larger of two values. */ max ( a : Int , b : Int ) : Int/** * Returns the larger of two values. */ max ( a : Int , b : Int ) : Int/** * Returns the larger of two values. */ max ( a : Int , b : Int ) : Int/** * Returns the larger of two values. */ max ( a : Int , b : Int ) : Int/** * Returns the larger of two values. */ max ( a : Int , b : Int ) : Int/** * Returns the larger of two values. */ max ( a : Int , b : Int ) : Int/** * Returns the larger of two values. */ max ( a : Int , b : Int ) : Int/** * Returns the larger of two values.
{ if ( a > b ) return a else return b } /** * Returns the smaller of two values. */ fun min ( a : Int , b : Int ) : Int/** * Returns the greater of two values. */ fun max ( a : Int , b : Int ) : Int/** * Returns the smaller of two values. */ fun min ( a : Int , b : Int ) : Int/** * Returns the greater of two values. */ fun max ( a : Int , b : Int ) : Int/** * Returns the smaller of two values. */ fun min ( a : Int , b : Int ) : Int/** * Returns the greater of two values. */ fun max ( a : Int , b : Int ) : Int/** * Returns the smaller of two values. */ fun min ( a : Int , b : Int ) : Int/** * Returns the greater of two values. */ fun max ( a : Int , b : Int ) : Int/** * Returns the smaller of two values. */ fun min ( a : Int , b : Int )
{ if ( n < 0 ) return -n; return n; } /** * Returns the absolute value of the given value [n]. * * Special cases: * - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow * * @see absoluteValue extension property for [Long] */ /** * Returns the absolute value of the given value [n]. * * Special cases: * - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow * * @see absoluteValue extension property for [Long] */ /** * Returns the absolute value of the given value [n]. * * Special cases: * - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow * * @see absoluteValue extension property for [Long] */ /** * Returns the absolute value of the given value [n]. * * Special cases: * - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE`
{ if ( a < b ) { return a } else { return b } } /** * Returns the larger of two values. */ max ( a : Long , b : Long ) : Long ike { if ( a > b ) { return a } else { return b } } /** * Returns the sum of two values. */ plus ( a : Long , b : Long ) : Long ike { return a + b } /** * Returns the difference of two values. */ minus ( a : Long , b : Long ) : Long ike { return a - b } /** * Returns the product of two values. */ times ( a : Long , b : Long ) : Long ike { return a * b } /** * Returns the quotient of two values. */ divide ( a : Long , b : Long ) : Long ike { return a / b } /** * Returns the remainder of two values. */ modulo ( a : Long , b :
{ if ( a > b ) return a else return b } /** * Returns the smaller of two values. */ ikey@ SinceKotlin ( " ikey" ) ikey public expect fun min ( a : Long , b : Long ) : Long ikey { if ( a < b ) return a else return b } /** * Returns the sum of two values. */ ikey@ SinceKotlin ( " ikey" ) ikey public expect fun add ( a : Long , b : Long ) : Long ikey { return a + b } /** * Returns the difference of two values. */ ikey@ SinceKotlin ( " ikey" ) ikey public expect fun sub ( a : Long , b : Long ) : Long ikey { return a - b } /** * Returns the product of two values. */ ikey@ SinceKotlin ( " ikey" ) ikey public expect fun mul ( a : Long , b : Long ) : Long ikey {
( ) { for ( var i = 0; i < this.nodes.size; i++ ) { var node = this.nodes.get( i ) if ( node != null ) { node.processSecondPass ( ) } } } /** * This method is used for traversing nodes after the second stage of compilation. */ processSecondPass override fun processThirdPass ( ) { for ( var i = 0; i < this.nodes.size; i++ ) { var node = this.nodes.get( i ) if ( node != null ) { node.processThirdPass ( ) } } } /** * This method is used for traversing nodes after the third stage of compilation. */ processThirdPass override fun processFourthPass ( ) { for ( var i = 0; i < this.nodes.size; i++ ) { var node = this.nodes.get( i ) if ( node != null ) { node.processFourthPass ( ) } }
internal { if ( this.cancellable ) { this.cancellable.cancel() this.cancellable = null } } /** * Awaits until previous call to `suspendCancellableCoroutineReusable` will * stop mutating cached instance */ kafkainternal fun awaitReusability ( ) kafkainternal { if ( this.cancellable ) { this.cancellable.cancel() this.cancellable = null } } /** * Awaits until previous call to `suspendCancellableCoroutineReusable` will * stop mutating cached instance */ kafkainternal fun awaitReusability ( ) kafkainternal { if ( this.cancellable ) { this.cancellable.cancel() this.cancellable = null } } /** * Awaits until previous call to `suspendCancellableCoroutineReusable` will * stop mutating cached instance */ kafka

ue : Throwable * * @param cause The cause of the cancellation. * * @return `true` if cancellation is (or previously was) postponed, `false` otherwise. */ public boolean postponeCancellation ( Throwable cause ) { if ( isReusableClaimed ( cause ) ) { return true; } else { return false; } } /** * Tries to postpone cancellation if reusable CC is currently in [REUSABLE_CANCELLED] state. * Returns `true` if cancellation is (or previously was) postponed, `false` otherwise. */ public boolean postponeCancellation ( Throwable cause ) { if ( isReusableCancelled ( cause ) ) { return true; } else { return false; } } /** * Tries to postpone cancellation if reusable CC is currently in [REUSABLE_FAILED] state. * Returns `true` if cancellation is (or previously was) postponed, `false` otherwise. */







/** * Returns the set of top-level callable (functions and properties) names in the file. * * The result may have false-positive entries but cannot have false-negative entries. It should contain all the names in the package but may have some additional names that are not there. * * @see KtResolveExtensionFile */ ktpublic abstract fun getTopLevelCallableNames ( ) : Set < Name > ktpublic /** * Returns the set of top-level callable (functions and properties) names in the file. * * The result may have false-positive entries but cannot have false-negative entries. It should contain all the names in the package but may have some additional names that are not there. * * @see KtResolveExtensionFile */ ktpublic abstract fun getTopLevelCallableNames ( ) : Set < Name > ktpublic /** * Returns the set of top-level callable (functions and properties) names in the file. * * The result may have false-positive entries but cannot have false-negative entries. It should contain all the names in the package

( ) : KtResolveExtensionNavigationTargetsProvider ( ) : KtResolveExtensionNavigationTargetsProvider ( ) : KtResolveExtensionNavigationTargetsProvider ( ) : KtResolveExtensionNavigationTargetsProvider ( ) : KtResolveExtensionNavigationTargetsProvider ( ) : KtResolveExtensionNavigationTargetsProvider ( ) : KtResolveExtensionNavigationTargetsProvider ( ) : KtResolveExtensionNavigationTargetsProvider ( ) : KtResolveExtensionNavigationTargetsProvider ( ) : KtResolveExtensionNavigationTargetsProvider ( ) : KtResolveExtensionNavigationTargetsProvider ( ) : KtResolveExtensionNavigationTargetsProvider ( ) : KtResolveExtensionNavigationTargetsProvider ( ) : KtResolveExtensionNavigationTargetsProvider ( ) : KtResolveExtensionNavigationTargetsProvider ( ) : KtResolveExtensionNavigationTargetsProvider ( ) : KtResolveExtensionNavigationTargetsProvider (






{ if ( output == null ) { return null; } if ( output.isEmpty() ) { return null; } if ( output.size() == 0 ) { return null; } if ( output.size() == 1 ) { return output[0]; } if ( output.size() == 2 ) { return output[0] + output[1]; } if ( output.size() == 3 ) { return output[0] + output[1] + output[2]; } if ( output.size() == 4 ) { return output[0] + output[1] + output[2] + output[3]; } if ( output.size() == 5 ) { return output[0] + output[1] + output[2] + output[3] + output[4]; } if ( output.size() == 6 ) { return output[0] + output[1] + output[2] + output[3] + output[4]
{ if ( input == null ) { throw new IllegalArgumentException("Input is null") } if ( input.isNull() ) { throw new IllegalArgumentException("Input is null") } if ( input.isBlank() ) { throw new IllegalArgumentException("Input is blank") } if ( input.isEmpty() ) { throw new IllegalArgumentException("Input is empty") } if ( input.isNotBlank() ) { throw new IllegalArgumentException("Input is not blank") } if ( input.isNotEmpty() ) { throw new IllegalArgumentException("Input is not empty") } if ( input.isNotBlank() ) { throw new IllegalArgumentException("Input is not blank") } if ( input.isBlank() ) { throw new IllegalArgumentException("Input is blank") } if ( input.isBlank() ) { throw new IllegalArgumentException("Input is blank") } if
abstract * * @param other * @return */ fun isImplies ( other : ESEffect ) : Boolean ? /** * Returns: * - true, when presence of `this`-effect necessary implies presence of `other`-effect * - false, when presence of `this`-effect necessary implies absence of `other`-effect * - null, when presence of `this`-effect doesn't implies neither presence nor absence of `other`-effect */ fun isImplies ( other : ESEffect ) : Boolean ? /** * Returns: * - true, when presence of `this`-effect necessary implies presence of `other`-effect * - false, when presence of `this`-effect necessary implies absence of `other`-effect * - null, when presence of `this`-effect doesn't implies neither presence nor absence of `other`-effect */ fun isImplies ( other : ESEffect ) : Boolean ? /** * Returns: * - true, when presence of `this`-effect necessary implies presence of `other`-effect * - false, when presence of `
{ if ( this is KtClassLikeSymbol ) { return this } else { return null } } /** * Returns [KtSamConstructorSymbol] if the given [KtInterfaceLikeSymbol] is a functional interface type, a.k.a. SAM. */ ktpublic fun KtInterfaceLikeSymbol . getSamConstructor ( ) : KtSamConstructorSymbol ? kt { if ( this is KtInterfaceLikeSymbol ) { return this } else { return null } } /** * Returns [KtSamConstructorSymbol] if the given [KtInterfaceLikeSymbol] is a functional interface type, a.k.a. SAM. */ ktpublic fun KtInterfaceLikeSymbol . getSamConstructor ( ) : KtSamConstructorSymbol ? kt { if ( this is KtInterfaceLikeSymbol ) { return this } else { return null } } /** * Returns [KtSamConstructorSymbol] if the
( type ) = { type } ; /** * Resolves all *declared* subtypes (not their transitive closure) */ cirfun subtypes ( type : CirClassType ) : Set < CirClassType > ( type ) = { type } ; /** * Resolves all *declared* superclasses (not their transitive closure) */ cirfun superclasses ( type : CirClassType ) : Set < CirClassType > ( type ) = { type } ; /** * Resolves all *declared* subclasses (not their transitive closure) */ cirfun subclasses ( type : CirClassType ) : Set < CirClassType > ( type ) = { type } ; /** * Resolves all *declared* superclasses (not their transitive closure) */ cirfun superclasses ( type : CirClassType ) : Set < CirClassType > ( type ) = { type } ; /** * Resolves all *declared* subclasses (not their transitive closure) */ cirfun subclasses ( type : CirClassType ) : Set < CirClassType > ( type ) = { type } ; /**
: ExecutionSource { if ( testClassesDirs.isEmpty() ) { return this } if ( classpath.isEmpty() ) { return this } if ( testClassesDirs.contains( classpath ) ) { return this } if ( classpath.contains( testClassesDirs.get( 0 ) ) ) { return this } if ( classpath.contains( testClassesDirs.get( 1 ) ) ) { return this } if ( classpath.contains( testClassesDirs.get( 2 ) ) ) { return this } if ( classpath.contains( testClassesDirs.get( 3 ) ) ) { return this } if ( classpath.contains( testClassesDirs.get( 4 ) ) ) { return this } if ( classpath.contains( testClassesDirs.get( 5 ) ) ) { return this } if ( cla
nt { return this } /** * Translates the given [SirType] to [KtType]. */ ktpublic fun SirType . translateType ( ) : KtType ktnt { return this } /** * Translates the given [KtType] to [SirType]. */ ktpublic fun KtType . translateType ( ) : SirType ktnt { return this } /** * Translates the given [SirType] to [KtType]. */ ktpublic fun SirType . translateType ( ) : KtType ktnt { return this } /** * Translates the given [KtType] to [SirType]. */ ktpublic fun KtType . translateType ( ) : SirType ktnt { return this } /** * Translates the given [SirType] to [KtType]. */ ktpublic fun SirType . translateType ( ) : KtType ktnt { return this } /** * Translates the given [Kt
( ) : null /** * Determines visibility of the given [KtSymbolWithVisibility]. * @return null if symbol should not be exposed to SIR completely. */ KtSymbolWithVisibility . sirVisibility ( ) : KtSymbolWithVisibility ( ) /** * Determines visibility of the given [KtSymbolWithVisibility]. * @return null if symbol should not be exposed to SIR completely. */ KtSymbolWithVisibility . sirVisibility ( ) : KtSymbolWithVisibility ( ) /** * Determines visibility of the given [KtSymbolWithVisibility]. * @return null if symbol should not be exposed to SIR completely. */ KtSymbolWithVisibility . sirVisibility ( ) : KtSymbolWithVisibility ( ) /** * Determines visibility of the given [KtSymbolWithVisibility]. * @return null if symbol should not be exposed to SIR completely. */ KtSymbolWithVisibility . sirVisibility ( ) : KtSymbolWithVisibility ( ) /**

x ( useSiteSession : FirSession ) : ConeKotlinType ( useSiteSession : FirSession ) : ConeKotlinType ( useSiteSession : FirSession ) : ConeKotlinType ( useSiteSession : FirSession ) : ConeKotlinType ( useSiteSession : FirSession ) : ConeKotlinType ( useSiteSession : FirSession ) : ConeKotlinType ( useSiteSession : FirSession ) : ConeKotlinType ( useSiteSession : FirSession ) : ConeKotlinType ( useSiteSession : FirSession ) : ConeKotlinType ( useSiteSession : FirSession ) : ConeKotlinType ( useSiteSession : FirSession ) : ConeKotlinType ( useSiteSession : FirSession ) : ConeKotlinType ( useSiteSession : FirSession ) : ConeKotlinType ( useSiteSession : FirSession ) : ConeKotlinType ( useSiteSession : FirSession ) : ConeKotlinType ( useSiteSession : FirSession ) : ConeKotlinType ( useSiteSession : FirSession ) : ConeKotlinType
fun ConeSimpleKotlinType.fullyExpandedType ( useSiteSession : FirSession ) : ConeSimpleKotlinType { return this } fun ConeSimpleKotlinType.fullyExpandedType ( useSiteSession : FirSiteSession ) : ConeSimpleKotlinType { return this } fun ConeSimpleKotlinType.fullyExpandedType ( useSiteSession : FirSiteSession ) : ConeSimpleKotlinType { return this } fun ConeSimpleKotlinType.fullyExpandedType ( useSiteSession : FirSiteSession ) : ConeSimpleKotlinType { return this } fun ConeSimpleKotlinType.fullyExpandedType ( useSiteSession : FirSiteSession ) : ConeSimpleKotlinType { return this } fun ConeSimpleKotlinType.fullyExpandedType ( useSiteSession : FirSiteSession ) : ConeSimpleKotlinType { return this } fun ConeSimpleKotlinType.fullyExpandedType ( use
fun ( fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExpandedConeType . fullyExp
* @param session * @return */ public FirClassLikeDeclaration fullyExpandedClass ( session : FirSession ) : FirClassLikeDeclaration { FirClassLikeDeclaration result = new FirClassLikeDeclaration(); result.name = session.name; result.className = session.className; result.typeName = session.typeName; return result; } /** * @see fullyExpandedType */ public FirTypeAlias fullyExpandedType ( session : FirSession ) : FirTypeAlias { FirTypeAlias result = new FirTypeAlias(); result.name = session.name; result.className = session.className; result.typeName = session.typeName; return result; } /** * @see fullyExpandedClass */ public FirClassLikeDeclaration fullyExpandedClass ( session : FirSession ) : FirClassLikeDeclaration { FirClassLikeDeclaration result = new FirClassLikeDeclaration(); result.name = session.name; result.className = session.


{ if ( this.isEmpty() ) { this.data = data } else { this.data = this.data + data } } /** * Appends data to the buffer. * * @param data the data to append. */ /** * Appends data to the buffer. * * @param data the data to append. */ /** * Appends data to the buffer. * * @param data the data to append. */ /** * Appends data to the buffer. * * @param data the data to append. */ /** * Appends data to the buffer. * * @param data the data to append. */ /** * Appends data to the buffer. * * @param data the data to append. */ /** * Appends data to the buffer. * * @param data the data to append. */ /** * Appends data to the buffer. * * @param data the data to append. */ /** * Appends data to the buffer. * *
public fun append ( data : ByteArray , fromIndex : Int = ike , toIndex : Int = data . size ) : Unit ikepublic fun append ( data : ByteArray , fromIndex : Int = ike , toIndex : Int = data . size ) : Unit ikepublic fun append ( data : ByteArray , fromIndex : Int = ike , toIndex : Int = data . size ) : Unit ikepublic fun append ( data : ByteArray , fromIndex : Int = ike , toIndex : Int = data . size ) : Unit ikepublic fun append ( data : ByteArray , fromIndex : Int = ike , toIndex : Int = data . size ) : Unit ikepublic fun append ( data : ByteArray , fromIndex : Int = ike , toIndex : Int = data . size ) : Unit ikepublic fun append ( data : ByteArray , fromIndex : Int = ike , toIndex : Int = data . size ) : Unit ikepublic fun append ( data : ByteArray , fromIndex : Int = ike , toIndex : Int = data . size ) : Unit ikepublic fun append ( data : ByteArray , fromIndex : Int = ike

public fun copyInto ( output : ByteArray , destinationIndex : Int , startIndex : Int , endIndex : Int ) : Unit { if (destinationIndex < startIndex || destinationIndex > endIndex || startIndex < 0 || startIndex > output.length || endIndex < 0 || endIndex > output.length) { throw new IllegalArgumentException() } if (destinationIndex == startIndex) { output[destinationIndex] = startIndex return } if (destinationIndex == endIndex) { output[destinationIndex] = endIndex return } if (startIndex == endIndex) { output[destinationIndex] = startIndex return } if (startIndex > endIndex) { throw new IllegalArgumentException() } if (startIndex < 0) { throw new IllegalArgumentException() } if (endIndex < 0) { throw new IllegalArgumentException() } if (startIndex > output.length) { throw new IllegalArgumentException
public operator fun set ( index : Int, value : Byte ) : None { if ( index < 0 || index >= mutableData.size() ) { throw new IndexOutOfBoundsException( index ) } mutableData[ index ] = value } /** * Get a byte from the immutable data. * * @Throws IndexOutOfBoundsException if index is beyond range. */ igpublic operator get ( index : Int ) : Byte igpublic operator fun set ( index : Int, value : Byte ) : None { if ( index < 0 || index >= immutableData.size() ) { throw new IndexOutOfBoundsException( index ) } immutableData[ index ] = value } /** * Get a byte from the mutable data. * * @Throws IndexOutOfBoundsException if index is beyond range. */ igpublic operator get ( index : Int ) : Byte igpublic operator fun set ( index : Int, value : Byte ) : None { if ( index < 0 || index >= mutableData.size() ) { throw new IndexOut
{ if ( block == null ) throw IllegalArgumentException () if ( block.dataSize != dataSize ) throw IllegalArgumentException () if ( block.dataSize == 0 ) throw IllegalArgumentException () if ( block.dataSize < 0 ) throw IllegalArgumentException () if ( block.dataSize == 1 ) throw IllegalArgumentException () if ( block.dataSize == 2 ) throw IllegalArgumentException () if ( block.dataSize == 3 ) throw IllegalArgumentException () if ( block.dataSize == 4 ) throw IllegalArgumentException () if ( block.dataSize == 5 ) throw IllegalArgumentException () if ( block.dataSize == 6 ) throw IllegalArgumentException () if ( block.dataSize == 7 ) throw IllegalArgumentException () if ( block.dataSize == 8 ) throw IllegalArgumentException () if ( block.dataSize == 9 ) throw IllegalArgumentException () if ( block.dataSize == 10 ) throw IllegalArgumentException () if ( block.dataSize == 11 ) throw IllegalArgumentException ()
{ if ( block == null ) { throw IllegalArgumentException( "block is null" ) } if ( block.dataSize <= 0 ) { throw IllegalArgumentException( "block dataSize must be positive" ) } if ( block.dataSize > dataSize ) { throw IllegalArgumentException( "block dataSize must be less than or equal to dataSize" ) } if ( block.dataSize == dataSize ) { throw IllegalArgumentException( "block dataSize is equal to dataSize" ) } if ( block.dataSize > dataSize ) { throw IllegalArgumentException( "block dataSize is greater than dataSize" ) } if ( block.dataSize == dataSize ) { throw IllegalArgumentException( "block dataSize is equal to dataSize" ) } if ( block.dataSize > dataSize ) { throw IllegalArgumentException( "block dataSize is greater than dataSize" ) } if ( block.dataSize == dataSize ) { throw IllegalArg

private fun jumpDataFlowToPostponedLambdas ( symbol : FirFunctionSymbol < * > ) { if ( symbol.isPostponedLambda ) { symbol.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.postponedLambda.post
{ if ( this.primaryConstructor ) { return this.primaryConstructor } else { return this.firstPropertyOrAnonymousInitializer() } } /** * The second in-place initializer is either: * 1. The primary constructor. * 2. The second property or anonymous initializer. */ /** * The second in-place initializer is either: * 1. The primary constructor. * 2. The second property or anonymous initializer. */ /** * The third in-place initializer is either: * 1. The primary constructor. * 2. The third property or anonymous initializer. */ /** * The third in-place initializer is either: * 1. The primary constructor. * 2. The third property or anonymous initializer. */ /** * The fourth in-place initializer is either: * 1. The primary constructor. * 2. The fourth property or anonymous initializer. */ /** * The fourth in-place initializer is either: * 1. The primary constructor. * 2. The fourth

: Boolean { try { node.invoke() } catch ( e : Exception ) { return false } return true } /** * this is a workaround to make function call dead when call is completed _before_ building its node in the graph * this happens when completing the first call in try/catch blocks * @returns `true` if node actually returned Nothing */ private fun completeFunctionCall ( node : FunctionCallNode ) : Boolean trove : Boolean { try { node.invoke() } catch ( e : Exception ) { return false } return true } /** * this is a workaround to make function call dead when call is completed _after_ building its node in the graph * this happens when completing the last call in try/catch blocks * @returns `true` if node actually returned Nothing */ private fun completeFunctionCall ( node : FunctionCallNode ) : Boolean trove : Boolean { try { node.invoke() } catch ( e : Exception ) { return false } return true } /**
* { if ( exitNode == null ) { return; } else { if ( implicitReceiver == null ) { implicitReceiver = implicitNode; } else { implicitNode = implicitReceiver; implicitReceiver = implicitNode->next; } } implicitNode = implicitNode->next; implicitReceiver = implicitNode->next; implicitNode = implicitNode->next; implicitReceiver = implicitNode->next; implicitReceiver = implicitNode->next; implicitReceiver = implicitNode->next; implicitReceiver = implicitNode->next; implicitReceiver = implicitNode->next; implicitReceiver = implicitNode->next; implicitReceiver = implicitNode->next; implicitReceiver = implicitNode->next; implicitReceiver = implicitNode->next; implicitReceiver = implicitNode->next; implicitReceiver = implicitNode->next;
Public: ConeKotlinType? { return this } /** * Sets [type] as receiver type of the function. */ kotlinpublic fun extensionReceiverType ( type : ConeKotlinType ) kotPublic: ConeKotlinType? { return this } /** * Sets [type] as function receiver type of the function. */ kotpublic fun extensionReceiverType ( type : ConeKotlinType ) kotPublic: ConeKotlinType? { return this } /** * Sets [type] as function receiver type of the function. */ kotpublic fun extensionReceiverType ( type : ConeKotlinType ) kotPublic: ConeKotlinType? { return this } /** * Sets [type] as function receiver type of the function. */ kotpublic fun extensionReceiverType ( type : ConeKotlinType ) kotPublic: ConeKotlinType? { return this } /** * Sets [type] as function receiver type of the function. */ k
: ConeKotlinType { return this } /** * Sets type, provided by [typeProvider], as extension receiver type of the function. * * Use this overload when extension receiver type references type parameters of the function. * * Use this overload when extension receiver type references type parameters of the function. * * Use this overload when extension receiver type references type parameters of the function. * * Use this overload when extension receiver type references type parameters of the function. * * Use this overload when extension receiver type references type parameters of the function. * * Use this overload when extension receiver type references type parameters of the function. * * Use this overload when extension receiver type references type parameters of the function. * * Use this overload when extension receiver type references type parameters of the function. * * Use this overload when extension receiver type references type parameters of the function. * * Use this overload when extension receiver type references type parameters of the function. * * Use this overload when extension receiver type references type parameters of the function. * * Use this overload when extension receiver type references type parameters of the function. * *
( owner , key , name , returnType , config ) : ConeKotlinFunction ( owner , key , name , returnType , config ) : ConeKotlinFunction ( owner , key , name , returnType , config ) : ConeKotlinFunction ( owner , key , name , returnType , config ) : ConeKotlinFunction ( owner , key , name , returnType , config ) : ConeKotlinFunction ( owner , key , name , returnType , config ) : ConeKotlinFunction ( owner , key , name , returnType , config ) : ConeKotlinFunction ( owner , key , name , returnType , config ) : ConeKotlinFunction ( owner , key , name , returnType , config ) : ConeKotlinFunction ( owner , key , name , returnType , config ) : ConeKotlinFunction ( owner , key , name , returnType , config ) : ConeKotlinFunction ( owner , key , name , returnType , config ) : ConeKotlinFunction ( owner , key , name , returnType , config ) : ConeKotlinFunction ( owner , key , name , returnType











{ var byteArray = Array<Byte>() for ( var i = 0; i < this.data.size; i++ ) { byteArray.put(this.data.get(i)) } return byteArray } /** * Read data from [Arrow random access format](https://arrow.apache.org/docs/java/ipc.html#reading-and-writing-random-access-files), write to new [ByteArray] */ private fun readArrowFeatherToByteArray ( ) : ByteArray { var byteArray = Array<Byte>() for ( var i = 0; i < this.data.size; i++ ) { byteArray.put(this.data.get(i)) } return byteArray } /** * Read data from [Arrow random access format](https://arrow.apache.org/docs/java/ipc.html#reading-and-writing-random-access-files), write to new [ByteArray] */ private fun writeArrowFeatherToByteArray ( ) : ByteArray {
@ Test fun testSimpleCompile ( ) import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; import java.util.regex.Matcher; import java.util.regex.Pattern; public class PatternTest { public static void main(String[] args) { Pattern pattern = Pattern.compile("[a-z]+"); Matcher matcher = pattern.matcher("abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabc
{ return DataFrameHtmlData( this, configuration ) } /** * @return DataFrameHtmlData with additional definitions. Can be rendered in Jupyter kernel environments */ fun DataFrameHtmlData( data : DataFrameHtmlData, configuration : DisplayConfiguration = DisplayConfiguration . DEFAULT ) = DataFrameHtmlData( data, configuration ) /** * @return DataFrameHtmlData with additional definitions. Can be rendered in Jupyter kernel environments */ fun DataFrameHtmlData( data : DataFrameHtmlData, configuration : DisplayConfiguration = DisplayConfiguration . DEFAULT ) = DataFrameHtmlData( data, configuration ) /** * @return DataFrameHtmlData with additional definitions. Can be rendered in Jupyter kernel environments */ fun DataFrameHtmlData( data : DataFrameHtmlData, configuration : DisplayConfiguration = DisplayConfiguration . DEFAULT ) = DataFrameHtmlData( data, configuration ) /** * @return DataFrameHtmlData with additional definitions. Can be rendered in Jupyter kernel environments */ fun DataFrameHtmlData( data : DataFrameHtml





{ final String javaHome = "java.home"; final List<String> versions = Arrays.asList("1.8", "1.9", "1.10", "1.11", "1.12", "1.13", "1.14", "1.15", "1.16", "1.17", "1.18", "1.19", "1.20", "1.21", "1.22", "1.23", "1.24", "1.25", "1.26", "1.27", "1.28", "1.29", "1.30", "1.31", "1.32", "1.33", "1.34", "1.35", "1.36", "1.37", "1.38", "1.39", "1.40", "1.41", "1.42", "1.43", "1.44", "1.45", "1.46", "1.47", "1.48", "1.49", "1.50", "1.51", "1.52", "1.
. testPackageInTheMiddle ( allTools = false ) */ fun testPackageInTheMiddle ( allTools: Boolean = true ) : Unit { assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEquals( true, allTools ) assertEqu
fun { const auto model_url = "https://model-hub.onnx.ai/ssd/ssd_mobilenet_v2_coco_2018_01_28/ssd_mobilenet_v2_coco_2018_01_28.onnx"; const auto model_path = "ssd_mobilenet_v2_coco_2018_01_28.onnx"; const auto image_url = "https://model-hub.onnx.ai/ssd/ssd_mobilenet_v2_coco_2018_01_28/ssd_mobilenet_v2_coco_2018_01_28.onnx"; const auto image_path = "ssd_mobilenet_v2_coco_2018_01_28.onnx"; const auto output_path = "ssd_mobilenet_v2_coco_2018_01_28/ssd_mobilenet_v2_coco_2018_01_28.onnx
Protected { if ( ! variableNames.isEmpty() ) { for ( String variableName : variableNames ) { var data = getData( variableName ); if ( data == null ) { throw new IllegalArgumentException( "Failed to load variable '" + variableName + "' with shape " + getData( variableName ).getShape() ); } } } return this; } /** * Loads variable data for variable names in the provided collection using a provided function. * @param [variableNames] Variable names to load. * @param [getData] Function that returns variable data by variable name and shape. */ varProtected open fun loadVariables ( variableNames : Collection < String > , getData : ( String , Shape ) -> Any ) varProtected { if ( ! variableNames.isEmpty() ) { for ( String variableName : variableNames ) { var data = getData( variableName ); if ( data == null ) { throw new IllegalArgumentException( "Failed to load variable '" + variableName + "' with shape
protected fun isOptimizerVariable ( variableName : String ) : Boolean { if ( variableName.length() == 0 ) { return false; } else if ( variableName.length() == 1 ) { return true; } else if ( variableName.length() > 1 ) { return false; } else { return true; } } /** Check that the variable with the name [variableName] is not an optimizer variable**/ protected fun isNotOptimizerVariable ( variableName : String ) : Boolean { if ( variableName.length() == 0 ) { return true; } else if ( variableName.length() == 1 ) { return false; } else if ( variableName.length() > 1 ) { return true; } else { return false; } } /** Check that the variable with the name [variableName] is not an optimizer
protected * * @param [pathToModelDirectory] Path to directory with TensorFlow graph and variable data. * @param [loadOptimizerState] Loads optimizer internal variables data, if true. */ void loadVariablesFromTxt ( pathToModelDirectory : String , loadOptimizerState : Boolean ) * * @param [pathToModelDirectory] Path to directory with TensorFlow graph and variable data. * @param [loadOptimizerState] Loads optimizer internal variables data, if true. */ void saveVariablesToTxt ( pathToModelDirectory : String , loadOptimizerState : Boolean ) * * @param [pathToModelDirectory] Path to directory with TensorFlow graph and variable data. * @param [loadOptimizerState] Loads optimizer internal variables data, if true. */ void saveVariablesToTxt ( pathToModelDirectory : String , loadOptimizerState : Boolean ) * * @param [pathToModelDirectory] Path to directory with TensorFlow graph and variable data. * @param [loadOptimizerState] Loads optimizer internal variables data
lectedVariables : List<String> = ArrayList<String>() { var variables : List<String> = ArrayList<String>() try { File file = new File( pathToModelDirectory ) if ( file.exists() ) { FileReader fileReader = new FileReader( file ) BufferedReader bufferedReader = new BufferedReader( fileReader ) String line; while ( ( line = bufferedReader.readLine() ) != null ) { if ( predicate( line ) ) { variables.add( line ) } } } } catch ( FileNotFoundException e ) { e.printStackTrace() } catch ( IOException e ) { e.printStackTrace() } return variables } /** * Loads variable data from .csv files for variables matching the provided predicate. * * @param [pathToModelDirectory] Path to directory with TensorFlow graph and variable data. * @param
protected { if ( data == null ) { throw new IllegalArgumentException( "Cannot assign null to variable." ); } if ( data.getClass() != variableShape.getClass() ) { throw new IllegalArgumentException( "Cannot assign data of type " + data.getClass() + " to variable of type " + variableShape.getClass() ); } if ( variableName == null ) { throw new IllegalArgumentException( "Cannot assign null to variable name." ); } if ( variableName.length() == 0 ) { throw new IllegalArgumentException( "Cannot assign null to variable name." ); } if ( data.getClass().getName() != variableName.getClass().getName() ) { throw new IllegalArgumentException( "Cannot assign data of type " + data.getClass().getName() + " to variable of type " + variableName.getClass().getName() ); } if ( variableName.length() == 0 ) { throw new IllegalArgumentException( "Cannot assign null
override { super.close() this.session = null this.tfGraph = null } /** * Creates a new session. * * @param args */ private fun createSession(args: Array<String>) { this.session = Session(args) } /** * Creates a new tfGraph. * * @param args */ private fun createGraph(args: Array<String>) { this.tfGraph = Graph(args) } /** * Creates a new session. * * @param args */ private fun createSession(args: Array<String>) { this.session = Session(args) } /** * Creates a new tfGraph. * * @param args */ private fun createGraph(args: Array<String>) { this.tfGraph = Graph(args) } /** * Creates a new session. *
override { super.close() this.session = null this.tfGraph = null } /** * Creates a new session. * * @param args */ private fun createSession(args: Array<String>) { this.session = Session(args) } /** * Creates a new tfGraph. * * @param args */ private fun createGraph(args: Array<String>) { this.tfGraph = Graph(args) } /** * Creates a new session. * * @param args */ private fun createSession(args: Array<String>) { this.session = Session(args) } /** * Creates a new tfGraph. * * @param args */ private fun createGraph(args: Array<String>) { this.tfGraph = Graph(args) } /** * Creates a new session. *
ly { return project.extensionPoints.toList() } /** * @return all currently registered extension points. * The returned list is *not* live and just represents the current snapshot. */ project operator get ( project : Project ) : Project { return project.extensionPoints.toList() } /** * @return all currently registered extension points. * The returned list is *not* live and just represents the current snapshot. */ project operator get ( project : Project ) : Project { return project.extensionPoints.toList() } /** * @return all currently registered extension points. * The returned list is *not* live and just represents the current snapshot. */ project operator get ( project : Project ) : Project { return project.extensionPoints.toList() } /** * @return all currently registered extension points. * The returned list is *not* live and just represents the current snapshot. */ project operator get ( project : Project ) : Project { return project.extensionPoints.toList() } /** * @return all currently registered extension point

: Pair<FloatArray , LongArray> { if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOf
{ if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () }
( ) : Pair<FloatArray , LongArray> { return OrtSession . Result . getFloatArrayWithShape ( name ) as Pair<FloatArray , LongArray> } /** * Returns the output by [name] as a [LongArray] with its shape. */ pairpublic fun OrtSession . Result . getLongArrayWithShape ( name : String ) : Pair<LongArray , LongArray> { return OrtSession . Result . getLongArrayWithShape ( name ) as Pair<LongArray , LongArray> } /** * Returns the output by [name] as a [FloatArray] with its shape. */ pairpublic fun OrtSession . Result . getFloatArrayWithShape ( name : String ) : Pair<FloatArray , LongArray> { return OrtSession . Result . getFloatArrayWithShape ( name ) as Pair<FloatArray , LongArray> } /** * Returns the output by [name] as a [LongArray] with its shape. */ pairpublic fun OrtSession . Result . getLongArrayWithShape ( name : String ) : Pair<LongArray , LongArray> { return OrtSession . Result
= OrtSession . Result . getFloatArray ( name ) as FloatArray /** * Returns the output by [name] as a [FloatArray]. */ fun OrtSession . Result . getFloatArray ( name : String ) : FloatArray /** * Returns the output by [name] as a [FloatArray]. */ fun OrtSession . Result . getFloatArray ( name : String ) : FloatArray /** * Returns the output by [name] as a [FloatArray]. */ fun OrtSession . Result . getFloatArray ( name : String ) : FloatArray /** * Returns the output by [name] as a [FloatArray]. */ fun OrtSession . Result . getFloatArray ( name : String ) : FloatArray /** * Returns the output by [name] as a [FloatArray]. */ fun OrtSession . Result . getFloatArray ( name : String ) : FloatArray /** * Returns the output by [name] as a [FloatArray]. */ fun OrtSession . Result . getFloatArray ( name : String ) : FloatArray
{ if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () }
: DoubleArray { if ( index < 0 || index >= this.size ) { throw new IndexOutOfBoundsException () } else { return this.getDoubleArray ( index ) } } /** * Returns the input at [index] as a [DoubleArray]. */ ortpublic fun OrtSession . Result . getDoubleArray ( index : Int ) : DoubleArray ort : DoubleArray { if ( index < 0 || index >= this.size ) { throw new IndexOutOfBoundsException () } else { return this.getDoubleArray ( index ) } } /** * Returns the input at [index] as a [DoubleArray]. */ ortpublic fun OrtSession . Result . getDoubleArray ( index : Int ) : DoubleArray ort : DoubleArray { if ( index < 0 || index >= this.size ) { throw new IndexOutOfBoundsException () } else { return this.getDoubleArray ( index ) } } /** * Returns the input at [index] as a [DoubleArray].
( name ) : Pair < DoubleArray , LongArray > { return Pair ( OrtSession . Result . getDoubleArray ( name ), OrtSession . Result . getLongArray ( name ) ) } /** * Returns the input by [name] as a [DoubleArray] with its shape. */ OrtSession . Result . getDoubleArrayWithShape ( name : String ) : Pair < DoubleArray , LongArray > : Pair < DoubleArray , LongArray > { return Pair ( OrtSession . Result . getDoubleArray ( name ), OrtSession . Result . getLongArray ( name ) ) } /** * Returns the input by [name] as a [LongArray] with its shape. */ OrtSession . Result . getDoubleArrayWithShape ( name : String ) : Pair < DoubleArray , LongArray > : Pair < DoubleArray , LongArray > { return Pair ( OrtSession . Result . getDoubleArray ( name ), OrtSession . Result . getLongArray ( name ) ) } /** * Returns the input by [name] as a [DoubleArray] with its shape. */ OrtSession . Result . getDoubleArrayWithShape ( name :
= OrtSession . Result . getDoubleArray ( name ) /** * Returns the input by [name] as a [DoubleArray]. */ OrtSession . Result . getDoubleArray ( name : String ) = OrtSession . Result . getDoubleArray ( name ) /** * Returns the input by [name] as a [DoubleArray]. */ OrtSession . Result . getDoubleArray ( name : String ) = OrtSession . Result . getDoubleArray ( name ) /** * Returns the input by [name] as a [DoubleArray]. */ OrtSession . Result . getDoubleArray ( name : String ) = OrtSession . Result . getDoubleArray ( name ) /** * Returns the input by [name] as a [DoubleArray]. */ OrtSession . Result . getDoubleArray ( name : String ) = OrtSession . Result . getDoubleArray ( name ) /** * Returns the input by [name] as a [DoubleArray]. */ OrtSession . Result . getDoubleArray ( name : String ) = OrtSession . Result . getDoubleArray ( name ) /** * Returns the input by [name] as a [DoubleArray].
{ if ( index < 0 ) { throw new IllegalArgumentException () } if ( index < 0 ) { throw new IllegalArgumentException () } if ( index < 0 ) { throw new IllegalArgumentException () } if ( index < 0 ) { throw new IllegalArgumentException () } if ( index < 0 ) { throw new IllegalArgumentException () } if ( index < 0 ) { throw new IllegalArgumentException () } if ( index < 0 ) { throw new IllegalArgumentException () } if ( index < 0 ) { throw new IllegalArgumentException () } if ( index < 0 ) { throw new IllegalArgumentException () } if ( index < 0 ) { throw new IllegalArgumentException () } if ( index < 0 ) { throw new IllegalArgumentException () } if ( index < 0 ) { throw new IllegalArgumentException () } if
( index ) { if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException ()
public fun OrtSession . Result . getLongArrayWithShape ( name : String ) : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray > () : Pair < LongArray , LongArray
= OrtSession . Result . getLongArray ( name ) as LongArray /** * Returns the output by [name] as a [FloatArray]. */ OrtSession . Result . getFloatArray ( name : String ) : FloatArray /** * Returns the output by [name] as a [LongArray]. */ OrtSession . Result . getLongArray ( name : String ) : LongArray /** * Returns the output by [name] as a [FloatArray]. */ OrtSession . Result . getFloatArray ( name : String ) : FloatArray /** * Returns the output by [name] as a [LongArray]. */ OrtSession . Result . getLongArray ( name : String ) : LongArray /** * Returns the output by [name] as a [FloatArray]. */ OrtSession . Result . getFloatArray ( name : String ) : FloatArray /** * Returns the output by [name] as a [LongArray]. */ OrtSession . Result . getLongArray ( name : String ) : LongArray /** * Returns the output by [name] as a [FloatArray]. */ OrtSession . Result .
( index ) : Pair < IntArray , LongArray > { if ( index < 0 ) { throw IndexOutOfBoundsException () } if ( index < 0 ) { throw IndexOutOfBoundsException () } if ( index < 0 ) { throw IndexOutOfBoundsException () } if ( index < 0 ) { throw IndexOutOfBoundsException () } if ( index < 0 ) { throw IndexOutOfBoundsException () } if ( index < 0 ) { throw IndexOutOfBoundsException () } if ( index < 0 ) { throw IndexOutOfBoundsException () } if ( index < 0 ) { throw IndexOutOfBoundsException () } if ( index < 0 ) { throw IndexOutOfBoundsException () } if ( index < 0 ) { throw IndexOutOfBoundsException () } if ( index < 0 ) { throw IndexOutOfBoundsException () }
{ if ( index < 0 || index >= this.size ) { throw new IndexOutOfBoundsException () } return this[index] } /** * Returns the input at [index] as an [Int]. */ OrtSession . Result . getInt ( index : Int ) : Int { if ( index < 0 || index >= this.size ) { throw new IndexOutOfBoundsException () } return this[index] } /** * Returns the input at [index] as an [IntArray]. */ OrtSession . Result . getIntArray ( index : Int ) : IntArray { if ( index < 0 || index >= this.size ) { throw new IndexOutOfBoundsException () } return this[index] } /** * Returns the input at [index] as an [Int]. */ OrtSession . Result . getInt ( index : Int ) : Int { if ( index < 0 || index >= this.size ) { throw new IndexOutOfBoundsException () } return this[index]
( name : String ) : Pair < IntArray , LongArray > { return OrtSession . Result . getIntArrayWithShape ( name ) as Pair < IntArray , LongArray > ( OrtSession . Result . getIntArrayWithShape ( name ) as IntArray , OrtSession . Result . getLongArrayWithShape ( name ) as LongArray ) } /** * Returns the output by [name] as an [IntArray] without its shape. */ OrtSession . Result . getIntArrayWithoutShape ( name : String ) : Pair < IntArray , LongArray > : Pair < IntArray , LongArray > { return OrtSession . Result . getIntArrayWithoutShape ( name ) as Pair < IntArray , LongArray > ( OrtSession . Result . getIntArrayWithoutShape ( name ) as IntArray , OrtSession . Result . getLongArrayWithoutShape ( name ) as LongArray ) } /** * Returns the output by [name] as an [LongArray] without its shape. */ OrtSession . Result . getLongArrayWithoutShape ( name : String ) : Pair < IntArray , LongArray > : Pair < IntArray , LongArray > {
{ return OrtSession.Result.getIntArray ( name ) } /** * Returns the input by [name] as an [IntArray]. */ OrtSession . Result . getIntArray ( name : String ) : IntArray ik { return OrtSession.Result.getIntArray ( name ) } /** * Returns the input by [name] as an [IntArray]. */ OrtSession . Result . getIntArray ( name : String ) : IntArray ik2 { return OrtSession.Result.getIntArray ( name ) } /** * Returns the input by [name] as an [IntArray]. */ OrtSession . Result . getIntArray ( name : String ) : IntArray ik3 { return OrtSession.Result.getIntArray ( name ) } /** * Returns the input by [name] as an [IntArray]. */ OrtSession . Result . getIntArray ( name : String ) : IntArray ik4 { return OrtSession.Result.getIntArray ( name ) } /** * Returns the input by [name] as an [Int
{ if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 0 ) { throw new IndexOutOfBoundsException () }
: ShortArray { if ( index < 0 || index >= this.size ) { throw new IndexOutOfBoundsException () } return this[index] } /** * Returns the input at [index] as a [ShortArray]. */ ortpublic fun OrtSession . Result . getShortArray ( index : Int ) : ShortArray ort : ShortArray { if ( index < 0 || index >= this.size ) { throw new IndexOutOfBoundsException () } return this[index] } /** * Returns the input at [index] as a [LongArray]. */ ortpublic fun OrtSession . Result . getLongArray ( index : Int ) : LongArray ort : LongArray { if ( index < 0 || index >= this.size ) { throw new IndexOutOfBoundsException () } return this[index] } /** * Returns the output at [index] as a [LongArray]. */ ortpublic fun OrtSession . Result . getLongArray ( index : Int ) : LongArray ort : LongArray {
{ if ( name == "" ) { return Pair.empty() } else if ( name.length() == 0 ) { return Pair.empty() } else if ( name.length() == 1 ) { return Pair.empty() } else if ( name.length() == 2 ) { return Pair.empty() } else if ( name.length() == 3 ) { return Pair.empty() } else if ( name.length() == 4 ) { return Pair.empty() } else if ( name.length() == 5 ) { return Pair.empty() } else if ( name.length() == 6 ) { return Pair.empty() } else if ( name.length() == 7 ) { return Pair.empty() } else if ( name.length() == 8 ) { return Pair.empty() } else if ( name.length() == 9 ) { return Pair.empty() } else if ( name.length() == 10 ) { return Pair.empty() } else if ( name.
: ShortArray /** * Returns the output by [name] as a [LongArray]. */ OrtSession . Result . getLongArray ( name : String ) : LongArray /** * Returns the output by [name] as a [FloatArray]. */ OrtSession . Result . getFloatArray ( name : String ) : FloatArray /** * Returns the output by [name] as a [DoubleArray]. */ OrtSession . Result . getDoubleArray ( name : String ) : DoubleArray /** * Returns the output by [name] as a [BooleanArray]. */ OrtSession . Result . getBooleanArray ( name : String ) : BooleanArray /** * Returns the output by [name] as a [StringArray]. */ OrtSession . Result . getStringArray ( name : String ) : StringArray /** * Returns the output by [name] as a [LongArray]. */ OrtSession . Result . getLongArray ( name : String ) : LongArray /** * Returns the output by [name] as a [FloatArray]. */ OrtSession . Result . getFloatArray ( name : String ) : Float
{ if ( index < 0 ) { throw IllegalArgumentException () } if ( index >= this.length ) { throw IllegalArgumentException () } if ( this[index] == null ) { throw IllegalArgumentException () } if ( this[index] == 0 ) { throw IllegalArgumentException () } if ( this[index] == 1 ) { throw IllegalArgumentException () } if ( this[index] == 2 ) { throw IllegalArgumentException () } if ( this[index] == 3 ) { throw IllegalArgumentException () } if ( this[index] == 4 ) { throw IllegalArgumentException () } if ( this[index] == 5 ) { throw IllegalArgumentException () } if ( this[index] == 6 ) { throw IllegalArgumentException () } if ( this[index] == 7 ) { throw IllegalArgumentException () } if ( this[
{ if ( index < 0 ) { throw IllegalArgumentException () } if ( index < 0 ) { throw IllegalArgumentException () } if ( index < 0 ) { throw IllegalArgumentException () } if ( index < 0 ) { throw IllegalArgumentException () } if ( index < 0 ) { throw IllegalArgumentException () } if ( index < 0 ) { throw IllegalArgumentException () } if ( index < 0 ) { throw IllegalArgumentException () } if ( index < 0 ) { throw IllegalArgumentException () } if ( index < 0 ) { throw IllegalArgumentException () } if ( index < 0 ) { throw IllegalArgumentException () } if ( index < 0 ) { throw IllegalArgumentException () } if ( index < 0 ) { throw IllegalArgumentException () } if ( index < 0 ) { throw IllegalArgument
public fun OrtSession . Result . getByteArrayWithShape ( name : String ) : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray > () : Pair < ByteArray , LongArray
{ if ( name == "" ) { return ByteArray(0) } else if ( name.isEmpty() ) { return ByteArray(0) } else if ( name.isBlank() ) { return ByteArray(0) } else if ( name.isBlankOrNull() ) { return ByteArray(0) } else if ( name.isBlankOrNullOrWhitespace() ) { return ByteArray(0) } else if ( name.isBlankOrWhitespaceOrBlank() ) { return ByteArray(0) } else if ( name.isBlankOrWhitespaceOrWhitespaceOrBlankOrWhitespace() ) { return ByteArray(0) } else if ( name.isBlankOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWhitespaceOrWh

= OrtSession . Result . get2DFloatArray ( index ) /** * Returns the output at [index] as an Array<FloatArray>. This operation could be slow for high dimensional tensors, * in which case [getFloatArray] should be used. */ /** * Returns the output at [index] as an Array<FloatArray>. This operation could be slow for high dimensional tensors, * in which case [getFloatArray] should be used. */ /** * Returns the output at [index] as an Array<FloatArray>. This operation could be slow for high dimensional tensors, * in which case [getFloatArray] should be used. */ /** * Returns the output at [index] as an Array<FloatArray>. This operation could be slow for high dimensional tensors, * in which case [getFloatArray] should be used. */ /** * Returns the output at [index] as an Array<FloatArray>. This operation could be slow for high dimensional tensors, * in which case [getFloatArray] should be used. */ /** * Returns the output at [index
( ) : Map < String , Any > /** * Returns all values from this [OrtSession.Result]. This operation could be slow for high dimensional tensors, * in which case functions that return one dimensional array such as [getFloatArray] or [getLongArray] should be used. * @see OnnxValue.getValue */ /** * Returns all values from this [OrtSession.Result]. This operation could be slow for high dimensional tensors, * in which case functions that return one dimensional array such as [getFloatArray] or [getLongArray] should be used. * @see OnnxValue.getValue */ /** * Returns all values from this [OrtSession.Result]. This operation could be slow for high dimensional tensors, * in which case functions that return one dimensional array such as [getFloatArray] or [getLongArray] should be used. * @see OnnxValue.getValue */ /** * Returns all values from this [OrtSession.Result]. This operation could be slow for high dimensional tensors, * in which case functions that return one dimensional array
Internal ( valueInfo : ValueInfo , valueName : String , method : String , type : OnnxJavaType ? = null ) * * @param valueInfo * @param valueName * @param method * @param type * @return */ public static void throwIfOutputNotSupported ( valueInfo : ValueInfo , valueName : String , method : String , type : OnnxJavaType ? = null ) { if ( valueInfo.type != type ) { throw new RuntimeException ( valueName + " " + method + " " + type ); } } /** * Checks if [valueInfo] corresponds to a Tensor of the specified [type]. * If it does not satisfy the requirements, exception with a message containing [valueName] and calling [method] name is thrown. * * @param valueInfo * @param valueName * @param method * @param type * @return */ public static void throwIfOutputNotSupported ( valueInfo : ValueInfo , valueName : String , method : String , type : OnnxJavaType ? = null ) { if
= let rec loop ( node : JsNode ) : Boolean = match node with | JsNode :: rest -> loop ( rest ) | JsNode :: rest -> any ( predicate ( node ) ) && loop ( rest ) | JsNode :: rest -> any ( predicate ( node ) ) && loop ( rest ) | JsNode :: rest -> any ( predicate ( node ) ) && loop ( rest ) | JsNode :: rest -> any ( predicate ( node ) ) && loop ( rest ) | JsNode :: rest -> any ( predicate ( node ) ) && loop ( rest ) | JsNode :: rest -> any ( predicate ( node ) ) && loop ( rest ) | JsNode :: rest -> any ( predicate ( node ) ) && loop ( rest ) | JsNode :: rest -> any ( predicate ( node ) ) && loop ( rest ) | JsNode :: rest -> any ( predicate ( node ) ) && loop ( rest ) | JsNode :: rest -> any ( predicate ( node ) ) && loop ( rest ) | JsNode :: rest -> any ( predicate
override { while (true) { println("Interrupting...") Thread.interrupt() } } fun main(args: Array<String>) { val thread = new Thread(InterruptThread()) thread.start() thread.interruptExecutions() thread.join() } Output: Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting... Interrupting
{ return this } /** * Extend this function to define placeholder in layer. * * NOTE: Called instead of [Layer.build]. * * @param [tf] TensorFlow graph API for building operations. */ private fun build ( tf : Ops ) : Placeholder < Float > /** * Extend this function to define placeholder in layer. * * NOTE: Called instead of [Layer.build]. * * @param [tf] TensorFlow graph API for building operations. */ private fun build ( tf : Ops ) : Placeholder < Float > /** * Extend this function to define placeholder in layer. * * NOTE: Called instead of [Layer.build]. * * @param [tf] TensorFlow graph API for building operations. */ private fun build ( tf : Ops ) : Placeholder < Float > /** * Extend this function to define placeholder in layer. * * NOTE: Called instead of [Layer.build]. * * @param [tf] TensorFlow graph API for building operations. */ private fun build ( tf : Ops ) : Placeholder
{ if ( classId.startsWith("org/") ) { return classId.substring( classId.lastIndexOf("/") + 1 ); } else { return classId; } } /** * @param classId the name of the class in the format: "org/foo/bar/Test.Inner" */ mapClass ( classId : String ) : String ik { if ( classId.startsWith("org/") ) { return classId.substring( classId.lastIndexOf("/") + 1 ); } else { return classId; } } /** * @param classId the name of the class in the format: "org/foo/bar/Test.Inner" */ ik ( classId : String ) : String ik { if ( classId.startsWith("org/") ) { return classId.substring( classId.lastIndexOf("/") + 1 ); } else { return classId; } } /** * @
{ if ( containerClassId == null ) { containerClassId = this.containerClassId } if ( containerClassId == null ) { containerClassId = this.containerClassId } if ( containerClassId == null ) { containerClassId = this.containerClassId } if ( containerClassId == null ) { containerClassId = this.containerClassId } if ( containerClassId == null ) { containerClassId = this.containerClassId } if ( containerClassId == null ) { containerClassId = this.containerClassId } if ( containerClassId == null ) { containerClassId = this.containerClassId } if ( containerClassId == null ) { containerClassId = this.containerClassId } if ( containerClassId == null ) { containerClassId = this.containerClassId } if ( containerClassId == null ) { containerClassId = this.containerClassId } if ( container
private fun Project . findProperty ( propertyName : String ) : Any ? /** * In case [Project.findProperty] can throw exception, this version catch it and return null */ /** * In case [Project.findProperty] can throw exception, this version catch it and return null */ /** * In case [Project.findProperty] can throw exception, this version catch it and return null */ /** * In case [Project.findProperty] can throw exception, this version catch it and return null */ /** * In case [Project.findProperty] can throw exception, this version catch it and return null */ /** * In case [Project.findProperty] can throw exception, this version catch it and return null */ /** * In case [Project.findProperty] can throw exception, this version catch it and return null */ /** * In case [Project.findProperty] can throw exception, this version catch it and return null */ /** * In case [Project.findProperty] can throw exception, this version catch it and return null */ /** * In case






* `test - launching after Lifecycle finished - will execute code right away` ( ) * `test - launching after Lifecycle finished - will execute code right away` ( ) * `test - launching after Lifecycle finished - will execute code right away` ( ) * `test - launching after Lifecycle finished - will execute code right away` ( ) * `test - launching after Lifecycle finished - will execute code right away` ( ) * `test - launching after Lifecycle finished - will execute code right away` ( ) * `test - launching after Lifecycle finished - will execute code right away` ( ) * `test - launching after Lifecycle finished - will execute code right away` ( ) * `test - launching after Lifecycle finished - will execute code right away` ( ) * `test - launching after Lifecycle finished - will execute code right away` ( ) * `test - launching after Lifecycle finished - will execute code right away` ( ) * `test - launching after Lifecycle finished - will execute code right away` ( ) * `test - launching after Lifecycle finished - will execute code right
{ val int1 = 1 val int2 = 2 val int3 = 3 val int4 = 4 val int5 = 5 val int6 = 6 val int7 = 7 val int8 = 8 val int9 = 9 val int10 = 10 val int11 = 11 val int12 = 12 val int13 = 13 val int14 = 14 val int15 = 15 val int16 = 16 val int17 = 17 val int18 = 18 val int19 = 19 val int20 = 20 val int21 = 21 val int22 = 22 val int23 = 23 val int24 = 24 val int25 = 25 val int26 = 26 val int27 = 27 val int28 = 28 val int29 = 29 val int30 = 30 val int31 = 31 val int32 = 32 val int33 = 33 val int34 = 34 val int35 = 35 val int36 = 36 val









fun ( vararg fields : String ) : void = { for ( var i = 0; i < fields.length; i++ ) { var field = fields[i]; if ( field.startsWith( "__" ) ) continue; if ( field.endsWith( "__" ) ) continue; if ( field.startsWith( "_" ) ) continue; if ( field.endsWith( "_" ) ) continue; if ( field.startsWith( "__" ) ) continue; if ( field.endsWith( "__" ) ) continue; if ( field.startsWith( "__" ) ) continue; if ( field.endsWith( "__" ) ) continue; if ( field.startsWith( "__" ) ) continue; if ( field.endsWith( "__" ) ) continue; if ( field.startsWith( "__" ) ) continue; if ( field.endsWith( "__" ) ) continue; if ( field.startsWith( "__" ) ) continue; if
fun ( vararg fields : String ) : void { if ( fields.length == 0 ) { return; } for ( var i = 0; i < fields.length; i++ ) { var field = fields[i]; if ( field.length == 0 ) { continue; } if ( field.startsWith( "*" ) ) { continue; } if ( field.startsWith( "/" ) ) { continue; } if ( field.startsWith( "+" ) ) { continue; } if ( field.startsWith( "-" ) ) { continue; } if ( field.startsWith( "%" ) ) { continue; } if ( field.startsWith( "^" ) ) { continue; } if ( field.startsWith( "&" ) ) { continue; } if ( field.startsWith( "=" ) ) { continue; }
* * @param field The name of the field. * @param value The value of the field. * @param withGetter If true, the getter method will be called. * * @return The default value of the field. */ public static String getDefault ( String field , String value , boolean withGetter = false ) { if ( withGetter ) { return getDefaultWithGetter ( field , value ) ; } else { return getDefaultWithoutGetter ( field , value ) ; } } /** * Specifies the default value of [field] in this implementation class. The default value can be arbitrary code. * * Use [additionalImports] if the default value uses types/functions that are not otherwise imported. */ public static String getDefaultWithoutGetter ( String field , String value ) { return value ; } /** * Specifies the default value of [field] in this implementation class. The default value can be arbitrary code. * * Use [additionalImports] if the default value uses type
val : Boolean = true; /** * Specifies that the default value of each field of [fields] in this implementation class should be `false`. * * If [withGetter] is `true`, the fields will be generated as getter-only computed properties with their getter returning `false`, * otherwise, as stored properties initialized to `false`. */ buzzfun defaultFalse ( vararg fields : String , withGetter : Boolean = false ) buzzval : Boolean = false; /** * Specifies that the default value of each field of [fields] in this implementation class should be `null`. * * If [withGetter] is `true`, the fields will be generated as getter-only computed properties with their getter returning `null`, * otherwise, as stored properties initialized to `null`. */ buzznull ( vararg fields : String , withGetter : Boolean = false ) buzzval : Boolean = null; /** * Specifies that the default value of each field of [fields] in this implementation class should be `null`. * * If [withGetter] is `true`, the fields will be generated as getter-
val : Boolean = false * * If [withSetter] is `true`, the fields will be generated as setter-only computed properties with their setter returning `false`, * otherwise, as stored properties initialized to `false`. */ /** * Specifies that the default value of each field of [fields] in this implementation class should be `true`. * * If [withGetter] is `true`, the fields will be generated as getter-only computed properties with their getter returning `true`, * otherwise, as stored properties initialized to `true`. */ /** * Specifies that the default value of each field of [fields] in this implementation class should be `true`. * * If [withSetter] is `true`, the fields will be generated as setter-only computed properties with their setter returning `true`, * otherwise, as stored properties initialized to `true`. */ /** * Specifies that the default value of each field of [fields] in this implementation class should be `false`. * * If [withGetter] is `true`, the fields will be generated as getter-only computed propertie
enames : String[] = [] * * @param vararg fields : String[] * @param withGetter : Boolean * * @return String[] */ public static String[] defaultNull ( vararg fields : String , withGetter : Boolean = false ) { String[] result = new String[fields.length]; for ( int i = 0 ; i < fields.length ; i++ ) { if ( withGetter ) { result[i] = null; } else { result[i] = fields[i]; } } return result; } /** * Specifies that the default value of each field of [fields] in this implementation class should be `null`. * * If [withGetter] is `true`, the fields will be generated as getter-only computed properties with their getter returning `null`, * otherwise, as stored properties initialized to `null`. * * @param vararg fields : String[] * @param withGetter : Boolean * * @return String[] */ public static
Getter : ( vararg fields : String , vararg fields2 : String , vararg fields3 : String , vararg fields4 : String , vararg fields5 : String , vararg fields6 : String , vararg fields7 : String , vararg fields8 : String , vararg fields9 : String , vararg fields10 : String , vararg fields11 : String , vararg fields12 : String , vararg fields13 : String , vararg fields14 : String , vararg fields15 : String , vararg fields16 : String , vararg fields17 : String , vararg fields18 : String , vararg fields19 : String , vararg fields20 : String , vararg fields21 : String , vararg fields22 : String , vararg fields23 : String , vararg fields24 : String , vararg fields25 : String , vararg fields26 : String , vararg fields27 : String , vararg fields28 : String , vararg fields29 : String , vararg fields30 : String , vararg fields31 : String , vararg fields32 : String , vararg fields33 : String , vararg fields34 : String , vararg fields35 : String , vararg fields36 : String , var
fun ( field : String , init : DefaultValueContext . ( ) -> Unit ) : Unit = if ( field == "" ) init else init /** * Allows to configure the default value of [field] in this implementation class. * * See the [DefaultValueContext] documentation for description of its DSL methods. */ /** * Allows to configure the default value of [field] in this implementation class. * * See the [DefaultValueContext] documentation for description of its DSL methods. */ /** * Allows to configure the default value of [field] in this implementation class. * * See the [DefaultValueContext] documentation for description of its DSL methods. */ /** * Allows to configure the default value of [field] in this implementation class. * * See the [DefaultValueContext] documentation for description of its DSL methods. */ /** * Allows to configure the default value of [field] in this implementation class. * * See the [DefaultValueContext] documentation for description of its DSL methods. */ /** * Allows to configure the default value of [field

fun ( ) = let internals = let internals = let internals = let internals = let internals = let internals = let internals = let internals = let internals = let internals = let internals = let internals = let internals = let internals = let internals = let internals = let internals = let internals = let internals = let internals = let internal
fun { return this; } /** * By default, all implementation classes are generated with `public` visibility. * * This method allows to forcibly make this implementation `private`. * * This method allows to forcibly make this implementation `protected`. * * This method allows to forcibly make this implementation `public`. * * This method allows to forcibly make this implementation `protected`. * * This method allows to forcibly make this implementation `private`. * * This method allows to forcibly make this implementation `public`. * * This method allows to forcibly make this implementation `protected`. * * This method allows to forcibly make this implementation `private`. * * This method allows to forcibly make this implementation `public`. * * This method allows to forcibly make this implementation `protected`. * * This method allows to forcibly make this implementation `private`. * * This method allows to forcibly make this implementation `public`. * * This method allows to forcibly make this implementation `protected`. * * This method allows to forcibly make this implementation `private`. * * This method allows to forcibly make this implementation `public`. *
imports ( vararg importables : Importable ) = { importables } /** * Types/functions that you want to additionally import in the file with the implementation class. * * This is useful if, for example, default values of fields reference classes or functions from other packages. * * Note that classes referenced in field types will be imported automatically. */ /** * Types/functions that you want to additionally import in the file with the implementation class. * * This is useful if, for example, default values of fields reference classes or functions from other packages. * * Note that classes referenced in field types will be imported automatically. */ /** * Types/functions that you want to additionally import in the file with the implementation class. * * This is useful if, for example, default values of fields reference classes or functions from other packages. * * Note that classes referenced in field types will be imported automatically. */ /** * Types/functions that you want to additionally import in the file with the implementation class. * * This is useful if, for example, default values of fields reference classes or


{ if ( superClass == this ) return true if ( superClass instanceof KtClassOrObjectSymbol ) return superClass.isSubClassOf ( this ) if ( superClass instanceof KtObjectSymbol ) return superClass.isSubClassOf ( this ) return false } /** * Checks if [this] class has [superClass] as its superclass somewhere in the inheritance hierarchy. * * N.B. The class is not considered to be a subclass of itself, so `myClass.isSubClassOf(myClass)` is always `false`. */ KtObjectSymbol . isSubClassOf ( superClass : KtObjectSymbol ) : Boolean /** * Checks if [this] class has [superClass] as its superclass somewhere in the inheritance hierarchy. * * N.B. The class is not considered to be a subclass of itself, so `myClass.isSubClassOf(myClass)` is always `false`. */ KtObjectSymbol . isSubClassOf ( superClass : KtObjectSymbol ) : Boolean /** * Checks if [
{ if ( superClass == this ) return true if ( superClass instanceof KtClassOrObjectSymbol ) return superClass.isDirectSubClassOf ( this ) return false } /** * Checks if [this] class has [superClass] listed as its direct superclass. * * N.B. The class is not considered to be a direct subclass of itself, so `myClass.isDirectSubClassOf(myClass)` is always `false`. */ KtClassOrObjectSymbol . isDirectSubClassOf ( superClass : KtClassOrObjectSymbol ) : Boolean /** * Checks if [this] class has [superClass] listed as its direct superclass. * * N.B. The class is not considered to be a direct subclass of itself, so `myClass.isDirectSubClassOf(myClass)` is always `false`. */ KtClassOrObjectSymbol . isDirectSubClassOf ( superClass : KtClassOrObjectSymbol ) : Boolean /** * Checks if [this] class has [superClass] listed as its direct superclass.


( valueCol ) : ColumnAccessor < C > { return this } /** * @include [ValueColReferenceDocs] {@set [CommonValueColDocs.ReceiverArg]} */ public fun < C > valueCol ( valueCol : ColumnAccessor < C > ) : ColumnAccessor < C > { return this } /** * @include [ValueColReferenceDocs] {@set [CommonValueColDocs.ReceiverArg]} */ public fun < C > valueCol ( valueCol : ColumnAccessor < C > ) : ColumnAccessor < C > { return this } /** * @include [ValueColReferenceDocs] {@set [CommonValueColDocs.ReceiverArg]} */ public fun < C > valueCol ( valueCol : ColumnAccessor < C > ) : ColumnAccessor < C > { return this } /** * @include [ValueColReferenceDocs] {@set [CommonValueColDocs.ReceiverArg]} */ public fun < C > valueCol ( valueCol : ColumnAccessor
{ if ( valueCol == null ) { throw IllegalArgumentException.ofType( IllegalArgumentException.class ) } else if ( valueCol.isNullable() ) { throw IllegalArgumentException.ofType( IllegalArgumentException.class ) } else if ( valueCol.isNotNullable() ) { throw IllegalArgumentException.ofType( IllegalArgumentException.class ) } else { throw IllegalArgumentException.ofType( IllegalArgumentException.class ) } } /** * @inherit [ValueColReferenceDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} */ /** * @inherit [ValueColReferenceDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} */ /** * @inherit [ValueColReferenceDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} */ /** * @inherit [ValueColReferenceDocs] {@set [CommonValueColDoc
( valueCol ) : AnyColumnGroupAccessor < C > { return this } /** * @include [ValueColReferenceDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} */ fun < C > AnyColumnGroupAccessor . valueCol ( valueCol : ColumnAccessor < C > ) : AnyColumnGroupAccessor < C > { return this } /** * @include [ValueColReferenceDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} */ fun < C > AnyColumnGroupAccessor . valueCol ( valueCol : ColumnAccessor < C > ) : AnyColumnGroupAccessor < C > { return this } /** * @include [ValueColReferenceDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} */ fun < C > AnyColumnGroupAccessor . valueCol ( valueCol : ColumnAccessor < C > ) : AnyColumnGroupAccessor < C > { return this } /** * @include [ValueColReferenceDocs]
( valueCol ) : ColumnAccessor < C > { return this } /** * @include [ValueColReferenceDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} */ fun < C > String . valueCol ( valueCol : ColumnAccessor < C > ) : ColumnAccessor < C > { return this } /** * @include [ValueColReferenceDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} */ fun < C > String . valueCol ( valueCol : ColumnAccessor < C > ) : ColumnAccessor < C > { return this } /** * @include [ValueColReferenceDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} */ fun < C > String . valueCol ( valueCol : ColumnAccessor < C > ) : ColumnAccessor < C > { return this } /** * @include [ValueColReferenceDocs] {@set [CommonValueColDocs.ReceiverArg]
( valueCol ) : ColumnAccessor < C > { return this } /** * @see [ValueColReferenceDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} */ kpublic fun < C > KProperty < * > . valueCol ( valueCol : ColumnAccessor < C > ) : ColumnAccessor < C > { return this } /** * @see [ValueColReferenceDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} */ kpublic fun < C > KProperty < * > . valueCol ( valueCol : ColumnAccessor < C > ) : ColumnAccessor < C > { return this } /** * @see [ValueColReferenceDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} */ kpublic fun < C > KProperty < * > . valueCol ( valueCol : ColumnAccessor < C > ) : ColumnAccessor < C > { return this } /** * @see [ValueColReferenceDoc
: ColumnAccessor < C > { if ( valueCol.isNullOrBlank() ) { return this } if ( valueCol.isNullOrBlank() ) { return this } if ( valueCol.isNullOrBlank() ) { return this } if ( valueCol.isNullOrBlank() ) { return this } if ( valueCol.isNullOrBlank() ) { return this } if ( valueCol.isNullOrBlank() ) { return this } if ( valueCol.isNullOrBlank() ) { return this } if ( valueCol.isNullOrBlank() ) { return this } if ( valueCol.isNullOrBlank() ) { return this } if ( valueCol.isNullOrBlank() ) { return this } if ( valueCol.isNullOrBlank() ) { return this } if ( valueCol
{@set [CommonValueColDocs.ReceiverArg]} {@set [CommonValueColDocs.ReceiverArg]} {@set [CommonValueColDocs.ReceiverArg]} {@set [CommonValueColDocs.ReceiverArg]} {@set [CommonValueColDocs.ReceiverArg]} {@set [CommonValueColDocs.ReceiverArg]} {@set [CommonValueColDocs.ReceiverArg]} {@set [CommonValueColDocs.ReceiverArg]} {@set [CommonValueColDocs.ReceiverArg]} {@set [CommonValueColDocs.ReceiverArg]} {@set [CommonValueColDocs.ReceiverArg]} {@set [CommonValueColDocs.ReceiverArg]} {@set [CommonValueColDocs.ReceiverArg]} {@set [CommonValueColDocs.ReceiverArg]} {@set [CommonValueColDocs.ReceiverArg]} {@set [CommonValueColDocs.ReceiverArg]} {@set [CommonValueColDocs.ReceiverArg]} {@set [CommonValueColDocs.ReceiverArg]} {@set [
( name : String ) : ColumnAccessor < C > { return this } /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg]} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > valueCol ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg]} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > valueCol ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg]} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > valueCol ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ValueColNameDocs] {@set [CommonValueCol
{ * * @param name The name of the column. * * @return The column. * */ public class SingleColumn < DataRow < * > > . valueCol ( name : String ) : SingleColumn < * > { * * @param name The name of the column. * * @return The column. * */ public class SingleColumn < DataRow < * > > . valueCol ( name : String ) : SingleColumn < * > { * * @param name The name of the column. * * @return The column. * */ public class SingleColumn < DataRow < * > > . valueCol ( name : String ) : SingleColumn < * > { * * @param name The name of the column. * * @return The column. * */ public class SingleColumn < DataRow < * > > . valueCol ( name : String ) : SingleColumn < * > { * * @param name The name of the column. * * @return The column. * */ public
( name : String ) : SingleColumn < C > { return this } /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [CommonValueColDocs.ValueColumnTypeParam] */ fun < C > SingleColumn < DataRow < * > > . valueCol ( name : String ) : SingleColumn < C > { return this } /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [CommonValueColDocs.ValueColumnTypeParam] */ fun < C > SingleColumn < DataRow < * > > . valueCol ( name : String ) : SingleColumn < C > { return this } /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [CommonValueColDocs.ValueColumnTypeParam] */ fun < C > SingleColumn < DataRow < * > > . valueCol (
( name : String ) : ColumnAccessor < * > * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
( name : String ) : ColumnAccessor < C > { return this } /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [CommonValueColDocs.ValueColumnTypeParam] */ fun < C > AnyColumnGroupAccessor . valueCol ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [CommonValueColDocs.ValueColumnTypeParam] */ fun < C > AnyColumnGroupAccessor . valueCol ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [CommonValueColDocs.ValueColumnTypeParam] */ fun < C > AnyColumnGroupAccessor . valueCol ( name : String ) : ColumnAccessor
{ return new ColumnAccessor < * > ( name : String ) { @Override public ColumnAccessor < * > ( name : String ) { return new ColumnAccessor < * > ( name : String ) { @Override public ColumnAccessor < * > ( name : String ) { return new ColumnAccessor < * > ( name : String ) { @Override public ColumnAccessor < * > ( name : String ) { return new ColumnAccessor < * > ( name : String ) { @Override public ColumnAccessor < * > ( name : String ) { return new ColumnAccessor < * > ( name : String ) { @Override public ColumnAccessor < * > ( name : String ) { return new ColumnAccessor < * > ( name : String ) { @Override public ColumnAccessor < * > ( name : String )
( name : String ) : ColumnAccessor < C > { return this } /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > String . valueCol ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > String . valueCol ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > String . valueCol ( name : String ) : ColumnAccessor < C > { return
( name : String ) : ColumnAccessor < * > * * @see [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @see [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @see [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @see [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @see [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @see [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @see [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @see [ValueColNameDocs] {@set [CommonValueColDocs.Receiver
( name : String ) : ColumnAccessor < C > { return this } /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [CommonValueColDocs.ValueColumnTypeParam] */ /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [CommonValueColDocs.ValueColumnTypeParam] */ /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [CommonValueColDocs.ValueColumnTypeParam] */ /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [CommonValueColDocs.ValueColumnTypeParam] */ /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] Type
( name : String ) : ColumnAccessor < * > * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
( name : String ) : ColumnAccessor < C > { return this } /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > ColumnPath . valueCol ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > ColumnPath . valueCol ( name : String ) : ColumnAccessor < C > { return this } /** * @include [ValueColNameDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > ColumnPath .
{@inherit CommonValueColDocs.ReceiverArg} {@inherit CommonValueColDocs.ReceiverArg} {@inherit CommonValueColDocs.ReceiverArg} {@inherit CommonValueColDocs.ReceiverArg} {@inherit CommonValueColDocs.ReceiverArg} {@inherit CommonValueColDocs.ReceiverArg} {@inherit CommonValueColDocs.ReceiverArg} {@inherit CommonValueColDocs.ReceiverArg} {@inherit CommonValueColDocs.ReceiverArg} {@inherit CommonValueColDocs.ReceiverArg} {@inherit CommonValueColDocs.ReceiverArg} {@inherit CommonValueColDocs.ReceiverArg} {@inherit CommonValueColDocs.ReceiverArg} {@inherit CommonValueColDocs.ReceiverArg} {@inherit CommonValueColDocs.ReceiverArg} {@inherit CommonValueColDocs.ReceiverArg} {@inherit CommonValueColDocs.ReceiverArg} {
: ColumnAccessor < C > { if ( path.isEmpty() ) { return this } else if ( path.isNullOrEmpty() ) { return null } else if ( path.isBlank() ) { return this } else if ( path.isBlankOrNull() ) { return null } else if ( path.isBlankOrNullOrEmpty() ) { return null } else if ( path.isBlankOrBlankOrNull() ) { return null } else if ( path.isBlankOrBlankOrBlankOrNull() ) { return null } else if ( path.isBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOr
{ * * @param path : ColumnPath * @return : SingleColumn */ public fun SingleColumn < DataRow < * > > . valueCol ( path : ColumnPath ) : SingleColumn < * > { if ( path == null ) throw new IllegalArgumentException () if ( path.isEmpty() ) throw new IllegalArgumentException () if ( path.isBlank() ) throw new IllegalArgumentException () if ( path.isBlank() ) throw new IllegalArgumentException () if ( path.isBlank() ) throw new IllegalArgumentException () if ( path.isBlank() ) throw new IllegalArgumentException () if ( path.isBlank() ) throw new IllegalArgumentException () if ( path.isBlank() ) throw new IllegalArgumentException () if ( path.isBlank() ) throw new IllegalArgumentException () if ( path.isBlank() ) throw new IllegalArgumentException () if ( path.isBlank() ) throw new IllegalArgumentException () if ( path.isBlank() )
( path : ColumnPath ) : SingleColumn < C > { if ( path.isEmpty() ) { return this } else if ( path.size() == 1 ) { return this } else if ( path.size() == 2 ) { return this } else if ( path.size() == 3 ) { return this } else if ( path.size() == 4 ) { return this } else if ( path.size() == 5 ) { return this } else if ( path.size() == 6 ) { return this } else if ( path.size() == 7 ) { return this } else if ( path.size() == 8 ) { return this } else if ( path.size() == 9 ) { return this } else if ( path.size() == 10 ) { return this } else if ( path.size() == 11 ) { return this } else if ( path.size() == 12 ) { return this } else if ( path.size() == 13
{ return new AnyColumnGroupAccessor< * > ( valueCol, path ); } /** * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] myColumn
{ if ( path.isEmpty() ) { return this } else if ( path.size() == 1 ) { return this } else if ( path.size() == 2 ) { return this } else if ( path.size() == 3 ) { return this } else if ( path.size() == 4 ) { return this } else if ( path.size() == 5 ) { return this } else if ( path.size() == 6 ) { return this } else if ( path.size() == 7 ) { return this } else if ( path.size() == 8 ) { return this } else if ( path.size() == 9 ) { return this } else if ( path.size() == 10 ) { return this } else if ( path.size() == 11 ) { return this } else if ( path.size() == 12 ) { return this } else if ( path.size() == 13 ) { return this } else if (
{ if ( path == null ) throw new IllegalArgumentException ( "path is null" ) ; if ( path.isEmpty() ) throw new IllegalArgumentException ( "path is empty" ) ; if ( path.isBlank() ) throw new IllegalArgumentException ( "path is blank" ) ; if ( path.contains ( "*" ) ) throw new IllegalArgumentException ( "path contains *" ) ; if ( path.contains ( "**" ) ) throw new IllegalArgumentException ( "path contains **" ) ; if ( path.contains ( "***" ) ) throw new IllegalArgumentException ( "path contains ***" ) ; if ( path.contains ( "****" ) ) throw new IllegalArgumentException ( "path contains ****" ) ; if ( path.contains ( "*****" ) ) throw new IllegalArgumentException ( "path contains *****" ) ; if ( path.contains ( "******" ) ) throw new IllegalArgumentException ( "path contains ******" ) ; if ( path.contains ( "********
( path : ColumnPath ) : ColumnAccessor < C > { return this } /** * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > String . valueCol ( path : ColumnPath ) : ColumnAccessor < C > { return this } /** * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > String . valueCol ( path : ColumnPath ) : ColumnAccessor < C > { return this } /** * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > String . valueCol ( path : ColumnPath ) : ColumnAccessor < C
{ return this.valueCol ( path ); } /** * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ValueColPathDocs] {@set [CommonValueColDocs.
( path : ColumnPath ) : ColumnAccessor < C > { if ( path.isEmpty() ) { return this } else if ( path.isNullOrEmpty() ) { return null } else if ( path.isNullOrBlank() ) { return this } else if ( path.isBlank() ) { return this } else if ( path.isBlankOrNull() ) { return this } else if ( path.isBlankOrBlankOrNull() ) { return this } else if ( path.isBlankOrBlankOrBlankOrNull() ) { return this } else if ( path.isBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlankOrBlank
{ return new ColumnAccessor< * > ( this, path ); } /** * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ValueColPathDocs] {@set [CommonValue
( path : ColumnPath ) : ColumnAccessor < C > { return this } /** * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > ColumnPath . valueCol ( path : ColumnPath ) : ColumnAccessor < C > { return this } /** * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > ColumnPath . valueCol ( path : ColumnPath ) : ColumnAccessor < C > { return this } /** * @include [ValueColPathDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C
< C > { /** * @param property * @return */ private fun < C > valueCol ( property : KProperty < C > ) : SingleColumn < C > { if ( property.isNullOrEmpty() ) { return SingleColumn.empty() } else if ( property.isNullOrBlank() ) { return SingleColumn.blank() } else { return SingleColumn( property.get() ) } } } /** * @param property * @return */ private fun < C > valueCol ( property : KProperty < C > ) : SingleColumn < C > { if ( property.isNullOrEmpty() ) { return SingleColumn.empty() } else if ( property.isNullOrBlank() ) { return SingleColumn.blank() } else { return SingleColumn( property.get() ) } } /** * @param property * @return */ private fun < C > valueCol ( property : KProperty < C > ) : SingleColumn < C
{ return SingleColumn<C>(this, property) } /** * @include [ValueColKPropertyDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} */ kpublic fun < C > SingleColumn < DataRow < * > > . valueCol ( property : KProperty < C > ) : kSingleColumn < C > { return kSingleColumn<C>(this, property) } /** * @include [ValueColKPropertyDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} */ kpublic fun < C > SingleColumn < DataRow < * > > . valueCol ( property : KProperty < C > ) : kSingleColumn < C > { return kSingleColumn<C>(this, property) } /** * @include [ValueColKPropertyDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} */ kpublic fun < C > SingleColumn < DataRow < * > > . valueCol ( property : KProperty < C > ) : kSingleColumn < C > {
{ return ColumnAccessor<C>(this, property) } /** * @include [ValueColKPropertyDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} */ kpublic fun < C > AnyColumnGroupAccessor . valueCol ( property : KProperty < C > ) : ColumnAccessor < C > kprivate { return ColumnAccessor<C>(this, property) } /** * @include [ValueColKPropertyDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} */ kpublic fun < C > AnyColumnGroupAccessor . valueCol ( property : KProperty < C > ) : ColumnAccessor < C > kprivate { return ColumnAccessor<C>(this, property) } /** * @include [ValueColKPropertyDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} */ kpublic fun < C > AnyColumnGroupAccessor . valueCol ( property : KProperty < C > ) : ColumnAccessor < C > kprivate { return ColumnAccessor
{ return ColumnAccessor<C>(this, property) } /** * @include [ValueColKPropertyDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} */ kpublic fun < C > String . valueCol ( property : KProperty < C > ) : ColumnAccessorK<C> { return ColumnAccessorK<C>(this, property) } /** * @include [ValueColKPropertyDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} */ kpublic fun < C > String . valueCol ( property : KProperty < C > ) : ColumnAccessorK<C> { return ColumnAccessorK<C>(this, property) } /** * @include [ValueColKPropertyDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} */ kpublic fun < C > String . valueCol ( property : KProperty < C > ) : ColumnAccessorK<C> { return ColumnAccessorK<C>(this, property
: ColumnAccessor < C > { @Override public ColumnAccessor < C > get ( value : C ) : ColumnAccessor < C > { @Override public ColumnAccessor < C > get ( value : C ) : ColumnAccessor < C > { @Override public ColumnAccessor < C > get ( value : C ) : ColumnAccessor < C > { @Override public ColumnAccessor < C > get ( value : C ) : ColumnAccessor < C > { @Override public ColumnAccessor < C > get ( value : C ) : ColumnAccessor < C > { @Override public ColumnAccessor < C > get ( value : C ) : ColumnAccessor < C > { @Override public ColumnAccessor < C > get ( value : C ) : ColumnAccessor < C > { @Override public ColumnAccessor < C > get ( value : C ) : ColumnAccessor < C > { @Override public ColumnAccessor < C > get ( value : C ) : ColumnAccessor < C > {
< C > { return ColumnAccessor<C>(this, property) } /** * @include [ValueColKPropertyDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ValueColKPropertyDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ValueColKPropertyDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ValueColKPropertyDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ValueColKPropertyDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ValueColKPropertyDocs] {@set [CommonValueColDocs.ReceiverArg] "pathTo"["myColumnGroup"].} * @include [ValueColKPropertyDocs]

@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppress ( " ix" ) ix@ Suppre
{ if ( index < 0 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 0 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 0 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 0 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 0 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 0 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 0 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 0 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 0 ) { throw new IndexOutOfBoundsException( index ) } if ( index < 0 ) { throw new IndexOutOfBoundsException( index ) } if ( index
{ if ( index < 0 ) { throw new IllegalArgumentException ( "index must be non-negative" ); } if ( index >= this.valueCol.size ) { throw new IllegalArgumentException ( "index out of bounds" ); } return this.valueCol.get ( index ); } /** * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.}
{ if ( index < 0 || index >= this.size ) throw new IndexOutOfBoundsException() return this[ index ] } /** * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > SingleColumn < DataRow < * > > . valueCol ( index : Int ) : SingleColumn < C > { if ( index < 0 || index >= this.size ) throw new IndexOutOfBoundsException() return this[ index ] } /** * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] myColumnGroup.} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > SingleColumn < DataRow < * > > . valueCol ( index : Int ) : SingleColumn < C > { if ( index < 0 || index >= this.size ) throw new IndexOutOfBoundsException() return this[ index ]
{ if ( index < 0 ) { throw new IllegalArgumentException ( "index must be non-negative" ); } if ( index >= this.valueCol.size ) { throw new IllegalArgumentException ( "index out of bounds" ); } return this.valueCol.get ( index ); } /** * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} * @include [ValueColIndexDocs] {@set [CommonValueColDoc
{ if ( index < 0 || index >= this.size ) { throw new IndexOutOfBoundsException() } else { return this[index] } } /** * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > String . valueCol ( index : Int ) : SingleColumn < C > { if ( index < 0 || index >= this.size ) { throw new IndexOutOfBoundsException() } else { return this[index] } } /** * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] "myColumnGroup".} * @include [CommonValueColDocs.ValueColumnTypeParam] */ public fun < C > String . valueCol ( index : Int ) : SingleColumn < C > { if ( index < 0 || index >= this.size ) { throw new IndexOut
{ if ( index < 0 ) { throw new IndexOutOfBoundsException (); } if ( index >= this.valueCol.size ) { throw new IndexOutOfBoundsException (); } return this.valueCol.get ( index ); } /** * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.}
{ if ( index < 0 ) { throw new IndexOutOfBoundsException() } else if ( index >= this.size ) { throw new IndexOutOfBoundsException() } else { return this[index] } } /** * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [CommonValueColDocs.ValueColumnTypeParam] */ kpublic fun < C > KProperty < * > . valueCol ( index : Int ) : SingleColumn < C > { if ( index < 0 ) { throw new IndexOutOfBoundsException() } else if ( index >= this.size ) { throw new IndexOutOfBoundsException() } else { return this[index] } } /** * @include [ValueColIndexDocs] {@set [CommonValueColDocs.ReceiverArg] Type::myColumnGroup.} * @include [CommonValueColDocs.ValueColumnTypeParam] */ kpublic fun
{ if ( index < 0 ) { throw new IllegalArgumentException ( "Index must be non-negative" ); } if ( index < 0 ) { throw new IllegalArgumentException ( "Index must be non-negative" ); } if ( index < 0 ) { throw new IllegalArgumentException ( "Index must be non-negative" ); } if ( index < 0 ) { throw new IllegalArgumentException ( "Index must be non-negative" ); } if ( index < 0 ) { throw new IllegalArgumentException ( "Index must be non-negative" ); } if ( index < 0 ) { throw new IllegalArgumentException ( "Index must be non-negative" ); } if ( index < 0 ) { throw new IllegalArgumentException ( "Index must be non-negative" ); } if ( index < 0 ) { throw new IllegalArgumentException ( "Index must be non-negative" ); } if ( index < 0 ) { throw new IllegalArg
( index : Int ) : C { if ( index < 0 ) { throw new IndexOutOfBoundsException () } if ( index < 1 ) { throw new IndexOutOfBoundsException () } if ( index < 2 ) { throw new IndexOutOfBoundsException () } if ( index < 3 ) { throw new IndexOutOfBoundsException () } if ( index < 4 ) { throw new IndexOutOfBoundsException () } if ( index < 5 ) { throw new IndexOutOfBoundsException () } if ( index < 6 ) { throw new IndexOutOfBoundsException () } if ( index < 7 ) { throw new IndexOutOfBoundsException () } if ( index < 8 ) { throw new IndexOutOfBoundsException () } if ( index < 9 ) { throw new IndexOutOfBoundsException () } if ( index < 10 ) { throw new IndexOutOfBound
( ) : SingleColumn < C > { if ( ! isColumn ( ) ) { throw new IllegalArgumentException ( "This is not a value column" ); } return this; } /** * Checks the validity of this [ValueColumn], * by adding a check to see it's a [SingleColumn] (so, a [ValueColumn]<*>) * and throwing an [IllegalArgumentException] if it's not. */ fun < C > ValueColumn < C > . ensureIsSingleColumn ( ) : ValueColumn < C > { if ( ! isColumn ( ) ) { throw new IllegalArgumentException ( "This is not a single column" ); } return this; } /** * Checks the validity of this [SingleColumn], * by adding a check to see it's a [ValueColumn] (so, a [SingleColumn]<*>) * and throwing an [IllegalArgumentException] if it's not. */ fun < C > SingleColumn < C > . ensureIsValueColumn ( ) : SingleColumn < C > { if
( ) { ColumnAccessor < C > . ensureIsValueColumn ( ) : ColumnAccessor < C > . ensureIsValueColumn ( ) : ColumnAccessor < C > . ensureIsValueColumn ( ) : ColumnAccessor < C > . ensureIsValueColumn ( ) : ColumnAccessor < C > . ensureIsValueColumn ( ) : ColumnAccessor < C > . ensureIsValueColumn ( ) : ColumnAccessor < C > . ensureIsValueColumn ( ) : ColumnAccessor < C > . ensureIsValueColumn ( ) : ColumnAccessor < C > . ensureIsValueColumn ( ) : ColumnAccessor < C > . ensureIsValueColumn ( ) : ColumnAccessor < C > . ensureIsValueColumn ( ) : ColumnAccessor < C > . ensureIsValueColumn ( ) : ColumnAccessor < C > . ensureIsValueColumn ( ) : ColumnAccessor < C > . ensureIsValueColumn ( ) : ColumnAccessor < C > . ensureIsValueColumn ( ) : ColumnAccessor < C > . ensureIsValueColumn ( ) : ColumnAccessor < C > . ensureIsValueColumn ( ) : ColumnAccessor < C > . ensureIsValueColumn

fun ( classNode : ClassNode ) * * @param classNode The class node to sort. * * @return The sorted class node. */ public static ClassNode sortClassMembers ( ClassNode classNode ) { ClassNode sortedClassNode = new ClassNode(); sortedClassNode.className = classNode.className; sortedClassNode.classFile = classNode.classFile; sortedClassNode.classFileName = classNode.classFileName; sortedClassNode.classNode = classNode.classNode; sortedClassNode.classNodeName = classNode.classNodeName; sortedClassNode.classNodeFile = classNode.classNodeFile; sortedClassNode.classNodeFileName = classNode.classNodeFileName; sortedClassNode.classMethod = classNode.classMethod; sortedClassNode.classMethodName = classNode.classMethodName; sortedClassNode.classMethodFile = classNode.classMethodFile; sortedClassNode.classMethodFileName = classNode.classMethodFileName


k ( k : Any ) { if ( file == null ) { return k; } if ( k == null ) { return file; } if ( file.isDirectory ( ) ) { return klibFile ( file.getAbsolutePath ( ) ); } if ( k.isDirectory ( ) ) { return klibFile ( file.getAbsolutePath ( ) ); } if ( file.isFile ( ) ) { return klibFile ( file.getAbsolutePath ( ) ); } if ( k.isFile ( ) ) { return klibFile ( file.getAbsolutePath ( ) ); } if ( file.isSymlink ( ) ) { return klibFile ( file.getAbsolutePath ( ) ); } if ( k.isSymlink ( ) ) { return klibFile ( file.getAbsolutePath ( ) ); } if ( file.isBlank ( ) ) { return klibFile ( file.getAbsolute
k ( klib : KonanLibrary ) { if ( klib == NULL ) { return NULL; } if ( klib == NULL ) { return NULL; } if ( klib == NULL ) { return NULL; } if ( klib == NULL ) { return NULL; } if ( klib == NULL ) { return NULL; } if ( klib == NULL ) { return NULL; } if ( klib == NULL ) { return NULL; } if ( klib == NULL ) { return NULL; } if ( klib == NULL ) { return NULL; } if ( klib == NULL ) { return NULL; } if ( klib == NULL ) { return NULL; } if ( klib == NULL ) { return NULL; } if ( klib == NULL ) { return NULL; } if ( klib == NULL ) {
( lib : KonanInteropLibrary ) { if ( lib == NULL ) { fprintf ( stderr, "Failed to open %s\n", lib ); exit ( EXIT_FAILURE ); } if ( klib == NULL ) { fprintf ( stderr, "Failed to open %s\n", klib ); exit ( EXIT_FAILURE ); } if ( kfun == NULL ) { fprintf ( stderr, "Failed to open %s\n", kfun ); exit ( EXIT_FAILURE ); } if ( klib == NULL ) { fprintf ( stderr, "Failed to open %s\n", klib ); exit ( EXIT_FAILURE ); } if ( kfun == NULL ) { fprintf ( stderr, "Failed to open %s\n", kfun ); exit ( EXIT_FAILURE ); } if ( klib
( libraryProject : Project , name : String , friend : Boolean ) { if ( !friend ) { if ( !libraryProject.artifacts.contains( artifact ) ) { libraryProject.artifacts.add( artifact ); } } else { if ( !libraryProject.artifacts.contains( artifact ) ) { libraryProject.artifacts.add( artifact ); libraryProject.artifacts.add( friend ); } } return libraryProject.artifacts.contains( artifact ); } /** Returns the number of artifacts in the specified project by name */ public int getNumberOfArtifacts( libraryProject : Project , name : String ) { if ( !libraryProject.artifacts.contains( name ) ) { return 0; } else { return libraryProject.artifacts.size( name ); } } /** Returns the total number of artifacts in the specified project */ public int getTotalNumberOfArtifacts( libraryProject : Project ) { return
( name : String , friend : Boolean ) { if ( friend ) { if ( name == "" ) { throw new IllegalArgumentException( "Missing artifact name" ); } else if ( name.length() == 0 ) { throw new IllegalArgumentException( "Missing artifact name" ); } } else { if ( name == "" ) { throw new IllegalArgumentException( "Missing artifact name" ); } else if ( name.length() == 0 ) { throw new IllegalArgumentException( "Missing artifact name" ); } } return this.artifacts.get( name ); } /** Returns the number of artifacts in the current project */ public int getNumberOfArtifacts() { return this.artifacts.size(); } /** Returns the total number of artifacts in the current project */ public int getTotalNumberOfArtifacts() { return this.artifacts.size(); } /** Returns the number of
{ if ( !isKonanLibrary(artifact) ) return nil; if ( !isKonanLibrary(artifact) ) return nil; if ( !isKonanLibrary(artifact) ) return nil; if ( !isKonanLibrary(artifact) ) return nil; if ( !isKonanLibrary(artifact) ) return nil; if ( !isKonanLibrary(artifact) ) return nil; if ( !isKonanLibrary(artifact) ) return nil; if ( !isKonanLibrary(artifact) ) return nil; if ( !isKonanLibrary(artifact) ) return nil; if ( !isKonanLibrary(artifact) ) return nil; if ( !isKonanLibrary(artifact) ) return nil; if ( !isKonanLibrary(artifact) ) return nil; if ( !isKonanLibrary(artifact) )
{ if ( !isinstance ( artifact, konan.artifact.KonanInteropLibrary ) ) { return false; } var config = artifact.config; if ( !config ) { return false; } if ( !config.config ) { return false; } if ( !config.config.config ) { return false; } if ( !config.config.config.config ) { return false; } if ( !config.config.config.config.config ) { return false; } if ( !config.config.config.config.config.config.config ) { return false; } if ( !config.config.config.config.config.config.config.config.config ) { return false; } if ( !config.config.config.config.config.config.config.config.config.config.config ) { return false
fun allLibrariesFrom ( vararg libraryProjects : Project ) { if ( libraryProjects == null || libraryProjects.length == 0 ) { return null; } if ( libraryProjects.length == 1 ) { return libraryProjects[0]; } if ( libraryProjects.length == 2 ) { var library1 = libraryProjects[0]; var library2 = libraryProjects[1]; if ( library1 == null ) { return library2; } if ( library2 == null ) { return library1; } return library1; } if ( libraryProjects.length == 3 ) { var library1 = libraryProjects[0]; var library2 = libraryProjects[1]; var library3 = libraryProjects[2]; if ( library1 == null ) { return library2; } if ( library2 == null ) { return library3;
fun allInteropLibrariesFrom ( vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project, vararg libraryProjects : Project,


() { for ( child in this.children ) { child.clear ( ) } this.children = [] } /** Returns the number of children of this node. */ fun size () = this.children.size ( ) } /** Returns the number of children of this node. */ fun size () = this.children.size ( ) /** Returns the number of children of this node. */ fun size () = this.children.size ( ) /** Returns the number of children of this node. */ fun size () = this.children.size ( ) /** Returns the number of children of this node. */ fun size () = this.children.size ( ) /** Returns the number of children of this node. */ fun size () = this.children.size ( ) /** Returns the number of children of this node. */ fun size () = this.children.size ( ) /** Returns the number of children of this node. */ fun size () = this.children.size ( ) /** Returns the number of children of this node. */ fun size () = this.
*/ public fun Element.appendText ( text : String ) : Element { if ( this.isEmpty() ) { this.text = text } else { this.text += "\n" + text } return this } /** * Creates text node and append it to the element. * * @return this element */ public fun Element.appendText ( text : String ) : Element { if ( this.isEmpty() ) { this.text = text } else { this.text += "\n" + text } return this } /** * Creates text node and append it to the element. * * @return this element */ public fun Element.appendText ( text : String ) : Element { if ( this.isEmpty() ) { this.text = text } else { this.text += "\n" + text } return this } /**
Internal = fun ( config : DokkaBuildProperties . ( ) -> Unit ) -> fun ( config : DokkaBuildProperties . ( ) -> Unit ) -> fun ( config : DokkaBuildProperties . ( ) -> Unit ) -> fun ( config : DokkaBuildProperties . ( ) -> Unit ) -> fun ( config : DokkaBuildProperties . ( ) -> Unit ) -> fun ( config : DokkaBuildProperties . ( ) -> Unit ) -> fun ( config : DokkaBuildProperties . ( ) -> Unit ) -> fun ( config : DokkaBuildProperties . ( ) -> Unit ) -> fun ( config : DokkaBuildProperties . ( ) -> Unit ) -> fun ( config : DokkaBuildProperties . ( ) -> Unit ) -> fun ( config : DokkaBuildProperties . ( ) -> Unit ) -> fun ( config : DokkaBuildProperties . ( ) -> Unit ) -> fun ( config : DokkaBuildProperties . ( ) -> Unit ) ->
{ var superclassesWithKind : Map < DRI , SuperclassesWithKind > = new HashMap<DRI , SuperclassesWithKind>() { @Override public void put ( DRI key , SuperclassesWithKind value ) { superclassesWithKind.put ( key , value ) } } var superclassesWithKind : Map < DRI , SuperclassesWithKind > = new HashMap<DRI , SuperclassesWithKind>() { @Override public void put ( DRI key , SuperclassesWithKind value ) { superclassesWithKind.put ( key , value ) } } var superclassesWithKind : Map < DRI , SuperclassesWithKind > = new HashMap<DRI , SuperclassesWithKind>() { @Override public void put ( DRI key , SuperclassesWithKind value ) { superclassesWithKind.put ( key , value ) } } var superclassesWithKind : Map < DRI , SuperclassesWithKind > = new HashMap
private fun String . cleanContentPreservingLinesLayout ( start : Int = 0 , end : Int = this . length ) : String { if ( start < 0 || end > this . length ) { throw new IllegalArgumentException () } if ( start > end ) { throw new IllegalArgumentException () } if ( start < 0 ) { throw new IllegalArgumentException () } if ( end > this . length ) { throw new IllegalArgumentException () } if ( start > end ) { throw new IllegalArgumentException () } if ( start < 0 ) { throw new IllegalArgumentException () } if ( end > this . length ) { throw new IllegalArgumentException () } if ( start > end ) { throw new IllegalArgumentException () } if ( start < 0 ) { throw new IllegalArgumentException () } if ( end > this . length ) { throw new IllegalArgumentException () } if ( start
* * @param file The file to convert * * @return The converted SourceCode */ SourceCode -> SourceCode * * @return The converted SourceCode */ SourceCode -> SourceCode * * @return The converted SourceCode */ SourceCode -> SourceCode * * @return The converted SourceCode */ SourceCode -> SourceCode * * @return The converted SourceCode */ SourceCode -> SourceCode * * @return The converted SourceCode */ SourceCode -> SourceCode * * @return The converted SourceCode */ SourceCode -> SourceCode * * @return The converted SourceCode */ SourceCode -> SourceCode * * @return The converted SourceCode */ SourceCode -> SourceCode * * @return The converted SourceCode */ SourceCode -> SourceCode * * @return The converted SourceCode */ SourceCode -> SourceCode * * @return The converted SourceCode */ SourceCode -> SourceCode * * @return The converted SourceCode */ SourceCode -> SourceCode * * @return The converted SourceCode */ SourceCode -> SourceCode * * @return The
* * @param name * @return */ public static SourceCode toScriptSource ( String name : String ? = null ) : SourceCode { if ( name == null ) { return new SourceCode (); } else { return new SourceCode ( name ); } } /** * Converts the SourceCode into the String */ SourceCode . toScriptSource ( name : String ? = null ) : String * * @param name * @return */ public static String toScriptSource ( SourceCode name : SourceCode ? = null ) : String { if ( name == null ) { return null; } else { return name.toString (); } } /** * Converts the SourceCode into the SourceCode */ SourceCode . toSourceCode ( name : SourceCode ? = null ) : SourceCode * * @param name * @return */ public static SourceCode toSourceCode ( SourceCode name : SourceCode ? = null ) : SourceCode { if ( name
public fun < I > Operation < I , FloatData > . normalize ( block : Normalizing . ( ) -> Unit ) : Operation < I , FloatData > /** Applies [Normalizing] postprocessor to the tensor to normalize it with given mean and std values. */ /** Applies [Normalizing] postprocessor to the tensor to normalize it with given mean and std values. */ /** Applies [Normalizing] postprocessor to the tensor to normalize it with given mean and std values. */ /** Applies [Normalizing] postprocessor to the tensor to normalize it with given mean and std values. */ /** Applies [Normalizing] postprocessor to the tensor to normalize it with given mean and std values. */ /** Applies [Normalizing] postprocessor to the tensor to normalize it with given mean and std values. */ /** Applies [Normalizing] postprocessor to the tensor to normalize it with given mean and std values. */ /** Applies [Normalizing] postprocessor to the tensor to normalize it with given mean and std values. */ /** Applies [Normalizing] postprocessor to the
public fun < I > Operation < I , FloatData > . rescale ( block : Rescaling . ( ) -> Unit ) : Operation < I , FloatData > /** Applies [Rescaling] postprocessor to the tensor to scale each value by a given coefficient. */ /** Applies [Rescaling] postprocessor to the tensor to scale each value by a given coefficient. */ /** Applies [Rescaling] postprocessor to the tensor to scale each value by a given coefficient. */ /** Applies [Rescaling] postprocessor to the tensor to scale each value by a given coefficient. */ /** Applies [Rescaling] postprocessor to the tensor to scale each value by a given coefficient. */ /** Applies [Rescaling] postprocessor to the tensor to scale each value by a given coefficient. */ /** Applies [Rescaling] postprocessor to the tensor to scale each value by a given coefficient. */ /** Applies [Rescaling] postprocessor to the tensor to scale each value by a given coefficient. */ /** Applies [Rescaling] postprocessor
{ if ( blockResult.isSuccess() ) { throw new exceptionClass ( message , blockResult ) ; } else { throw new exceptionClass ( message , blockResult ) ; } } /** Asserts that a [blockResult] is a success with the specific exception type being thrown. */ blockResult : Result < Unit > /** Asserts that a [blockResult] is a failure with the specific exception type being thrown. */ blockResult : Result < Unit > /** Asserts that a [blockResult] is a success with the specific exception type being thrown. */ blockResult : Result < Unit > /** Asserts that a [blockResult] is a failure with the specific exception type being thrown. */ blockResult : Result < Unit > /** Asserts that a [blockResult] is a success with the specific exception type being thrown. */ blockResult : Result < Unit > /** Asserts that a [blockResult] is a failure with the specific exception type being thrown. */ blockResult : Result < Unit > /** Asserts that a [blockResult] is a success with the specific exception
@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . H
@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . HIDDEN ) x@ Deprecated ( " x" , level = DeprecationLevel . H
{ if ( ! block () ) { throw new AssertionFailedException () ; } else { throw new AssertionFailedException () ; } } /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @suppress */ var /** @
@ Deprecated ( " . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
@ Suppress ( " irl" ) irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly irl @ InlineOnly
: Array < StackTraceElement > = Array < StackTraceElement > () : Array < StackTraceElement > = Array < StackTraceElement > () : Array < StackTraceElement > = Array < StackTraceElement > () : Array < StackTraceElement > = Array < StackTraceElement > () : Array < StackTraceElement > = Array < StackTraceElement > () : Array < StackTraceElement > = Array < StackTraceElement > () : Array < StackTraceElement > = Array < StackTraceElement > () : Array < StackTraceElement > = Array < StackTraceElement > () : Array < StackTraceElement > = Array < StackTraceElement > () : Array < StackTraceElement > = Array < StackTraceElement > () : Array < StackTraceElement > = Array < StackTraceElement > () : Array < StackTraceElement > = Array < StackTraceElement > () : Array < StackTraceElement > = Array < StackTraceElement > () : Array < StackTraceElement > = Array < StackTraceElement > () : Array < StackTraceElement > = Array < StackTraceElement > () :
( message : String ? , cause : Throwable ? ) : AssertionError ( message : String ? , cause : Throwable ? ) : AssertionError ( message : String ? , cause : Throwable ? ) : AssertionError ( message : String ? , cause : Throwable ? ) : AssertionError ( message : String ? , cause : Throwable ? ) : AssertionError ( message : String ? , cause : Throwable ? ) : AssertionError ( message : String ? , cause : Throwable ? ) : AssertionError ( message : String ? , cause : Throwable ? ) : AssertionError ( message : String ? , cause : Throwable ? ) : AssertionError ( message : String ? , cause : Throwable ? ) : AssertionError ( message : String ? , cause : Throwable ? ) : AssertionError ( message : String ? , cause : Throwable ? ) : AssertionError ( message : String ? , cause : Throwable ? ) : AssertionError ( message : String ? , cause : Throwable ? ) : AssertionError ( message : String ? , cause : Throwable ? ) : AssertionError (
: IrValueDeclaration * * @param original * @param replacement * @return */ public IrValueDeclaration registerReplacement ( IrValueDeclaration original , IrValueDeclaration replacement ) { if ( original == null ) { return replacement; } else if ( replacement == null ) { return original; } else { return new IrValueDeclaration ( original , replacement ); } } /** * Registers one-to-many replacement */ public IrValueDeclaration registerManyReplacement ( IrValueDeclaration original , IrValueDeclaration replacement ) { if ( original == null ) { return replacement; } else if ( replacement == null ) { return original; } else { return new IrValueDeclaration ( original , replacement ); } } /** * Registers many-to-one replacement */ public IrValueDeclaration registerManyReplacement ( IrValueDeclaration original , IrValueDeclaration replacement ) { if
: IrValueDeclarationMfvcNodeInstance { if ( original == null ) { return replacement; } else if ( replacement == null ) { return original; } else { return new IrValueDeclarationMfvcNodeInstance ( original , replacement ); } } /** * Registers replacement of a complex expression with flattened MFVC instance */ fun registerReplacement ( original : IrValueDeclarationMfvcNodeInstance , replacement : ValueDeclarationMfvcNodeInstance ) : IrValueDeclarationMfvcNodeInstance { if ( original == null ) { return replacement; } else if ( replacement == null ) { return original; } else { return new IrValueDeclarationMfvcNodeInstance ( original , replacement ); } } /** * Registers replacement of a complex expression with flattened MFVC instance */ fun registerReplacement ( original : IrValueDeclarationMfvcNodeInstance , replacement : ValueDeclarationMfvcNodeInstance ) : IrValueDeclarationMfvcNodeInstance { if ( original == null ) {
FlattenedExpressionsWithGivenSafety ( node : MfvcNode , safe : Boolean , expression : IrExpression ) : List<MfvcNode> { if ( safe ) { return listOf<MfvcNode>() } else { return listOf<MfvcNode>() } } /** * @param safe whether protect from partial (because of a potential exception) initialization or not */ fun IrBlockBuilder . makeFlattenedExpressionsWithGivenSafety ( node : MfvcNode , safe : Boolean , expression : IrExpression ) : List<MfvcNode> { if ( safe ) { return listOf<MfvcNode>() } else { return listOf<MfvcNode>() } } /** * @param safe whether protect from partial (because of a potential exception) initialization or not */ fun IrBlockBuilder . makeFlattenedExpressionsWithGivenSafety ( node : MfvcNode , safe : Boolean , expression : IrExpression ) : List<MfvcNode

| expression = [ expression ] | otherwise = expression : (flattenExpression expression) /** * Takes not transformed expression and returns its flattened transformed representation (expressions) */ irBlockBuilder . flattenExpression ( expression : IrBlock ) : List < IrBlock > | expression = [ expression ] | otherwise = expression : (flattenExpression expression) /** * Takes not transformed expression and returns its flattened transformed representation (expressions) */ irBlockBuilder . flattenExpression ( expression : IrBlock ) : List < IrBlock > | expression = [ expression ] | otherwise = expression : (flattenExpression expression) /** * Takes not transformed expression and returns its flattened transformed representation (expressions) */ irBlockBuilder . flattenExpression ( expression : IrBlock ) : List < IrBlock > | expression = [ expression ] | otherwise = expression : (flattenExpression expression) /** * Takes not transformed expression and returns its flattened transformed representation (expressions) */ irBlockBuilder . flattenExpression ( expression : IrBlock ) : List < IrBlock > | expression
: MfvcNodeInstance = { if ( instance == null ) { instance = new MfvcNodeInstance() } if ( expression == null ) { return instance } if ( expression.isEmpty() ) { return instance } if ( instance.isEmpty() ) { return new MfvcNodeInstance() } if ( instance.isLeaf() ) { return new MfvcNodeInstance() } if ( expression.isLeaf() ) { return new MfvcNodeInstance() } if ( instance.isLeaf() ) { return new MfvcNodeInstance() } if ( instance.isLeaf() ) { return new MfvcNodeInstance() } if ( instance.isLeaf() ) { return new MfvcNodeInstance() } if ( instance.isLeaf() ) { return new MfvcNodeInstance() } if ( instance.isLeaf() ) { return new M
: IrBody { return this } /** * Removes boxing when the result is used */ private fun IrBody . removeAllBoxes ( ) : IrBody { return this } /** * Removes boxing when the result is used */ private fun IrBody . removeAllBoxes ( ) : IrBody { return this } /** * Removes boxing when the result is used */ private fun IrBody . removeAllBoxes ( ) : IrBody { return this } /** * Removes boxing when the result is used */ private fun IrBody . removeAllBoxes ( ) : IrBody { return this } /** * Removes boxing when the result is used */ private fun IrBody . removeAllBoxes ( ) : IrBody { return this } /** * Removes boxing when the result is used */ private fun IrBody . removeAllBoxes ( ) : IrBody { return this } /** * Removes boxing when the result is used */ private fun IrBody . removeAllBoxes ( ) : IrBody {
private fun findNearestBlockForVariable ( variable : IrVariable , body : BlockOrBody ) : Map < IrVariable , BlockOrBody ? > * Finds the most narrow block or body which contains all usages of each of the given variables */ private fun findNearestBlockForVariable ( variable : IrVariable , body : BlockOrBody ) : Map < IrVariable , BlockOrBody ? > * Finds the most narrow block or body which contains all usages of each of the given variables */ private fun findNearestBlockForVariable ( variable : IrVariable , body : BlockOrBody ) : Map < IrVariable , BlockOrBody ? > * Finds the most narrow block or body which contains all usages of each of the given variables */ private fun findNearestBlockForVariable ( variable : IrVariable , body : BlockOrBody ) : Map < IrVariable , BlockOrBody ? > * Finds the most narrow block or body which contains all usages of each of the given variables */ private fun findNearestBlockForVariable ( variable : IrVariable , body : BlockOrBody ) : Map < IrVariable , BlockOrBody ? > * Finds the
{ if ( variables.isEmpty() ) { return this } if ( variables.size() == 1 ) { return this } if ( variables.size() == 2 ) { return this } if ( variables.size() == 3 ) { return this } if ( variables.size() == 4 ) { return this } if ( variables.size() == 5 ) { return this } if ( variables.size() == 6 ) { return this } if ( variables.size() == 7 ) { return this } if ( variables.size() == 8 ) { return this } if ( variables.size() == 9 ) { return this } if ( variables.size() == 10 ) { return this } if ( variables.size() == 11 ) { return this } if ( variables.size() == 12 ) { return this } if ( variables.size() ==
public fun < I > Operation < I , FloatData > . transpose ( sharpBlock : Transpose . ( ) -> Unit ) : Operation < I , FloatData > . transpose ( sharpBlock : Transpose . ( ) -> Unit ) : Operation < I , FloatData > . transpose ( sharpBlock : Transpose . ( ) -> Unit ) : Operation < I , FloatData > . transpose ( sharpBlock : Transpose . ( ) -> Unit ) : Operation < I , FloatData > . transpose ( sharpBlock : Transpose . ( ) -> Unit ) : Operation < I , FloatData > . transpose ( sharpBlock : Transpose . ( ) -> Unit ) : Operation < I , FloatData > . transpose ( sharpBlock : Transpose . ( ) -> Unit ) : Operation < I , FloatData > . transpose ( sharpBlock : Transpose . ( ) -> Unit ) : Operation < I , FloatData > . transpose ( sharpBlock : Transpose . ( ) -> Unit ) : Operation < I , FloatData > . transpose ( sharpBlock : Transpose . ( ) -> Unit ) : Operation < I , FloatData > . transpose ( sharpBlock : Transpose . ( ) -> Unit
= new CommonThreadLocal < T > ( name ) ; /** * Create a thread-local storage for an object of type [T]. * * If two different thread-local objects share the same [name], they will not necessarily share the same value, * but they may. * Therefore, use a unique [name] for each thread-local object. */ /** * Create a thread-local storage for an object of type [T]. * * If two different thread-local objects share the same [name], they will not necessarily share the same value, * but they may. * Therefore, use a unique [name] for each thread-local object. */ /** * Create a thread-local storage for an object of type [T]. * * If two different thread-local objects share the same [name], they will not necessarily share the same value, * but they may. * Therefore, use a unique [name] for each thread-local object. */ /** * Create a thread-local storage for an object of type [T]. * * If two different thread-local objects share the same [name], they
{ if ( testString.isEmpty() ) { return startIndex } else { var i = startIndex while ( i < testString.length ) { if ( testString.charAt(i) == testString.charAt(startIndex) ) { i++ if ( i == testString.length ) { return startIndex } } else { i++ } } return startIndex } } /** Returns startIndex+shift, the next position to match */ fun matches ( startIndex : Int , testString : CharSequence , matchResult : MatchResultImpl ) : Int { if ( testString.isEmpty() ) { return startIndex } else { var i = startIndex while ( i < testString.length ) { if ( testString.charAt(i) == testString.charAt(startIndex) ) { i++ if ( i == testString.length ) { return startIndex } } else { i++
fun HTMLTag . unsafe ( block : Unsafe . ( ) -> Unit ) : Unit { let tag = block(); tag.name = block.name; tag.value = block.value; tag.attributes = block.attributes; tag.style = block.style; tag.id = block.id; tag.class = block.class; tag.backgroundColor = block.backgroundColor; tag.color = block.color; tag.borderColor = block.borderColor; tag.borderWidth = block.borderWidth; tag.padding = block.padding; tag.paddingTop = block.paddingTop; tag.paddingBottom = block.paddingBottom; tag.paddingLeft = block.paddingLeft; tag.paddingRight = block.paddingRight; tag.marginLeft = block.marginLeft; tag.marginRight = block.marginRight; tag.marginTop = block.marginTop; tag.marginBottom = block.marginBottom; tag.marginLeft = block.marginLeft; tag.
( child : KtSourceElement ) : Unit { if ( depth < 0 ) { return } if ( ! types.contains ( child.type ) ) { return } processChild ( child ) if ( reverse ) { forEachChildOfType ( types , depth - 1 , true , processChild , child ) } else { forEachChildOfType ( types , depth - 1 , false , processChild , child ) } } /** * Iterates recursively over all children up to the given depth. * `processChild` is invoked for each child having a type in the `types` set. */ KtSourceElement . forEachChildOfType ( types : Set < IElementType > , depth : Int = 0 , reverse : Boolean = false , processChild : ( KtSourceElement ) -> Unit , ) kt ( child : KtSourceElement ) : Unit { if ( depth < 0 ) { return } if ( ! types.contains ( child.type ) ) { return } processChild (
: Unit { if ( depth < 0 ) { depth = 0 reverse = true } else if ( depth > 0 ) { depth = depth - 1 reverse = false } else { depth = 0 reverse = true } if ( reverse ) { forEachChildOfType ( types , depth + 1 , processChild , reverse ) } else { forEachChildOfType ( types , depth , processChild , reverse ) } } /** * See [KtSourceElement.forEachChildOfType] */ /** * See [KtSourceElement.forEachChildOfType] */ /** * See [KtSourceElement.forEachChildOfType] */ /** * See [KtSourceElement.forEachChildOfType] */ /** * See [KtSourceElement.forEachChildOfType] */ /** * See [KtSourceElement.forEachChildOfType] */ /** * See [KtSourceElement.forEachChildOfType] */ /** * See [
: FlyweightCapableTreeStructure < LighterASTNode > { if ( depth < 0 ) { throw new IllegalArgumentException ("LighterASTNode.forEachChildOfType: depth must be non-negative") } if ( reverse ) { forEachChildOfType ( types , depth - 1 , reverse , treeStructure , processChild ) } else { forEachChildOfType ( types , depth , reverse , treeStructure , processChild ) } } /** * See [KtSourceElement.forEachChildOfType] */ fun LighterASTNode . forEachChildOfType ( types : Set < IElementType > , depth : Int = 0 , reverse : Boolean = false , treeStructure : FlyweightCapableTreeStructure < LighterASTNode > , processChild : ( LighterASTNode ) -> Unit , ) : FlyweightCapableTreeStructure < LighterASTNode > { if ( depth < 0 ) { throw new IllegalArgumentException ("LighterASTNode.forEachChildOfType: depth must be non-negative") }
( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : KtLightSourceElement ( childNode ) : K
-> KtSourceElement = { if ( indexFromLast < 0 ) indexFromLast = 0 if ( indexFromLast < 0 ) indexFromLast = 0 if ( indexFromLast < 0 ) indexFromLast = 0 if ( indexFromLast < 0 ) indexFromLast = 0 if ( indexFromLast < 0 ) indexFromLast = 0 if ( indexFromLast < 0 ) indexFromLast = 0 if ( indexFromLast < 0 ) indexFromLast = 0 if ( indexFromLast < 0 ) indexFromLast = 0 if ( indexFromLast < 0 ) indexFromLast = 0 if ( indexFromLast < 0 ) indexFromLast = 0 if ( indexFromLast < 0 ) indexFromLast = 0 if ( indexFromLast < 0 ) indexFromLast = 0 if ( indexFromLast < 0 ) indexFromLast = 0 if ( indexFromLast < 0 ) indexFromLast = 0 if ( indexFromLast < 0 ) indexFromLast = 0 if ( indexFromLast < 0 ) indexFromLast = 0 if ( indexFromLast < 0
= nil * * @return the source element of the last segment * of `importedFqName`. */ let getLastImportedFqNameSegmentSource (importedFqName : KtSourceElement) : KtSourceElement? = let lastSegment = importedFqName.getLastSegment () let lastSegmentSource = lastSegment.getLastSegmentSource () if lastSegmentSource = nil then let lastSegmentSource = importedFqName.getLastSegmentSource () if lastSegmentSource = nil then let lastSegmentSource = importedFqName.getLastSegmentSource () if lastSegmentSource = nil then let lastSegmentSource = importedFqName.getLastSegmentSource () if lastSegmentSource = nil then let lastSegmentSource = importedFqName.getLastSegmentSource () if lastSegmentSource = nil then let lastSegmentSource = importedFqName.getLastSegmentSource () if lastSegmentSource = nil then let lastSegmentSource =

( ) { var a = [1,2,3,4,5,6,7,8,9] var b = [1,2,3,4,5,6,7,8,9] var c = [1,2,3,4,5,6,7,8,9] var d = [1,2,3,4,5,6,7,8,9] var e = [1,2,3,4,5,6,7,8,9] var f = [1,2,3,4,5,6,7,8,9] var g = [1,2,3,4,5,6,7,8,9] var h = [1,2,3,4,5,6,7,8,9] var i = [1,2,3,4,5,6,7,8,9] var j = [1,2,3,4,5,6,7,8,9] var k = [1,2,3





fun ( key : K ) : V = let ( value : V ) = cache ( key ) in value end /** * Removes the value associated with [key] from the cache, performs cleanup on it, and returns it if it exists. **Must be called in a * write action.** */ linecache ( key : K ) : V ? linecache ( key : K ) : V = let ( value : V ) = cache ( key ) in value end /** * Removes the value associated with [key] from the cache, performs cleanup on it, and returns it if it exists. **Must be called in a * read action.** */ linecache ( key : K ) : V ? linecache ( key : K ) : V = let ( value : V ) = cache ( key ) in value end /** * Removes the value associated with [key] from the cache, performs cleanup on it, and returns it if it exists. **Must be called in a * write action.** */ linecache (



fun = null * * @param classId * @return an [InputStream] which should be used to load the .kotlin_metadata file for class with the given [classId]. * [classId] identifies either a real top level class, or a package part (e.g. it can be "foo/bar/_1Kt") */ public static InputStream findMetadata ( ClassId classId ) : InputStream ? * * @param classId * @return an [InputStream] which should be used to load the .kotlin_metadata file for class with the given [classId]. * [classId] identifies either a real top level class, or a package part (e.g. it can be "foo/bar/_1Kt") */ public static InputStream findMetadata ( String classId ) : InputStream ? * * @param classId * @return an [InputStream] which should be used to load the .kotlin_metadata file for class with the given [classId]. * [classId] identifies either a real top level class, or a package part (e.g. it
{ if ( fqName == null || fqName.isEmpty() ) { return false; } if ( fqName.contains( ".kotlin_metadata" ) ) { return true; } else { return false; } } /** * @return `true` iff this finder is able to locate the package with the given [fqName], containing .kotlin_metadata files. * Note that returning `true` makes [MetadataPackageFragmentProvider] construct the package fragment for the package, * and that fact can alter the qualified name expression resolution in the compiler front-end */ /** * @return `true` iff this finder is able to locate the package with the given [fqName], containing .kotlin_metadata files. * Note that returning `true` makes [MetadataPackageFragmentProvider] construct the package fragment for the package, * and that fact can alter the qualified name expression resolution in the compiler front-end */ /** * @return `true` iff this finder is able to locate the package with the
= null { if ( packageFqName == null || packageFqName.isEmpty() ) { return null; } if ( packageFqName.endsWith( ".kotlin_builtins" ) ) { packageFqName = packageFqName.substring( 0, packageFqName.length() - 4 ); } if ( packageFqName.endsWith( "/" ) ) { packageFqName = packageFqName.substring( 0, packageFqName.length() - 1 ); } if ( packageFqName.endsWith( "/" ) ) { packageFqName = packageFqName.substring( 0, packageFqName.length() - 1 ); } if ( packageFqName.endsWith( "/" ) ) { packageFqName = packageFqName.substring( 0, packageFqName.length() - 1 ); } if ( packageFqName.endsWith( "/" ) ) { packageFqName = packageFqName.
{ return this.classId } /** * Retrieves className from [KtUserType] for compiled code only. * * It relies on [org.jetbrains.kotlin.psi.stubs.impl.KotlinNameReferenceExpressionStubImpl.isClassRef], * which is set during cls analysis only. */ fun KtUserType . className ( ) : String { return this.className } /** * Retrieves name from [KtUserType] for compiled code only. * * It relies on [org.jetbrains.kotlin.psi.stubs.impl.KotlinNameReferenceExpressionStubImpl.isClassRef], * which is set during cls analysis only. */ fun KtUserType . name ( ) : String { return this.name } /** * Retrieves name from [KtUserType] for compiled code only. * * It relies on [org.jetbrains.kotlin.psi.stubs.impl.KotlinName
{ var tmpdir = ""; if ( ! os.path.exists ( tmpdir ) ) { os.makedirs ( tmpdir ); } return tmpdir; } /** * See https://nodejs.org/api/os.html#ostmpfile */ megafun tmpfile ( ) : String ? megafile { var tmpfile = ""; if ( ! os.path.exists ( tmpfile ) ) { os.makedirs ( tmpfile ); } return tmpfile; } /** * See https://nodejs.org/api/os.html#ostmpdir */ megafun tmpdir ( ) : String ? megafile { var tmpdir = ""; if ( ! os.path.exists ( tmpdir ) ) { os.makedirs ( tmpdir ); } return tmpdir; } /** * See https://nodejs.org/api/os.html#ostmpfile */ megafun tmpfile ( ) : String ? meg
{ var platform = ""; switch ( platform ) { case "linux": platform = "linux"; break; case "darwin": platform = "darwin"; break; case "win32": platform = "win32"; break; case "cygwin": platform = "cygwin"; break; case "macosx": platform = "macosx"; break; default: platform = "unknown"; break; } return platform; } /** * See https://nodejs.org/api/os.html#osplatform */ micropython platform ( ) : String micropython { var platform = ""; switch ( platform ) { case "linux": platform = "linux"; break; case "darwin": platform = "darwin"; break; case "win32": platform = "win32"; break; case "cygwin": platform = "cyg






: * [condition]: guaranteed to be invoked under the lock. */ public synchronized void advanceUntilIdleOr ( condition : ( ) -> Boolean ) { while ( !condition( this ) ) { this.next(); } } /** * [condition]: guaranteed to be invoked under the lock. */ public synchronized void advanceUntilIdle ( condition : ( ) -> Boolean ) { while ( !condition( this ) ) { this.next(); } } /** * [condition]: guaranteed to be invoked under the lock. */ public synchronized void advanceUntil ( condition : ( ) -> Boolean ) { while ( !condition( this ) ) { this.next(); } } /** * [condition]: guaranteed to be invoked under the lock. */ public synchronized void advance ( condition : ( ) -> Boolean ) { while ( !condition( this ) ) { this.next(); } } /** * [condition]: guaranteed to be invoked under the lock.
Public { for ( var i = 0; i < this.tasks.size; i++ ) { this.tasks.get( i ).run() } } /** * Runs the tasks that are scheduled to execute at this moment of real time. */ runCurrent ( ) realPublic { for ( var i = 0; i < this.tasks.size; i++ ) { this.tasks.get( i ).run() } } /** * Runs the tasks that are scheduled to execute at this moment of both virtual and real time. */ runCurrent ( ) bothPublic { for ( var i = 0; i < this.tasks.size; i++ ) { this.tasks.get( i ).run() } } /** * Runs the tasks that are scheduled to execute at this moment of both virtual and real time. */ runCurrent ( ) bothPublic { for ( var i = 0; i < this.tasks.size; i++ ) { this.tasks.get( i ).run() } }

throws IllegalArgumentException { if ( delayTime < 0 ) { throw IllegalArgumentException("delayTime must be non-negative") } if ( delayTime > this.delay ) { throw IllegalArgumentException("delayTime must be less than the current delay") } this.delay += delayTime this.scheduleTasks() } /** * Moves the virtual clock of this dispatcher backward by [the specified amount][delayTime], running the * scheduled tasks in the meantime. * * @throws IllegalArgumentException if passed a negative [delay][delayTime]. */ advanceTimeBy ( -delayTime : Duration ) gnithrows IllegalArgumentException { if ( -delayTime < 0 ) { throw IllegalArgumentException("delayTime must be non-negative") } if ( -delayTime > this.delay ) { throw IllegalArgumentException("delayTime must be less than the current delay") } this.delay -= delayTime this.scheduleTasks() } /** * Moves the virtual clock of this dispatcher
: Boolean * * @param strict * @return */ fun isIdle ( strict : Boolean = true ) : Boolean { if ( strict ) return true else return false } /** * Checks that the only tasks remaining in the scheduler are cancelled. * * @param strict * @return */ fun isIdle ( strict : Boolean = true ) : Boolean { if ( strict ) return true else return false } /** * Checks that the only tasks remaining in the scheduler are cancelled. * * @param strict * @return */ fun isIdle ( strict : Boolean = true ) : Boolean { if ( strict ) return true else return false } /** * Checks that the only tasks remaining in the scheduler are cancelled. * * @param strict * @return */ fun isIdle ( strict : Boolean = true ) : Boolean { if ( strict ) return true else return false } /** * Checks that the
Internal = { if ( context.scheduler ) { context.scheduler.sendDispatchEvent( this, context ) } } /** * Notifies this scheduler about a task completion event. * * [context] is the context in which the task will be dispatched. */ fun sendTaskCompletionEvent ( context : CoroutineContext ) = { if ( context.scheduler ) { context.scheduler.sendTaskCompletionEvent( this, context ) } } /** * Notifies this scheduler about a task failure event. * * [context] is the context in which the task will be dispatched. */ fun sendTaskFailureEvent ( context : CoroutineContext ) = { if ( context.scheduler ) { context.scheduler.sendTaskFailureEvent( this, context ) } } /** * Notifies this scheduler about a task error event. * * [context] is the context in which the task will be dispatched. */ fun sendTaskErrorEvent ( context : CoroutineContext ) = {
{ if ( null == dispatchEvent ) { return; } if ( null == dispatchEvent.dispatchEvent ) { return; } if ( null == dispatchEvent.dispatchEvent.dispatchEvent ) { return; } if ( null == dispatchEvent.dispatchEvent.dispatchEvent.dispatchEvent ) { return; } if ( null == dispatchEvent.dispatchEvent.dispatchEvent.dispatchEvent.dispatchEvent ) { return; } if ( null == dispatchEvent.dispatchEvent.dispatchEvent.dispatchEvent.dispatchEvent.dispatchEvent ) { return; } if ( null == dispatchEvent.dispatchEvent.dispatchEvent.dispatchEvent.dispatchEvent.dispatchEvent.dispatchEvent.dispatchEvent ) { return; } if ( null == dispatchEvent.dispatchEvent.dispatchEvent.dispatchEvent.dispatchEvent.dispatchEvent.dispatchEvent.
public fun < R > Sequence < * > . filterIsInstance ( klass : Class < R > ) : Sequence < * > . filterIsInstance ( klass : Class < R > ) : Sequence < * >. filterIsInstance ( klass : Class < R > ) : Sequence < * >. filterIsInstance ( klass : Class < R > ) : Sequence < * >. filterIsInstance ( klass : Class < R > ) : Sequence < * >. filterIsInstance ( klass : Class < R > ) : Sequence < * >. filterIsInstance ( klass : Class < R > ) : Sequence < * >. filterIsInstance ( klass : Class < R > ) : Sequence < * >. filterIsInstance ( klass : Class < R > ) : Sequence < * >. filterIsInstance ( klass : Class < R > ) : Sequence < * >. filterIsInstance ( klass : Class < R > ) : Sequence < * >. filterIsInstance ( klass : Class < R > ) : Sequence < * >. filterIsInstance ( klass : Class < R > ) : Sequence < * >. filterIsInstance ( klass : Class < R > )
InstanceToJVM ( destination , klass ) : C */ /** * Appends all elements that are instances of specified class to the given [destination]. * * The operation is _terminal_. * * @sample samples.collections.Collections.Filtering.filterIsInstanceToJVM */ /** * Appends all elements that are instances of specified class to the given [destination]. * * The operation is _terminal_. * * @sample samples.collections.Collections.Filtering.filterIsInstanceToJVM */ /** * Appends all elements that are instances of specified class to the given [destination]. * * The operation is _terminal_. * * @sample samples.collections.Collections.Filtering.filterIsInstanceToJVM */ /** * Appends all elements that are instances of specified class to the given [destination]. * * The operation is _terminal_. * * @sample samples.collections.Collections.Filtering.filterIsInstanceToJVM */ /** * App
ter public fun < T : Comparable < T > > Sequence < T > . toSortedSet ( ) : java . util . SortedSet < T > . toSortedSet ( ) : java . util . SortedSet < T > . toSortedSet ( ) : java . util . SortedSet < T > . toSortedSet ( ) : java . util . SortedSet < T > . toSortedSet ( ) : java . util . SortedSet < T > . toSortedSet ( ) : java . util . SortedSet < T > . toSortedSet ( ) : java . util . SortedSet < T > . toSortedSet ( ) : java . util . SortedSet < T > . toSortedSet ( ) : java . util . SortedSet < T > . toSortedSet ( ) : java . util . SortedSet < T > . toSortedSet ( ) : java . util . SortedSet < T > . toSortedSet ( ) : java . util . SortedSet < T > . toSortedSet ( ) : java . util . SortedSet < T > . toSortedSet (
public fun < T > Sequence < T > . toSortedSet ( comparator : Comparator < in T > ) : java . util . SortedSet < T > */ /** * Returns a new [SortedSet][java.util.SortedSet] of all elements. * * Elements in the set returned are sorted according to the given [comparator]. * * The operation is _terminal_. */ /** * Returns a new [SortedSet][java.util.SortedSet] of all elements. * * Elements in the set returned are sorted according to the given [comparator]. * * The operation is _terminal_. */ /** * Returns a new [SortedSet][java.util.SortedSet] of all elements. * * Elements in the set returned are sorted according to the given [comparator]. * * The operation is _terminal_. */ /** * Returns a new [SortedSet][java.util.SortedSet] of all elements. * * Elements in the set returned are sorted according to the given


fun ( ) * [X.YY.Z<caret>Z] * [X.YY.Z<caret>Z] * [X.YY.Z<caret>Z] * [X.YY.Z<caret>Z] * [X.YY.Z<caret>Z] * [X.YY.Z<caret>Z] * [X.YY.Z<caret>Z] * [X.YY.Z<caret>Z] * [X.YY.Z<caret>Z] * [X.YY.Z<caret>Z] * [X.YY.Z<caret>Z] * [X.YY.Z<caret>Z] * [X.YY.Z<caret>Z] * [X.YY.Z<caret>Z] * [X.YY.Z<caret>Z] * [X.YY.Z<caret>Z] * [X.YY.Z<caret>Z] * [X.YY.Z<caret>Z]





: ColumnSet < Any > { val colsWithoutNulls = mutableListOf<Any>() colsWithoutNulls.add("myColumnGroup") colsWithoutNulls.add("myColumn1") colsWithoutNulls.add("myColumn2") colsWithoutNulls.add("myColumn3") colsWithoutNulls.add("myColumn4") colsWithoutNulls.add("myColumn5") colsWithoutNulls.add("myColumn6") colsWithoutNulls.add("myColumn7") colsWithoutNulls.add("myColumn8") colsWithoutNulls.add("myColumn9") colsWithoutNulls.add("myColumn10") colsWithoutNulls.add("myColumn11") colsWithoutNulls.add("myColumn12") colsWithoutNulls.add("myColumn13") colsWithoutNulls.add("myColumn14") colsWithoutNulls.add("myColumn15") colsWithoutNulls.
: ColumnSet<Any> { val colsWithoutNulls: ColumnSet<Any> = ColumnSet<Any>() colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this)
: ColumnSet < Any > { val colsWithoutNulls = mutableListOf<Any>() colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) colsWithoutNulls.add(this) col
override fun fullyExpandedType ( type : KtType ) : KtType ** Expanded by default */ override fun fullyExpandedType ( type : KtType ) : KtType ** Expanded by default */ override fun fullyExpandedType ( type : KtType ) : KtType ** Expanded by default */ override fun fullyExpandedType ( type : KtType ) : KtType ** Expanded by default */ override fun fullyExpandedType ( type : KtType ) : KtType ** Expanded by default */ override fun fullyExpandedType ( type : KtType ) : KtType ** Expanded by default */ override fun fullyExpandedType ( type : KtType ) : KtType ** Expanded by default */ override fun fullyExpandedType ( type : KtType ) : KtType ** Expanded by default */ override fun fullyExpandedType ( type : KtType ) : KtType ** Expanded by default */ override fun fullyExpandedType ( type : KtType ) : KtType ** Expanded by

fun { * * @param args * @return void */ void irisClassification ( void ) { * * @param args * @return void */ void irisClassification ( void ) { * * @param args * @return void */ void irisClassification ( void ) { * * @param args * @return void */ void irisClassification ( void ) { * * @param args * @return void */ void irisClassification ( void ) { * * @param args * @return void */ void irisClassification ( void ) { * * @param args * @return void */ void irisClassification ( void ) { * * @param args * @return void */ void irisClassification ( void ) { * * @param args * @return void */ void irisClassification ( void ) { * * @param args * @return void */ void irisClassification ( void ) { * * @param args * @return void *
( ) { var a = [1,2,3,4,5,6,7,8,9] var b = [1,2,3,4,5,6,7,8,9] var c = [1,2,3,4,5,6,7,8,9] var d = [1,2,3,4,5,6,7,8,9] var e = [1,2,3,4,5,6,7,8,9] var f = [1,2,3,4,5,6,7,8,9] var g = [1,2,3,4,5,6,7,8,9] var h = [1,2,3,4,5,6,7,8,9] var i = [1,2,3,4,5,6,7,8,9] var j = [1,2,3,4,5,6,7,8,9] var k = [1,2,3
override fun dispatch ( context : CoroutineContext , block : Runnable ) : Unit { if ( block instanceof Runnable ) { dispatch( context , block ) } else if ( block instanceof Unit ) { dispatch( context , block ) dispatch( context , block ) } else { dispatch( context , block ) dispatch( context , block ) dispatch( context , block ) dispatch( context , block ) dispatch( context , block ) dispatch( context , block ) dispatch( context , block ) dispatch( context , block ) dispatch( context , block ) dispatch( context , block ) dispatch( context , block ) dispatch( context , block ) dispatch( context , block ) dispatch( context , block ) dispatch( context , block ) dispatch( context , block ) dispatch( context , block ) dispatch( context , block ) dispatch( context , block ) dispatch( context , block )
override fun scheduleResumeAfterDelay ( timeMillis : Long , continuation : CancellableContinuation < Unit > ) { if ( continuation == null ) { throw IllegalArgumentException () } if ( timeMillis < 0 ) { throw IllegalArgumentException () } if ( timeMillis == 0 ) { throw IllegalArgumentException () } if ( timeMillis == 1 ) { throw IllegalArgumentException () } if ( timeMillis == 2 ) { throw IllegalArgumentException () } if ( timeMillis == 3 ) { throw IllegalArgumentException () } if ( timeMillis == 4 ) { throw IllegalArgumentException () } if ( timeMillis == 5 ) { throw IllegalArgumentException () } if ( timeMillis == 6 ) { throw IllegalArgumentException () } if ( timeMillis == 7 ) { throw IllegalArgumentException () } if ( timeMillis == 8 )
override fun invokeOnTimeout ( timeMillis : Long , block : Runnable , context : CoroutineContext ) : DisposableHandle { if ( timeMillis > 0 ) { disposableHandle.dispose() disposableHandle = null } return this } /** @suppress */ fun invokeOnTimeout ( timeMillis : Long , block : Runnable , context : CoroutineContext ) : DisposableHandle override fun invokeOnTimeout ( timeMillis : Long , block : Runnable , context : CoroutineContext ) : DisposableHandle { if ( timeMillis > 0 ) { disposableHandle.dispose() disposableHandle = null } return this } /** @suppress */ fun invokeOnTimeout ( timeMillis : Long , block : Runnable , context : CoroutineContext ) : DisposableHandle override fun invokeOnTimeout ( timeMillis : Long , block : Runnable , context : CoroutineContext ) : DisposableHandle { if ( timeMillis > 0 ) { disposableHandle.di


* * @return JDuration */ public static JDuration decodeJavaDuration(String path) { try { return JDuration.parse(path); } catch (ParseException e) { e.printStackTrace(); } return null; } /** * Decode [JTime] from [Config]. * See https://github.com/lightbend/config/blob/main/HOCON.md#time-format * * @param path in config */ public static JTime decodeJavaTime(String path) { try { return JTime.parse(path); } catch (ParseException e) { e.printStackTrace(); } return null; } /** * Decode [JDate] from [Config]. * See https://github.com/lightbend/config/blob/main/HOCON.md#date-format * * @param path in config */ public static JDate decodeJavaDate(String path) { try { return JDate
fun ( kotlinCompilation : KotlinCompilation < * > ) : TaskProvider < out AbstractArchiveTask > { * * @param kotlinCompilation : KotlinCompilation < * > * * @return archive task associated with [kotlinCompilation] instance. * * This method searches via Identity class (Project path, target and compilation names) of Compilations not by reference. * So it is safe to pass decorated or wrapped instances. */ } /** * Returns archive task associated with [kotlinCompilation] instance. * * @param kotlinCompilation : KotlinCompilation < * > * * @return archive task associated with [kotlinCompilation] instance. * * This method searches via Identity class (Project path, target and compilation names) of Compilations not by reference. * So it is safe to pass decorated or wrapped instances. */ } /** * Returns archive task associated with [kotlinCompilation] instance. * * @param kotlinCompilation : KotlinCompilation < * > * * @return archive task





{ return this.displayableName } /** * Parenthesis is applied in 1 case: * - page only contains functions (therefore documentable from this page is [DFunction]) * - page only contains functions (therefore documentable from this page is [DFunction]) * - page only contains functions (therefore documentable from this page is [DFunction]) * - page only contains functions (therefore documentable from this page is [DFunction]) * - page only contains functions (therefore documentable from this page is [DFunction]) * - page only contains functions (therefore documentable from this page is [DFunction]) * - page only contains functions (therefore documentable from this page is [DFunction]) * - page only contains functions (therefore documentable from this page is [DFunction]) * - page only contains functions (therefore documentable from this page is [DFunction]) * - page only contains functions (therefore documentable from this page is [DFunction]) * - page only contains functions (therefore documentable from this page is [DFunction]) * - page only contains functions (therefore documentable
.OrtSession = { var session : OrtSession = OrtSession (); session.sessionId = options.sessionId; session.sessionName = options.sessionName; session.sessionType = options.sessionType; session.sessionDate = options.sessionDate; session.sessionStartTime = options.sessionStartTime; session.sessionEndTime = options.sessionEndTime; session.sessionDuration = options.sessionDuration; session.sessionStart = options.sessionStart; session.sessionEnd = options.sessionEnd; session.sessionStartTime = options.sessionStartTime; session.sessionEndTime = options.sessionEndTime; session.sessionDuration = options.sessionDuration; session.sessionStart = options.sessionStart; session.sessionEnd = options.sessionEnd; session.sessionStartTime = options.sessionStartTime; session.sessionEndTime = options.sessionEndTime; session.sessionDuration = options.sessionDuration; session.sessionStart = options.sessionStart; session.sessionEnd = options.sessionEnd

( ) : Map < String , Any > = ArrayListOf<Map<String , Any>>() { var result = ArrayListOf<Map<String , Any>>() for ( var i = 0; i < inputData.size; i++ ) { result.add( ArrayListOf<Map<String , Any>>() ) for ( var j = 0; j < inputData[i].size; j++ ) { result[i].add( ArrayListOf<Map<String , Any>>() ) for ( var k = 0; k < inputData[i][j].size; k++ ) { result[i][j].add( ArrayListOf<Map<String , Any>>() ) for ( var l = 0; l < inputData[i][j][k].size; l++ ) { result[i][j][k].add( ArrayListOf<Map<String , Any>>() ) for ( var m = 0; m < inputData[i][j][k][l].size; m++ ) { result[i][j][k][l].add(
= OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConverter.convert( OrtSessionResultConver
{ if ( inputs.isEmpty() ) { return 0.0f } else { val max = inputs.values.max() val min = inputs.values.min() val sum = inputs.values.sum() val mean = inputs.values.mean() val median = inputs.values.median() val mode = inputs.values.mode() val variance = inputs.values.variance() val standardDeviation = inputs.values.standardDeviation() val skewness = inputs.values.skewness() val kurtosis = inputs.values.kurtosis() val skewnessMean = inputs.values.skewnessMean() val skewnessMedian = inputs.values.skewnessMedian() val skewnessMode = inputs.values.skewnessMode() val kurtosisMean = inputs.values.kurtosisMean() val kurtosisMedian = inputs.values.kurtosisMedian() val kurtosisMode = inputs.value
override { super.close() if ( this.parent != null ) { if ( this.parent.parent != null ) { this.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent.parent




OutputLinesStart ( vararg lines : List < String > ) : Exception? { if ( lines.isEmpty() ) { throw new RuntimeException( "Expected output lines are empty" ) } if ( expected.isEmpty() ) { throw new RuntimeException( "Expected output lines are empty" ) } if ( lines.size() != expected.size() ) { throw new RuntimeException( "Expected and captured output lines do not have the same size" ) } for ( var i = 0; i < lines.size(); i++ ) { if ( lines[i] != expected[i] ) { throw new RuntimeException( "Expected and captured output lines do not start with the same list" ) } } return null } /** * Verifies that this lines captured by [captureOutput] end with the same list as [expected] one * and throws exception if not. Additional lines in the output are ignored. This is useful for * testing that the exception with the appropriate message was thrown */ listpublic fun List < String > .







FileExists ( file : Path ) : bool { if ( ! file.exists ( ) ) { return false; } if ( ! file.isFile ( ) ) { return false; } if ( ! file.isRegularFile ( ) ) { return false; } return true; } /** * Asserts file under [file] path exists and is a regular file. * Returns true if file exists and is a regular file. * Returns false if file does not exist or is not a regular file. */ bool assertFileExistsAndIsRegularFile ( file : Path , ) : bool { if ( ! file.exists ( ) ) { return false; } if ( ! file.isFile ( ) ) { return false; } if ( ! file.isRegularFile ( ) ) { return false; } return true; } /** * Asserts file under [file] path exists and is a
FileInProjectExists ( pathToFile : String ) : Boolean { try { java.io.File file = new java.io.File ( pathToFile ); java.io.FileReader fileReader = new java.io.FileReader ( file ); java.io.BufferedReader bufferedReader = new java.io.BufferedReader ( fileReader ); java.io.FileWriter fileWriter = new java.io.FileWriter ( pathToFile ); java.io.BufferedWriter bufferedWriter = new java.io.BufferedWriter ( fileWriter ); java.io.PrintWriter printWriter = new java.io.PrintWriter ( bufferedWriter ); printWriter.println ( pathToFile ); java.io.PrintWriter printWriter2 = new java.io.PrintWriter ( bufferedWriter ); printWriter2.println ( pathToFile ); java.io.PrintWriter printWriter3 = new java.io.PrintWriter ( bufferedWriter ); printWriter3.println ( pathToFile ); java.io.PrintWriter printWriter4 = new java.io.
Exists ( pathToFile : String ) * Asserts file under [pathToFile] relative to the test project does not exist. */ /** * Asserts file under [pathToFile] relative to the test project does not exist. */ /** * Asserts file under [pathToFile] relative to the test project does not exist. */ /** * Asserts file under [pathToFile] relative to the test project does not exist. */ /** * Asserts file under [pathToFile] relative to the test project does not exist. */ /** * Asserts file under [pathToFile] relative to the test project does not exist. */ /** * Asserts file under [pathToFile] relative to the test project does not exist. */ /** * Asserts file under [pathToFile] relative to the test project does not exist. */ /** * Asserts file under [pathToFile] relative to the test project does not exist. */ /** * Asserts file under [pathToFile] relative
fun ( symlink : symlink ) = let exists ( symlink : symlink ) = symlink.exists () in exists ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exists ( symlink : symlink ) ( exist
SymlinkInProjectExists ( pathToFile : String , ) : Boolean = { if ( isSymlink ( pathToFile ) ) { return true; } else { return false; } } /** * Asserts symlink under [pathToFile] exists and is a symlink. */ isSymlink ( pathToFile : String ) : Boolean = { if ( isSymlink ( pathToFile ) ) { return true; } else { return false; } } /** * Asserts symlink under [pathToFile] exists and is a symlink. */ assertSymlinkExists ( pathToFile : String , ) : Boolean = { if ( isSymlink ( pathToFile ) ) { return true; } else { return false; } } /** * Asserts symlink under [pathToFile] exists and is a symlink
DirectoryExists ( pathToDir : String ) : Unit = { assertTrue ( isDirectory ( pathToDir ) ) } /** * Asserts directory under [pathToDir] relative to the test project exists and is a directory. */ gradleProject . assertDirectoryExists ( pathToDir : String , ) isDirectory ( pathToDir : String ) : Unit = { assertTrue ( isDirectory ( pathToDir ) ) } /** * Asserts directory under [pathToDir] relative to the test project exists and is a directory. */ gradleProject . assertDirectoryExists ( pathToDir : String , ) isDirectory ( pathToDir : String ) : Unit = { assertTrue ( isDirectory ( pathToDir ) ) } /** * Asserts directory under [pathToDir] relative to the test project exists and is a directory. */ gradleProject . assertDirectoryExists ( pathToDir : String , ) isDirectory ( pathToDir : String ) : Unit = { assertTrue ( isDirectory ( pathToDir ) ) } /** * Asserts directory under [
* * @param dirPath * @param message * @return */ public static boolean assertDirectoryExists ( dirPath : Path , message : String ? = null ) { if ( dirPath.isDirectory () ) { return true; } else { if ( message != null ) { throw new RuntimeException ( message ); } else { return false; } } } /** * Asserts file under [filePath] exists and is a file. */ public static boolean assertFileExists ( filePath : Path , message : String ? = null ) { if ( filePath.isFile () ) { return true; } else { if ( message != null ) { throw new RuntimeException ( message ); } else { return false; } } } /** * Asserts directory under [dirPath] exists and is a directory. */ public static boolean assertDirectoryEx
Fun ( pathToFile : String , vararg expectedText : String ) * * @param pathToFile * @param vararg expectedText * @return */ public static void assertFileInProjectContains ( pathToFile : String , vararg expectedText : String ) { File file = new File ( pathToFile ); if ( file.exists () ) { try ( BufferedReader reader = new BufferedReader ( new FileReader ( pathToFile ) ) ) { String line; while ( ( line = reader.readLine () ) != null ) { if ( line.contains ( expectedText ) ) { System.out.println ( line ); } } } } else { System.out.println ( pathToFile + " does not exist." ); } } /** * Asserts file under [pathToFile] relative to the test project exists and contains all the lines from [expectedText] * * @param pathToFile
AssertFileInProjectDoesNotContain ( pathToFile : String , vararg unexpectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg expectedText : String , vararg
{ * * @param file * @param vararg expectedText * * @return the content of the [file] */ public static String assertFileContains ( file : Path , vararg expectedText : String ) : String { * * @param file * @param vararg expectedText * * @return the content of the [file] */ public static String assertFileContains ( file : Path , vararg expectedText : String ) : String { * * @param file * @param vararg expectedText * * @return the content of the [file] */ public static String assertFileContains ( file : Path , vararg expectedText : String ) : String { * * @param file * @param vararg expectedText * * @return the content of the [file] */ public static String assertFileContains ( file : Path , vararg expectedText : String ) : String { * * @param file * @param vararg expectedText * * @return the content of the [file] */ public static String assertFileContains ( file : Path ,
{ assert ( files.size() == expectedText.length() ); for ( int i = 0 ; i < expectedText.length() ; i++ ) { if ( ! files.contains( expectedText.substring( i , i + 1 ) ) ) { throw new RuntimeException ( "Expected " + expectedText.substring( i , i + 1 ) + " not found in " + files.toString() ); } } return expectedText.toString(); } /** * Asserts files together contains all the lines from [expectedText] */ boolean assertFilesCombinedContains ( files : List < Path > , vararg expectedText : String , ) : boolean { assert ( files.size() == expectedText.length() ); for ( int i = 0 ; i < expectedText.length() ; i++ ) { if ( ! files.contains( expectedText.substring( i , i + 1 ) ) ) { return false; } } return true; } /** * Asserts files together contains all
s : ( String , String ) [] = { val lines : Array[String] = file.readLines.toArray val expectedLines : Array[String] = Array.ofDim[String](unexpectedText.length) for ( i <- 0 until unexpectedText.length ) { expectedLines(i) = lines(i) } assert ( lines == expectedLines ) } /** * Asserts file under [file] exists and does not contain any line from [unexpectedText] */ assertFileExistsAndDoesNotContain ( file : Path , vararg unexpectedText : String , ) : ( String , String ) [] = { val lines : Array[String] = file.readLines.toArray val expectedLines : Array[String] = Array.ofDim[String](unexpectedText.length) for ( i <- 0 until unexpectedText.length ) { expectedLines(i) = lines(i) } assert ( lines == expectedLines ) } /** * Asserts file under [file] exists and does not
unthrows AssertionError { if ( expected.exists() ) { if ( actual.exists() ) { if ( expected.stat().st_size != actual.stat().st_size ) { throw new AssertionError ( "Files are not equal." ); } } else { throw new AssertionError ( "Expected file does not exist." ); } } else { throw new AssertionError ( "Expected file does not exist." ); } } /** * Asserts that the content of two directories are equal. * @param expected The path to the expected directory. * @param actual The path to the actual directory. * @throws AssertionError if the contents of the two directories are not equal. */ budunthrows AssertionError { if ( expected.exists() ) { if ( actual.exists() ) { if ( expected.stat().st_size != actual.stat().st_

g . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGeneratedGradle . excludeGener
{ svgLogoPath = svgLogoPath ? svgLogoPath : ""; svgLogoPath = svgLogoPath ? svgLogoPath : ""; svgLogoPath = svgLogoPath ? svgLogoPath : ""; svgLogoPath = svgLogoPath ? svgLogoPath : ""; svgLogoPath = svgLogoPath ? svgLogoPath : ""; svgLogoPath = svgLogoPath ? svgLogoPath : ""; svgLogoPath = svgLogoPath ? svgLogoPath : ""; svgLogoPath = svgLogoPath ? svgLogoPath : ""; svgLogoPath = svgLogoPath ? svgLogoPath : ""; svgLogoPath = svgLogoPath ? svgLogoPath : ""; svgLogoPath = svgLogoPath ? svgLogoPath : ""; svgLogoPath = svgLog





( ) { var a = [1,2,3,4,5,6,7,8,9] var b = [1,2,3,4,5,6,7,8,9] var c = [1,2,3,4,5,6,7,8,9] var d = [1,2,3,4,5,6,7,8,9] var e = [1,2,3,4,5,6,7,8,9] var f = [1,2,3,4,5,6,7,8,9] var g = [1,2,3,4,5,6,7,8,9] var h = [1,2,3,4,5,6,7,8,9] var i = [1,2,3,4,5,6,7,8,9] var j = [1,2,3,4,5,6,7,8,9] var k = [1,2,3
{ firFile.action } /** * Access to [FirFile] declaration will be performed inside [action]. */ firfun withFile ( firFile : FirFile , action : ( ) -> Unit ) : Unit { firFile.action } /** * Access to [FirFile] declaration will be performed inside [action]. */ firfun withFile ( firFile : FirFile , action : ( ) -> Unit ) : Unit { firFile.action } /** * Access to [FirFile] declaration will be performed inside [action]. */ firfun withFile ( firFile : FirFile , action : ( ) -> Unit ) : Unit { firFile.action } /** * Access to [FirFile] declaration will be performed inside [action]. */ firfun withFile ( firFile : FirFile , action : ( ) -> Unit ) : Unit { firFile.action } /** * Access to [FirFile] declaration will be performed inside [action]. */ firfun withFile ( firFile : FirFile ,

= { var i = 0; while ( i < action.length ) { action[i](); i++; } } /** * Access to elements inside [FirScript] will be performed inside [action]. * * @param {FirScript} firScript * @param {FirScript} action * * @returns {FirScript} */ /** * Access to elements inside [FirScript] will be performed inside [action]. * * @param {FirScript} firScript * @param {FirScript} action * * @returns {FirScript} */ /** * Access to elements inside [FirScript] will be performed inside [action]. * * @param {FirScript} firScript * @param {FirScript} action * * @returns {FirScript} */ /** * Access to elements inside [FirScript] will be performed inside [action]. * * @param {FirScript} firScript * @param {FirScript} action * * @
fun ( target : LLFirResolveTarget ) : LLFirResolveState = match element with | None -> LLFirResolveState.None | _ -> match target with | None -> LLFirResolveState.None | _ -> match element with | None -> LLFirResolveState.None | _ -> match target with | None -> LLFirResolveState.None | _ -> match element with | None -> LLFirResolveState.None | _ -> match target with | None -> LLFirResolveState.None | _ -> match element with | None -> LLFirResolveState.None | _ -> match target with | None -> LLFirResolveState.None | _ -> match element with | None -> LLFirResolveState.None | _ -> match target with | None -> LLFirResolveState.None | _ ->

Fun KotlinNativeArtifactConfig . withPodspec ( configure : KotlinArtifactsPodspecExtension . ( ) -> Unit ) /** * Creates a new KotlinArtifact with the given configuration. * * @param name The name of the artifact. * @param config The configuration of the artifact. * @return A new KotlinArtifact. */ fun newKotlinArtifact(name : String, config : KotlinArtifactsPodspecExtension . ( ) -> Unit ) : KotlinArtifact /** * Creates a new KotlinArtifact with the given configuration. * * @param name The name of the artifact. * @param config The configuration of the artifact. * @return A new KotlinArtifact. */ fun newKotlinArtifact(name : String, config : KotlinArtifactsPodspecExtension . ( ) -> Unit ) : KotlinArtifact /** * Creates a new KotlinArtifact with the given configuration. * * @param name The name of the artifact. * @param config The configuration of the artifact. * @return A new Kotlin
= { var session : LLFirSession = LLFirSession (); session.module = module; return session; } /** * Returns an [LLFirSession] for the [module]. * For a binary module, the resulting session will be a binary (resolvable) one. */ getSession ( module : KtModule ) : LLFirSession session = { var session : LLFirSession = LLFirSession (); session.module = module; return session; } /** * Returns an [LLFirSession] for the [module]. * For a binary module, the resulting session will be a binary (non-resolvable) one. */ getSession ( module : KtModule ) : LLFirSession session = { var session : LLFirSession = LLFirSession (); session.module = module; return session; } /** * Returns an [LLFirSession] for the [module]. * For a binary module, the resulting session will be a binary (resolvable) one. */ getSession ( module :
( module : KtModule ) : LLFirResolvableSession { * * @param module The module. * * @return An analyzable [LLFirSession] for the module. * * Note: prefer using [getSession] unless you need to perform resolution actively. * Resolvable sessions for libraries are much less performant. */ public LLFirResolvableSession getResolvableSession ( module : KtModule ) : LLFirResolvableSession { * * @param module The module. * * @return An analyzable [LLFirSession] for the module. * * Note: prefer using [getSession] unless you need to perform resolution actively. * Resolvable sessions for libraries are much less performant. */ public LLFirResolvableSession getResolvableSession ( module : KtModule ) : LLFirResolvableSession { * * @param module The module. * * @return An analyzable [LLFirSession] for the module. * * Note: prefer using [getSession] unless you need to perform resolution
() : RegExp { return this } /** * Resets the regular expression so that subsequent [RegExp.test] and [RegExp.exec] calls will match starting with the end of the input string. */ fun RegExp . reset ( ) : RegExp { return this } /** * Resets the regular expression so that subsequent [RegExp.test] and [RegExp.exec] calls will match starting and ending with the input string. */ fun RegExp . reset ( ) : RegExp { return this } /** * Resets the regular expression so that subsequent [RegExp.test] and [RegExp.exec] calls will match starting and ending with the input string. */ fun RegExp . reset ( ) : RegExp { return this } /** * Resets the regular expression so that subsequent [RegExp.test] and [RegExp.exec] calls will match starting and ending with the input string. */ fun RegExp . reset ( ) : RegExp { return this } /** * Resets the regular expression so that subsequent [RegExp
public inline operator fun RegExpMatch . get ( index : Int , capturingParenthesis : Boolean = false ) : String ? * * @param index The index of the text to match. * @param capturingParenthesis If true, the text matched by the capturing parenthesis will be returned. * * @return The text matched by [RegExp.exec] if the [index] parameter is 0, or the text matched by the capturing parenthesis * at the given index. */ inline inline operator fun RegExpMatch . get ( index : Int , capturingParenthesis : Boolean = false ) : String ? * * @param index The index of the text to match. * @param capturingParenthesis If true, the text matched by the capturing parenthesis will be returned. * * @return The text matched by [RegExp.exec] if the [index] parameter is 0, or the text matched by the capturing parenthesis * at the given index. */ inline inline operator fun RegExpMatch . get ( index : Int , capturingParenthesis : Boolean = false ) : String ? * * @param index The index of the text to match. * @param
( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array ( ) : Array

fun performGCOnCleanerWorker ( ) : Unit { try { Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.sleep(1000) Thread.
fun main() { val workers = ArrayList<Future<Unit>>() workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(Future<Unit>) workers.add(
( Parcelable < T > ) : Parcelable < T > = Parcelable < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T > . Creator < T


( ) { var a = [1,2,3,4,5,6,7,8,9] var b = [1,2,3,4,5,6,7,8,9] var c = [1,2,3,4,5,6,7,8,9] var d = [1,2,3,4,5,6,7,8,9] var e = [1,2,3,4,5,6,7,8,9] var f = [1,2,3,4,5,6,7,8,9] var g = [1,2,3,4,5,6,7,8,9] var h = [1,2,3,4,5,6,7,8,9] var i = [1,2,3,4,5,6,7,8,9] var j = [1,2,3,4,5,6,7,8,9] var k = [1,2,3

( nullable : kotlin . Boolean , markerName : kotlin . String ) : FieldType . FrameFieldType ( nullable : kotlin . Boolean , markerName : kotlin . String ) : FieldType . FieldType ( nullable : kotlin . Boolean , markerName : kotlin . String ) : FieldType . FieldType ( nullable : kotlin . Boolean , markerName : kotlin . String ) : FieldType . FieldType ( nullable : kotlin . Boolean , markerName : kotlin . String ) : FieldType . FieldType ( nullable : kotlin . Boolean , markerName : kotlin . String ) : FieldType . FieldType ( nullable : kotlin . Boolean , markerName : kotlin . String ) : FieldType . FieldType ( nullable : kotlin . Boolean , markerName : kotlin . String ) : FieldType . FieldType ( nullable : kotlin . Boolean , markerName : kotlin . String ) : FieldType . FieldType ( nullable : kotlin . Boolean , markerName : kotlin . String ) : FieldType . FieldType ( nullable : k

public fun < T > label ( column : ColumnReference < T > , ) : NonPositionalMapping < T , String > */ /** * Maps the `label` aesthetic to a data column by [ColumnReference]. * * @param column the data column to map to the color. * @return a [NonPositionalMapping] object representing the mapping. */ /** * Maps the `label` aesthetic to a data column by [ColumnReference]. * * @param column the data column to map to the color. * @return a [NonPositionalMapping] object representing the mapping. */ /** * Maps the `label` aesthetic to a data column by [ColumnReference]. * * @param column the data column to map to the color. * @return a [NonPositionalMapping] object representing the mapping. */ /** * Maps the `label` aesthetic to a data column by [ColumnReference]. * * @param column the data column to map to the color. * @return a [NonPositionalMapping] object representing the mapping. */ /** * Maps the
{ return NonPositionalMapping< T , String >() } /** * Maps the `color` aesthetic to a data column by [KProperty]. * * @param column the data column to map to the color. * @return a [NonPositionalMapping] object representing the mapping. */ fun < T > color ( column : KProperty < T > , ) : NonPositionalMapping < T , String > /** * Maps the `size` aesthetic to a data column by [KProperty]. * * @param column the data column to map to the size. * @return a [NonPositionalMapping] object representing the mapping. */ fun < T > size ( column : KProperty < T > , ) : NonPositionalMapping < T , String > /** * Maps the `shape` aesthetic to a data column by [KProperty]. * * @param column the data column to map to the shape. * @return a [NonPositionalMapping] object representing the mapping. */ fun < T > shape ( column : KProperty < T > , ) : NonPositional
{ return NonPositionalMapping<Any ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? , String ? ,
public fun < T > label ( values : Iterable < T > , name : String ? = null , ) : NonPositionalMapping < T , String > /** * Maps the `color` aesthetic to iterable of values. * * @param values the iterable containing the values. * @param name optional name for this aesthetic mapping. * @return a [NonPositionalMapping] object representing the mapping. */ /** * Maps the `color` aesthetic to iterable of values. * * @param values the iterable containing the values. * @param name optional name for this aesthetic mapping. * @return a [NonPositionalMapping] object representing the mapping. */ /** * Maps the `size` aesthetic to iterable of values. * * @param values the iterable containing the values. * @param name optional name for this aesthetic mapping. * @return a [NonPositionalMapping] object representing the mapping. */ /** * Maps the `size` aesthetic to iterable of values. * * @param values the iterable containing the values. * @param name
: NonPositionalMapping < T , String > { return NonPositionalMapping< T , String >() } /** * Maps the `color` aesthetic to a data column. * * @param values the data column to map to the color. * @return a [NonPositionalMapping] object representing the mapping. */ fun < T > color ( values : DataColumn < T > , ) : NonPositionalMapping < T , String > = NonPositionalMapping< T , String >() /** * Maps the `size` aesthetic to a data column. * * @param values the data column to map to the size. * @return a [NonPositionalMapping] object representing the mapping. */ fun < T > size ( values : DataColumn < T > , ) : NonPositionalMapping < T , String > = NonPositionalMapping< T , String >() /** * Maps the `color` aesthetic to a data column. * * @param values the data column to map to the color. * @return a [NonPositionalMapping] object representing the mapping


* * Decodes an instance of [CDPResponse] from JSON-encoded [message]. * * [serializerForMessageId] is used for retrieving additional information about how to decode the response for the given message id. */ CDPResponse decodeCDPResponse ( message : String , serializerForMessageId : ( Int ) -> CDPMethodCallEncodingInfo ) : CDPResponse * * Decodes an instance of [CDPResponse] from JSON-encoded [message]. * * [serializerForMessageId] is used for retrieving additional information about how to decode the response for the given message id. */ CDPResponse decodeCDPResponse ( message : String , serializerForMessageId : ( Int ) -> CDPMethodCallEncodingInfo ) : CDPResponse * * Decodes an instance of [CDPResponse] from JSON-encoded [message]. * * [serializerForMessageId] is used for retrieving additional information about how to decode the response for the given message id. */ CDPResponse decodeCDPResponse ( message : String , serializerForMessage
: CDPMethodCallEncodingInfo = CDPMethodCallEncodingInfo( messageId = messageId , methodName = methodName , params = params ) /** * Returns the JSON message for invoking the method, as well as the information about how to decode its result. */ private inline fun < reified Response : CDPMethodInvocationResult , reified Params : CDPRequestParams > encodeCDPMethodCall ( messageId : Int , methodName : String , params : Params ? */ /** * Returns the JSON message for invoking the method, as well as the information about how to decode its result. */ private inline fun < reified Response : CDPMethodInvocationResult , reified Params : CDPRequestParams > encodeCDPMethodCall ( messageId : Int , methodName : String , params : Params ? */ /** * Returns the JSON message for invoking the method, as well as the information about how to decode its result. */ private inline fun < reified Response : CDPMethodInvocationResult , reified Params : CDPRequestParams > encodeCDPMethodCall
Response : CDPMethodInvocationResult * * @param encodeMethodCallWithMessageId passed a message id, expected to return the JSON-encoded CDP message * and some information about how to decode the response. */ fun genericEvaluateRequest ( encodeMethodCallWithMessageId : ( Int ) -> Pair < String , CDPMethodCallEncodingInfo > ) : CDPMethodInvocationResult /** * @param encodeMethodCallWithMessageId passed a message id, expected to return the JSON-encoded CDP message * and some information about how to decode the response. */ fun genericEvaluateRequest ( encodeMethodCallWithMessageId : ( Int ) -> Pair < String , CDPMethodCallEncodingInfo > ) : CDPMethodInvocationResult /** * @param encodeMethodCallWithMessageId passed a message id, expected to return the JSON-encoded CDP message * and some information about how to decode the response. */ fun genericEvaluateRequest ( encodeMethodCallWithMessageId : ( Int ) -> Pair < String , CDPMethodCallEncodingInfo > ) : CDPMet
* * @return true if the reporting is enabled, false otherwise. */ public static bool isEnabled ( ) { return runtime.Event.ExecutionContextCreated != null; } /** * Enables reporting of execution contexts destruction by means of [Runtime.Event.ExecutionContextDestroyed] event. * When the reporting gets enabled the event will be sent immediately for each existing execution context. * * See [Runtime.enable](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-enable) */ public static bool isEnabled ( ) { return runtime.Event.ExecutionContextDestroyed != null; } /** * Enables reporting of execution contexts creation by means of [Runtime.Event.ExecutionContextCreated] event. * When the reporting gets enabled the event will be sent immediately for each existing execution context. * * See [Runtime.enable](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-enable) */ public static bool isEnabled ( ) { return runtime.Event.Execution
*/ fun runIfWaitingForDebugger () = if (isWaitingForDebugger ()) Runtime.runIfWaitingForDebugger () /** * Tells inspected instance to run if it was waiting for debugger to detach. * * See [Runtime.runIfWaitingForDebugger](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-runIfWaitingForDebugger) */ buddetach fun runIfWaitingForDebugger () = if (isWaitingForDebugger ()) Runtime.runIfWaitingForDebugger () /** * Tells inspected instance to run if it was waiting for debugger to attach. * * See [Runtime.runIfWaitingForDebugger](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-runIfWaitingForDebugger) */ buddetach fun runIfWaitingForDebugger () = if (isWaitingForDebugger ()) Runtime.runIfWaitingForDebugger () /** * Tells inspected

* * @return true if the reporting is enabled, false otherwise. */ public static bool isEnabled ( ) { return runtime.Event.ExecutionContextCreated != null; } /** * Enables reporting of execution contexts destruction by means of [Runtime.Event.ExecutionContextDestroyed] event. * When the reporting gets enabled the event will be sent immediately for each existing execution context. * * See [Runtime.enable](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-enable) */ public static bool isEnabled ( ) { return runtime.Event.ExecutionContextDestroyed != null; } /** * Enables reporting of execution contexts creation by means of [Runtime.Event.ExecutionContextCreated] event. * When the reporting gets enabled the event will be sent immediately for each existing execution context. * * See [Runtime.enable](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-enable) */ public static bool isEnabled ( ) { return runtime.Event.Execution
* * Resumes JavaScript execution. * * See [Debugger.resume](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-resume) * * Resumes JavaScript execution. * * See [Debugger.resume](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-resume) * * Resumes JavaScript execution. * * See [Debugger.resume](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-resume) * * Resumes JavaScript execution. * * See [Debugger.resume](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-resume) * * Resumes JavaScript execution. * * See [Debugger.resume](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-resume) * * Resumes JavaScript execution. *


auskip * * @return New value for skip pauses state. */ fun setSkipAllPauses ( skip : Boolean ) { if ( skip ) { return true } else { return false } } /** * Makes page not interrupt on any breaks (breakpoint, exception, dom exception etc). * * See [Debugger.setSkipAllBreaks](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setSkipAllBreaks) * * @param skip New value for skip breaks state. * * @return New value for skip breaks state. */ fun setSkipAllBreaks ( skip : Boolean ) { if ( skip ) { return true } else { return false } } /** * Makes page not interrupt on any exceptions (exception, dom exception etc). * * See [Debugger.setSkipAllExceptions](https://chromedevtools.github.io/devtools-
( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( )

@BetaInteropApi */ public fun getOriginalKotlinClass ( objCClass : ObjCClass ) : KClass < * >? { if ( objCClass instanceof KClass ) { return objCClass } else { return null } } /** * If [objCClass] is a class generated to Objective-C header for Swift class, * returns [SwiftClass] for that original Swift class. * * Otherwise returns `null`. */ public fun getOriginalSwiftClass ( objCClass : ObjCClass ) : SwiftClass < * > ? { if ( objCClass instanceof SwiftClass ) { return objCClass } else { return null } } /** * If [objCClass] is a class generated to Objective-C header for Java class, * returns [JavaClass] for that original Java class. * * Otherwise returns `null`. */ public fun getOriginalJavaClass ( objCClass : ObjCClass ) : JavaCla
@BetaInteropApi /** * If [objCProtocol] is a protocol generated to Objective-C header for Kotlin class, * returns [KClass] for that original Kotlin class. * * Otherwise returns `null`. */ /** * If [objCProtocol] is a protocol generated to Objective-C header for Kotlin class, * returns [KClass] for that original Kotlin class. * * Otherwise returns `null`. */ /** * If [objCProtocol] is a protocol generated to Objective-C header for Kotlin class, * returns [KClass] for that original Kotlin class. * * Otherwise returns `null`. */ /** * If [objCProtocol] is a protocol generated to Objective-C header for Kotlin class, * returns [KClass] for that original Kotlin class. * * Otherwise returns `null`. */ /** * If [objCProtocol] is a protocol generated to Objective-C header for Kotlin class, * returns [KClass] for that original Kotlin class. * * Otherwise



( ) { var a = [1,2,3,4,5,6,7,8,9] var b = [1,2,3,4,5,6,7,8,9] var c = [1,2,3,4,5,6,7,8,9] var d = [1,2,3,4,5,6,7,8,9] var e = [1,2,3,4,5,6,7,8,9] var f = [1,2,3,4,5,6,7,8,9] var g = [1,2,3,4,5,6,7,8,9] var h = [1,2,3,4,5,6,7,8,9] var i = [1,2,3,4,5,6,7,8,9] var j = [1,2,3,4,5,6,7,8,9] var k = [1,2,3
{ var settings = [ { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository": { "repository":

/** * Creates a Char with the specified [code]. * * @sample samples.text.Chars.charFromCode */ /** * Creates a Char with the specified [code]. * * @sample samples.text.Chars.charFromCode */ /** * Creates a Char with the specified [code]. * * @sample samples.text.Chars.charFromCode */ /** * Creates a Char with the specified [code]. * * @sample samples.text.Chars.charFromCode */ /** * Creates a Char with the specified [code]. * * @sample samples.text.Chars.charFromCode */ /** * Creates a Char with the specified [code]. * * @sample samples.text.Chars.charFromCode */ /** * Creates a Char with the specified [code]. * * @sample samples.text.Chars.charFromCode */ /** * Creates a Char with the specified [code]. * * @sample samples.text
( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) : KotlinGradlePluginExtensionPoint ( ) :


lease = false /** * Acquires a permit from this semaphore without suspension. * * @return `true` if a permit was acquired, `false` otherwise. */ private fun tryAcquire ( ) : Boolean /** * Acquires a permit from this semaphore without suspension. * * @return `true` if a permit was acquired, `false` otherwise. */ private fun tryAcquire ( ) : Boolean /** * Acquires a permit from this semaphore without suspension. * * @return `true` if a permit was acquired, `false` otherwise. */ private fun tryAcquire ( ) : Boolean /** * Acquires a permit from this semaphore without suspension. * * @return `true` if a permit was acquired, `false` otherwise. */ private fun tryAcquire ( ) : Boolean /** * Acquires a permit from this semaphore without suspension. * * @return `true` if a permit was acquired, `false` otherwise. */ private fun tryAcquire ( ) : Boolean /** * Acquires a permit from this semaph
Permit () = { if ( this.acquirer == null ) { this.acquirer = this.semaphore.acquire () } this.semaphore.release () } /** * Releases a permit, returning it into this semaphore. Resumes the first * suspending acquirer if there is one at the point of invocation. * Throws [IllegalStateException] if the number of [release] invocations is greater than the number of preceding [acquire]. */ releasePermit () = { if ( this.acquirer == null ) { this.acquirer = this.semaphore.acquire () } this.semaphore.release () } /** * Releases a permit, returning it into this semaphore. Resumes the first * suspending acquirer if there is one at the point of invocation. * Throws [IllegalStateException] if the number of [release] invocations is greater than the number of preceding [acquire]. */ releasePermit () = { if ( this.acquirer == null ) {
{ var permits = permits var acquiredPermits = acquiredPermits if ( acquiredPermits < 0 ) acquiredPermits = 0 if ( acquiredPermits > permits ) acquiredPermits = permits if ( acquiredPermits < 0 ) acquiredPermits = 0 if ( acquiredPermits > permits ) acquiredPermits = permits if ( acquiredPermits < 0 ) acquiredPermits = 0 if ( acquiredPermits > permits ) acquiredPermits = permits if ( acquiredPermits < 0 ) acquiredPermits = 0 if ( acquiredPermits > permits ) acquiredPermits = permits if ( acquiredPermits < 0 ) acquiredPermits = 0 if ( acquiredPermits > permits ) acquiredPermits = permits if ( acquiredPermits < 0 ) acquiredPermits = 0 if ( acquiredPermits > permits ) acquiredPermits = permits if ( acquiredPermits < 0 ) acquiredPermits = 0 if ( acquiredPermits > permits ) acquiredPermits = permits if ( acquiredPermits < 0 ) acquiredPermits = 0 if ( acquiredPermits > permits ) acquiredPermits =
* */ public suspend inline fun < T > Semaphore . withPermit ( action : ( ) -> T ) : T { semaphore.acquire() action() semaphore.release() } /** * Executes the given [action], acquiring a permit from this semaphore at the beginning * and releasing it after the [action] is completed. * * @return the return value of the [action]. */ public suspend inline fun < T > Semaphore . withPermit ( action : ( ) -> T ) : T { semaphore.acquire() action() semaphore.release() } /** * Executes the given [action], acquiring a permit from this semaphore at the beginning * and releasing it after the [action] is completed. * * @return the return value of the [action]. */ public suspend inline fun < T > Semaphore . withPermit ( action : ( ) -> T ) : T { semaphore.acquire() action() semaphore.release()
private { val permits = this.permits if ( permits > 0 ) { permits -= 1 if ( permits < 0 ) { permits = 0 } } else { permits = 0 } this.permits = permits return permits } /** * Increases the number of available permits * and ensures that it is not greater than [permits] * at the point of increment. The last may happen * due to an incorrect `release()` call without * a preceding `acquire()`. */ balloonprivate fun incPermits ( ) : Int balloon private { val permits = this.permits if ( permits > 0 ) { permits += 1 if ( permits < 0 ) { permits = 0 } } else { permits = 0 } this.permits = permits return permits } /** * Releases a permit * and decrements the number of available permits * and ensures that it is not greater than [permits] * at the point of release. The
: Int { if ( this.availablePermits > this.maxPermits ) { this.availablePermits = this.maxPermits } return this.availablePermits } /** * Changes the number of available permits to * [permits] if it became greater due to an * incorrect [release] call. */ coerceAvailablePermitsAtMinimum ( ) : Int { if ( this.availablePermits < this.minPermits ) { this.availablePermits = this.minPermits } return this.availablePermits } /** * Changes the number of available permits to * [permits] if it became greater due to an * incorrect [release] call. */ coerceAvailablePermitsAtMaximum ( ) : Int { if ( this.availablePermits > this.maxPermits ) { this.availablePermits = this.maxPermits } return this.availablePermits } /** * Changes the number of available permits to * [permits] if it became greater due to an * incorrect [release
q = false /** * Returns `false` if the received permit cannot be used and the calling operation should restart. */ addAcquireToQueue ( waiter : Waiter ) : Boolean /** * Returns `false` if the received permit cannot be used and the calling operation should restart. */ addAcquireToQueue ( waiter : Waiter ) : Boolean /** * Returns `false` if the received permit cannot be used and the calling operation should restart. */ addAcquireToQueue ( waiter : Waiter ) : Boolean /** * Returns `false` if the received permit cannot be used and the calling operation should restart. */ addAcquireToQueue ( waiter : Waiter ) : Boolean /** * Returns `false` if the received permit cannot be used and the calling operation should restart. */ addAcquireToQueue ( waiter : Waiter ) : Boolean /** * Returns `false` if the received permit cannot be used and the calling operation should restart. */ addAcquireToQueue ( waiter : Waiter ) : Boolean /** * Returns `false` if the received permit cannot be used and the calling operation should restart. *
abstract = { val first = this.first val last = this.last val step = this.step if (first == null || last == null) { return null } if (step < 0) { first = last last = first step = -step } if (step < 0) { first = last last = first step = -step } if (step < 0) { first = last last = first step = -step } if (step < 0) { first = last last = first step = -step } if (step < 0) { first = last last = first step = -step } if (step < 0) { first = last last = first step = -step } if (step < 0) { first = last last = first step = -step } if (step < 0) { first
{ if ( expression == null ) { return false; } if ( expression.isEmpty() ) { return false; } if ( expression.head == '*' ) { return true; } if ( expression.head == '+' ) { return true; } if ( expression.head == '-' ) { return true; } if ( expression.head == '/' ) { return true; } if ( expression.head == '^' ) { return true; } if ( expression.head == '(' ) { return true; } if ( expression.head == ')' ) { return true; } if ( expression.head == '[' ) { return true; } if ( expression.head == ']' ) { return true; } if ( expression.head == '{' ) { return true; } if ( expression.head == '}' ) {
{ if ( matcher == null ) { return false; } if ( matcher.matches ( call ) ) { return true; } return false; } /** * Matches the `iterator()` call that produced the iterable; if the call matches (or the matcher is null), * the handler can build a [HeaderInfo] from the iterable. */ matcher matchIteratorCall ( call : IrCall ) : Boolean matcher { if ( matcher == null ) { return false; } if ( matcher.matches ( call ) ) { return true; } return false; } /** * Matches the `iterator()` call that produced the iterable; if the call matches (or the matcher is null), * the handler can build a [HeaderInfo] from the iterable. */ matcher matcherIteratorCall ( call : IrCall ) : Boolean matcher { if ( matcher == null ) { return false; } if ( matcher.matches ( call )
fun ( expression : E , data : D , scopeOwner : IrSymbol ) : HeaderInfo { if ( expression == null ) { return null; } if ( data == null ) { return null; } if ( scopeOwner == null ) { return null; } return new HeaderInfo ( expression , data , scopeOwner ); } /** Builds a [Header] from the expression. */ headerfun ( expression : E , data : D , scopeOwner : IrSymbol ) : Header { if ( expression == null ) { return null; } if ( data == null ) { return null; } if ( scopeOwner == null ) { return null; } return new Header ( expression , data , scopeOwner ); } /** Builds a [HeaderInfo] from the expression. */ headerfun ( expression : E , data : D , scopeOwner : IrSymbol ) : HeaderInfo { if ( expression == null ) { return null; } if ( data == null ) {
override fun visitCall ( expression : IrCall , data : IrCall ? ) : HeaderInfo ? /** Builds a [HeaderInfo] for iterable expressions that are calls (e.g., `.reversed()`, `.indices`). */ /** Builds a [HeaderInfo] for iterable expressions that are calls (e.g., `.reversed()`, `.indices`). */ /** Builds a [HeaderInfo] for iterable expressions that are calls (e.g., `.reversed()`, `.indices`). */ /** Builds a [HeaderInfo] for iterable expressions that are calls (e.g., `.reversed()`, `.indices`). */ /** Builds a [HeaderInfo] for iterable expressions that are calls (e.g., `.reversed()`, `.indices`). */ /** Builds a [HeaderInfo] for iterable expressions that are calls (e.g., `.reversed()`, `.indices`). */ /** Builds a [HeaderInfo] for iterable expressions that are calls (e.g., `.re
override fun visitCall ( call : IrCall , data : IrCall ? ) : HeaderInfo ? moveroverride fun visitCall ( call : IrCall , data : IrCall ? ) : HeaderInfo ? moveroverride fun visitCall ( call : IrCall , data : IrCall ? ) : HeaderInfo ? moveroverride fun visitCall ( call : IrCall , data : IrCall ? ) : HeaderInfo ? moveroverride fun visitCall ( call : IrCall , data : IrCall ? ) : HeaderInfo ? moveroverride fun visitCall ( call : IrCall , data : IrCall ? ) : HeaderInfo ? moveroverride fun visitCall ( call : IrCall , data : IrCall ? ) : HeaderInfo ? moveroverride fun visitCall ( call : IrCall , data : IrCall ? ) : HeaderInfo ? moveroverride fun visitCall ( call : IrCall , data : IrCall ? ) : HeaderInfo ? moveroverride fun visitCall ( call : IrCall , data : IrCall ? ) : HeaderInfo ? moveroverride fun visitCall ( call : IrCall , data : IrCall ? ) : HeaderInfo ? moveroverride fun
. withEnvironment ( build : MutableMap < String , String ? > . ( ) -> Unit ) . withEnvironment ( build : MutableMap < String , String ? > . ( ) -> Unit ) . withEnvironment ( build : MutableMap < String , String ? > . ( ) -> Unit ) . withEnvironment ( build : MutableMap < String , String ? > . ( ) -> Unit ) . withEnvironment ( build : MutableMap < String , String ? > . ( ) -> Unit ) . withEnvironment ( build : MutableMap < String , String ? > . ( ) -> Unit ) . withEnvironment ( build : MutableMap < String , String ? > . ( ) -> Unit ) . withEnvironment ( build : MutableMap < String , String ? > . ( ) -> Unit ) . withEnvironment ( build : MutableMap < String , String ? > . ( ) -> Unit ) . withEnvironment ( build : MutableMap < String , String ? > . ( ) -> Unit ) . withEnvironment ( build : MutableMap < String , String ? > . ( ) -> Unit ) . withEnvironment ( build : MutableMap < String , String ? > . ( ) -> Unit ) . withEnvironment (
{ var args : List<String> = new ArrayList<String>(); for ( var arg : arguments ) { args.add(arg); } return this; } /** * Helper function to _remove_ [arguments] from any existing * [GradleRunner arguments][GradleRunner.getArguments]. */ varfun GradleRunner . removeArguments ( vararg arguments : String ) : GradleRunner { var args : List<String> = new ArrayList<String>(); for ( var arg : arguments ) { args.remove(arg); } return this; } /** * Helper function to _append_ [arguments] to any existing * [GradleRunner arguments][GradleRunner.getArguments]. */ varfun GradleRunner . appendArguments ( vararg arguments : String ) : GradleRunner { var args : List<String> = new ArrayList<String>(); for ( var arg : arguments ) { args.add(arg); }
ternal fun < T : Task , R : Any > TaskCollection < T > . implementing ( kclass : KClass < R > ) : TaskCollection < T > . implementing ( kclass : KClass < R > ) : TaskCollection < T > . implementing ( kclass : KClass < R > ) : TaskCollection < T > . implementing ( kclass : KClass < R > ) : TaskCollection < T > . implementing ( kclass : KClass < R > ) : TaskCollection < T > . implementing ( kclass : KClass < R > ) : TaskCollection < T > . implementing ( kclass : KClass < R > ) : TaskCollection < T > . implementing ( kclass : KClass < R > ) : TaskCollection < T > . implementing ( kclass : KClass < R > ) : TaskCollection < T > . implementing ( kclass : KClass < R > ) : TaskCollection < T > . implementing ( kclass : KClass < R > ) : TaskCollection < T > . implementing ( kclass : KClass < R > ) : TaskCollection < T > . implementing ( kclass : KClass < R > ) : TaskCollection < T > . implementing ( kclass :
*/ /** * Check that the `whenEvaluated` actions that are scheduled before the Android plugin is applied get triggered only after the actions * done in the Android plugin's afterEvaluate phase */ /** * Check that the `whenEvaluated` actions that are scheduled before the Android plugin is applied get triggered only after the actions * done in the Android plugin's afterEvaluate phase */ /** * Check that the `whenEvaluated` actions that are scheduled before the Android plugin is applied get triggered only after the actions * done in the Android plugin's afterEvaluate phase */ /** * Check that the `whenEvaluated` actions that are scheduled before the Android plugin is applied get triggered only after the actions * done in the Android plugin's afterEvaluate phase */ /** * Check that the `whenEvaluated` actions that are scheduled before the Android plugin is applied get triggered only after the actions * done in the Android plugin's afterEvaluate phase */ /** * Check that the `whenEvaluated` actions that are scheduled before the Android plugin is applied get triggered only after the













